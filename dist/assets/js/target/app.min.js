var PRS$0 = function(o, t) {
    o["__proto__"] = {
        a: t
    };
    return o["a"] === t;
}({}, {});

var DP$0 = Object.defineProperty;

var GOPD$0 = Object.getOwnPropertyDescriptor;

var MIXIN$0 = function(t, s) {
    for (var p in s) {
        if (s.hasOwnProperty(p)) {
            DP$0(t, p, GOPD$0(s, p));
        }
    }
    return t;
};

(function(e) {
    function f(a, c) {
        function b(a) {
            if (!this || this.constructor !== b) return new b(a);
            this._keys = [];
            this._values = [];
            this._itp = [];
            this.objectOnly = c;
            a && v.call(this, a);
        }
        c || w(a, "size", {
            get: x
        });
        a.constructor = b;
        b.prototype = a;
        return b;
    }
    function v(a) {
        this.add ? a.forEach(this.add, this) : a.forEach(function(a) {
            this.set(a[0], a[1]);
        }, this);
    }
    function d(a) {
        this.has(a) && (this._keys.splice(b, 1), this._values.splice(b, 1), this._itp.forEach(function(a) {
            b < a[0] && a[0]--;
        }));
        return -1 < b;
    }
    function m(a) {
        return this.has(a) ? this._values[b] : void 0;
    }
    function n(a, c) {
        if (this.objectOnly && c !== Object(c)) throw new TypeError("Invalid value used as weak collection key");
        if (c != c || 0 === c) for (b = a.length; b-- && !y(a[b], c); ) ; else b = a.indexOf(c);
        return -1 < b;
    }
    function p(a) {
        return n.call(this, this._values, a);
    }
    function q(a) {
        return n.call(this, this._keys, a);
    }
    function r(a, c) {
        this.has(a) ? this._values[b] = c : this._values[this._keys.push(a) - 1] = c;
        return this;
    }
    function t(a) {
        this.has(a) || this._values.push(a);
        return this;
    }
    function h() {
        this._values.length = 0;
    }
    function z() {
        return k(this._itp, this._keys);
    }
    function l() {
        return k(this._itp, this._values);
    }
    function A() {
        return k(this._itp, this._keys, this._values);
    }
    function B() {
        return k(this._itp, this._values, this._values);
    }
    function k(a, c, b) {
        var g = [ 0 ], e = !1;
        a.push(g);
        return {
            next: function() {
                var f, d = g[0];
                !e && d < c.length ? (f = b ? [ c[d], b[d] ] : c[d], g[0]++) : (e = !0, a.splice(a.indexOf(g), 1));
                return {
                    done: e,
                    value: f
                };
            }
        };
    }
    function x() {
        return this._values.length;
    }
    function u(a, c) {
        for (var b = this.entries(); ;) {
            var d = b.next();
            if (d.done) break;
            a.call(c, d.value[1], d.value[0], this);
        }
    }
    var b, w = Object.defineProperty, y = function(a, b) {
        return isNaN(a) ? isNaN(b) : a === b;
    };
    "undefined" == typeof WeakMap && (e.WeakMap = f({
        "delete": d,
        clear: h,
        get: m,
        has: q,
        set: r
    }, !0));
    "undefined" != typeof Map && new Map().values().next || (e.Map = f({
        "delete": d,
        has: q,
        get: m,
        set: r,
        keys: z,
        values: l,
        entries: A,
        forEach: u,
        clear: h
    }));
    "undefined" != typeof Set && new Set().values().next || (e.Set = f({
        has: p,
        add: t,
        "delete": d,
        clear: h,
        keys: l,
        values: l,
        entries: B,
        forEach: u
    }));
    "undefined" == typeof WeakSet && (e.WeakSet = f({
        "delete": d,
        add: t,
        clear: h,
        has: p
    }, !0));
})("undefined" != typeof exports && "undefined" != typeof global ? global : window);

(function() {
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(elt) {
            var len = this.length >>> 0;
            var from = Number(arguments[1]) || 0;
            from = from < 0 ? Math.ceil(from) : Math.floor(from);
            if (from < 0) from += len;
            for (;from < len; from++) {
                if (from in this && this[from] === elt) return from;
            }
            return -1;
        };
    }
    if (typeof String.prototype.trim !== "function") {
        String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, "");
        };
    }
})();

var Observer = function() {
    "use strict";
    var proto$0 = {};
    function Observer() {
        this._events = new Map();
    }
    DP$0(Observer, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false
    });
    proto$0.register = function(subject) {
        this._events.set(subject, []);
    };
    proto$0.watch = function(subject, action) {
        this._events.get(subject).push(action);
    };
    proto$0.notify = function(subject, oldValue, newValue) {
        var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
        var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
        function GET_ITER$0(v) {
            if (v) {
                if (Array.isArray(v)) return 0;
                var f;
                if (S_MARK$0) S_MARK$0(v);
                if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                    if (S_MARK$0) S_MARK$0(void 0);
                    return f.call(v);
                }
                if (S_MARK$0) S_MARK$0(void 0);
                if (v + "" === "[object Generator]") return v;
            }
            throw new Error(v + " is not iterable");
        }
        var $D$0;
        var $D$1;
        var $D$2;
        var $D$3;
        $D$3 = this._events.get(subject);
        $D$0 = GET_ITER$0($D$3);
        $D$2 = $D$0 === 0;
        $D$1 = $D$2 ? $D$3.length : void 0;
        for (var action; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
            action = $D$2 ? $D$3[$D$0++] : $D$1["value"];
            action.apply(null, [ oldValue, newValue ]);
        }
        $D$0 = $D$1 = $D$2 = $D$3 = void 0;
    };
    MIXIN$0(Observer.prototype, proto$0);
    proto$0 = void 0;
    return Observer;
}();

var BaseDiff = function() {
    "use strict";
    var proto$0 = {};
    function BaseDiff() {
        if (typeof this._initDiff !== "function") {
            throw new TypeError("Method _initDiff must be implemented");
        }
        this._init();
    }
    DP$0(BaseDiff, "prototype", {
        configurable: false,
        enumerable: false,
        writable: false
    });
    proto$0._init = function() {
        this._panels = {};
        this._panelCount = 0;
        this._dataCount = 0;
        this._order = 0;
    };
    proto$0.addPanel = function(id) {
        this._panelCount++;
        this._panels[id] = {
            data: [],
            onComplete: null,
            order: this._setOrder()
        };
    };
    proto$0._setOrder = function() {
        var o = this._order;
        this._order++;
        return o;
    };
    proto$0.onComplete = function(id, completeCb) {
        this._panels[id].onComplete = completeCb;
    };
    proto$0.onDestroy = function() {
        this._init();
    };
    proto$0.setData = function(deploymentID, data) {
        this._dataCount++;
        this._panels[deploymentID].data = data;
        if (this._panelCount < 2) {
            return;
        }
        if (this._panelCount === this._dataCount) {
            this._panelCount = 0;
            this._dataCount = 0;
            this._initDiff();
        }
    };
    proto$0._complete = function(newP) {
        for (var panel in newP) {
            this._panels[panel].onComplete(newP[panel]);
        }
    };
    MIXIN$0(BaseDiff.prototype, proto$0);
    proto$0 = void 0;
    return BaseDiff;
}();

(function() {
    var core = angular.module("atCore", [ "RealProgress", "angular-jwt", "LocalStorageModule" ]);
    var api = angular.module("atAPI", []);
    var loginApp = angular.module("atUILogin", [ "ngAnimate", "ngRoute", "atAPI", "atCore" ]);
    var app = angular.module("atUI", [ "xeditable", "ngAnimate", "ngTagsInput", "ngRoute", "ui.knob", "angularMoment", "cfp.hotkeys", "ngCookies", "ngFx", "atAPI", "atCore", "ngSanitize", "ngDropzone", "chart.js" ]);
    app.run([ "editableOptions", function(editableOptions) {
        editableOptions.theme = "bs3";
    } ]);
    app.config([ "$routeProvider", "localStorageServiceProvider", function($routeProvider, localStorageServiceProvider) {
        $routeProvider.otherwise({
            redirectTo: "/home/dashboard"
        });
        localStorageServiceProvider.setPrefix("atUI");
        localStorageServiceProvider.setStorageCookie(0);
    } ]);
    loginApp.config([ "localStorageServiceProvider", function(localStorageServiceProvider) {
        localStorageServiceProvider.setPrefix("atUI");
        localStorageServiceProvider.setStorageCookie(0);
    } ]);
    app.service("$locationEx", [ "$location", "$route", "$rootScope", function($location, $route, $rootScope) {
        $location.skipReload = function() {
            var lastRoute = $route.current;
            var un = $rootScope.$on("$locationChangeSuccess", function() {
                $route.current = lastRoute;
                un();
            });
            return $location;
        };
        return $location;
    } ]);
    app.config([ "$httpProvider", "jwtInterceptorProvider", function($httpProvider, jwtInterceptorProvider) {
        jwtInterceptorProvider.tokenGetter = [ "localStorageService", "config", function(localStorageService, config) {
            if (config.url.substr(config.url.length - 5) == ".html") {
                return null;
            }
            var token = localStorageService.get("token");
            return token;
        } ];
        $httpProvider.interceptors.push("jwtInterceptor");
    } ]);
})();

$(function() {
    $(".addons").popover({
        trigger: "hover"
    });
    $(".tooltipTrigger").tooltip({});
});

(function() {
    var app = angular.module("atUI");
    app.controller("AppController", [ "$scope", "LocaleLabels", "$log", "StoreService", "UserService", "$route", "$timeout", "LoadingScreenService", "localStorageService", function($scope, LocaleLabels, $log, StoreService, UserService, $route, $timeout, LoadingScreenService, localStorageService) {
        var _token = localStorageService.get("token");
        if (_token === null) {
            window.location = "/login.html";
        }
        $scope.$on("$routeChangeStart", function(e, u) {
            if (!u.hasOwnProperty("$$route") || u.$$route.originalPath === "/login") {
                return;
            }
            _ping();
        });
        var _ping = function() {
            UserService.ping(function() {
                $scope.isOk = "assets/templates/core/layout/app.html";
            });
        };
        $scope.words = {};
        LocaleLabels.onRefresh(function(labels) {
            $scope.words = labels;
        });
        $scope.leftOff = StoreService.getWhereWeLeftOff();
        $scope.nameLeftOff = StoreService.getRawLeftOff();
        $scope.isOk = null;
        $scope.$watch("isOk", function(newValue, oldValue) {
            if (newValue !== null) {
                $route.reload();
            }
        });
        $scope.$on("refresh-failed-ping", function() {
            LoadingScreenService.show();
            $timeout(function() {
                _ping();
                LoadingScreenService.hide();
            }, 5e3);
        });
        $scope.$on("$destroy", function() {
            $log.warn("AppController is now being destroyed! Should never happen...");
        });
    } ]);
    app.filter("leftOffName", [ function() {
        return function(route) {
            route = route || null;
            if (route === null) {
                return "";
            }
            if (route.indexOf("/") !== false) {
                route = route.substr(1);
            }
            route = route.replace(/\/(\w+)\//gi, ", ").replace(/_/gi, " ");
            var s = route.split(" ");
            var r = "";
            for (var i in s) {
                if (parseInt(i) === 0) {
                    r += s[i] + " ";
                    continue;
                }
                r += s[i].charAt(0).toUpperCase() + s[i].slice(1) + " ";
            }
            return route;
        };
    } ]);
})();

(function() {
    angular.module("atUI").directive("deploymentsToolbarItem", [ "PlatformService", function(PlatformService) {
        return {
            templateUrl: "assets/templates/core/layout/header/deploymentsToolbarItem.html",
            controller: function($scope, $element) {
                $scope.deployments = [];
                $scope.selectedDeployment = null;
                PlatformService.onChange(function() {
                    $scope.deployments = PlatformService.getPlatforms();
                    $scope.selectedDeployment = PlatformService.current;
                });
                PlatformService.fetchPlatforms(function() {
                    $scope.deployments = PlatformService.getPlatforms();
                    $scope.selectedDeployment = PlatformService.current;
                });
                $scope.selectDeployment = function(deployment) {
                    $scope.selectedDeployment = deployment;
                    PlatformService.current = deployment;
                };
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("navBarTrigger", [ "NavBarToggleService", function(NavBarToggleService) {
        return {
            controller: function($scope, $element) {
                $scope.toggle = function() {
                    if (NavBarToggleService.currentState() === true) {
                        $element.find("a").attr("title", "Show Menu");
                    } else {
                        $element.find("a").attr("title", "Hide Menu");
                    }
                    NavBarToggleService.toggleState();
                };
            },
            link: function(scope, element, attrs) {
                NavBarToggleService.setStageLeft($("#stage").css("left"));
            }
        };
    } ]);
    app.service("NavBarToggleService", function() {
        var _opened = true;
        var _stageLeft = 0;
        var _events = {
            open: [],
            close: []
        };
        var _runActionsFor = function(action) {
            for (var i in _events[action]) {
                _events[action][i].apply(null, []);
            }
        };
        this.currentState = function() {
            return _opened;
        };
        this.toggleState = function() {
            _opened = !_opened;
            if (_opened) {
                _runActionsFor("open");
            } else {
                _runActionsFor("close");
            }
        };
        this.doOpen = function() {
            if (_opened === false) {
                this.toggleState();
            }
        };
        this.doClose = function() {
            if (_opened) {
                this.toggleState();
            }
        };
        this.setStageLeft = function(left) {
            _stageLeft = left;
        };
        this.getStageLeft = function() {
            return _stageLeft;
        };
        this.on = function(action, cb) {
            _events[action].push(cb);
        };
    });
})();

(function() {
    angular.module("atUI").directive("languageToolbarItem", [ "LocaleLabels", function(LocaleLabels) {
        return {
            templateUrl: "assets/templates/core/layout/header/languageToolbarItem.html",
            controller: function($scope, $element) {
                $scope.langSelected = "English";
                $scope.locales = [ {
                    id: "en-us",
                    label: "English"
                }, {
                    id: "es-mx",
                    label: "Spanish"
                } ];
                $scope.selectLang = function(lang) {
                    $scope.langSelected = lang.label;
                    LocaleLabels.refreshLabels(lang);
                };
                $scope.selectLang($scope.locales[0]);
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("LocaleLabels", [ "APIService", function(APIService) {
        this.locales = {
            labels: {},
            cache: {}
        };
        var on = [];
        this.doOnRefresh = function() {
            for (var i in on) {
                on[i].apply(null, [ this.locales.labels ]);
            }
        };
        this.onRefresh = function(cb) {
            on.push(cb);
        };
        this.refreshLabels = function(locale) {
            var ref = this;
            if (!ref.locales.cache.hasOwnProperty(locale.id)) {
                APIService.get("locals/labels_" + locale.id).success(function(data) {
                    ref.locales.cache[locale.id] = data;
                    ref.locales.labels = ref.locales.cache[locale.id];
                    ref.doOnRefresh();
                }).error(function(data, status) {
                    console.error(data, status);
                });
            } else {
                ref.locales.labels = ref.locales.cache[locale.id];
                ref.doOnRefresh();
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").directive("toolbarItemsHolder", [ "ToolbarService", "$compile", function(ToolbarService, $compile) {
        return {
            controller: function($scope, $element) {
                $scope.tools = [];
                var _redered = [];
                var _compileItem = function(item) {
                    var temp = '<div class="btn-group" ng-show="tools[' + ($scope.tools.length - 1) + '].display" ' + item.directive.replace(/([A-Z])/g, function($1) {
                        return "-" + $1.toLowerCase();
                    }) + "></div>";
                    $element.append($compile(temp)($scope));
                };
                ToolbarService.watch("change", function(oldValue, newValue) {
                    $scope.tools = newValue;
                    if (oldValue.length < newValue.length) {
                        var item = angular.copy(newValue).pop();
                        _compileItem(item);
                    }
                });
                ToolbarService.add({
                    id: "core/Language",
                    directive: "languageToolbarItem"
                });
                ToolbarService.add({
                    id: "core/Deployments",
                    directive: "deploymentsToolbarItem"
                });
            }
        };
    } ]);
})();

(function() {
    var ToolbarService = function(super$0) {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var SP$0 = Object.setPrototypeOf || function(o, p) {
            if (PRS$0) {
                o["__proto__"] = p;
            } else {
                DP$0(o, "__proto__", {
                    value: p,
                    configurable: true,
                    enumerable: false,
                    writable: true
                });
            }
            return o;
        };
        var OC$0 = Object.create;
        if (!PRS$0) MIXIN$0(ToolbarService, super$0);
        var proto$0 = {};
        function ToolbarService() {
            super$0.call(this);
            this.register("change");
            this.tools = [];
        }
        if (super$0 !== null) SP$0(ToolbarService, super$0);
        ToolbarService.prototype = OC$0(super$0 !== null ? super$0.prototype : null, {
            constructor: {
                value: ToolbarService,
                configurable: true,
                writable: true
            }
        });
        DP$0(ToolbarService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0.getTools = function() {
            return this.tools;
        };
        proto$0._itExists = function(toolID) {
            for (var i in this.tools) {
                if (toolID === this.tools[i].id) {
                    return i;
                }
            }
            return false;
        };
        proto$0.add = function(tool) {
            var _old = angular.copy(this.tools);
            var i = this._itExists(tool.id);
            if (i !== false) {
                this.tools[i].display = true;
                this.notify("change", _old, this.tools);
                return;
            }
            tool.display = true;
            this.tools.push(tool);
            this.notify("change", _old, this.tools);
        };
        proto$0.remove = function(toolID) {
            for (var i in this.tools) {
                if (this.tools[i].id === toolID) {
                    var _old = this.tools;
                    this.tools[i].display = false;
                    this.notify("change", _old, this.tools);
                    return;
                }
            }
        };
        MIXIN$0(ToolbarService.prototype, proto$0);
        proto$0 = void 0;
        return ToolbarService;
    }(Observer);
    angular.module("atUI").service("ToolbarService", [ ToolbarService ]);
})();

(function() {
    var PRS$0 = function(o, t) {
        o["__proto__"] = {
            a: t
        };
        return o["a"] === t;
    }({}, {});
    var DP$0 = Object.defineProperty;
    var GOPD$0 = Object.getOwnPropertyDescriptor;
    var MIXIN$0 = function(t, s) {
        for (var p in s) {
            if (s.hasOwnProperty(p)) {
                DP$0(t, p, GOPD$0(s, p));
            }
        }
        return t;
    };
    var app = angular.module("atUI");
    var NavBarController = function() {
        "use strict";
        var proto$0 = {};
        function NavBarController($scope, $element, $compile, NavService, $location, NavBarToggleService) {
            this.$scope = $scope;
            this.$element = $element;
            this.$compile = $compile;
            this.NavService = NavService;
            this.$location = $location;
            this.NavBarToggleService = NavBarToggleService;
            this._init();
        }
        DP$0(NavBarController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            this._initScope();
        };
        proto$0._initScope = function() {
            var self = this;
            this.$scope.links = null;
            this.$scope.$on("$locationChangeSuccess", function() {
                self.setCurrentLocation(self.$location.path());
            });
            this.NavService.fetch(function(data) {
                self.$scope.links = data;
                self.setCurrentLocation(self.$location.path());
                self._render();
            });
            this.NavBarToggleService.on("open", function() {
                self.showMenu();
            });
            this.NavBarToggleService.on("close", function() {
                self.hideMenu();
            });
        };
        proto$0.showMenu = function() {
            var self = this;
            var $stage = $("#stage");
            $stage.stop(true).animate({
                left: self.NavBarToggleService.getStageLeft()
            });
            this.$element.stop(true).animate({
                width: "240px"
            }, 350, function() {
                self.$element.children("ul").stop(true).slideDown();
            });
        };
        proto$0.hideMenu = function() {
            var self = this;
            var $stage = $("#stage");
            this.$element.children("ul").stop(true).slideUp(function() {
                $stage.stop(true).animate({
                    left: 0
                });
                self.$element.stop(true).animate({
                    width: 0
                }, 350);
            });
        };
        proto$0.setCurrentLocation = function(location) {
            this.$scope.currentLocation = location;
            this._syncWithLinks();
        };
        proto$0.open = function(link) {
            for (var i in this.$scope.links) {
                if (this.$scope.links[i].uiNavParentID === link.uiNavParentID) {
                    this.$scope.links[i].__ACTIVE = true;
                } else {
                    this.$scope.links[i].__ACTIVE = false;
                }
            }
        };
        proto$0._syncWithLinks = function() {
            var parent = null;
            for (var i in this.$scope.links) {
                for (var ii in this.$scope.links[i].children) {
                    if (this.$scope.links[i].children[ii].link === this.$scope.currentLocation) {
                        this.$scope.links[i].children[ii].__ACTIVE = true;
                        parent = this.$scope.links[i].uiNavParentID;
                    } else {
                        this.$scope.links[i].children[ii].__ACTIVE = false;
                    }
                }
            }
            for (var iii in this.$scope.links) {
                if (this.$scope.links[iii].uiNavParentID === parent) {
                    this.$scope.links[iii].__ACTIVE = true;
                } else {
                    this.$scope.links[iii].__ACTIVE = false;
                }
            }
        };
        proto$0._render = function() {
            var dom = "<li nav-bar-parent></li>";
            var $links = this.$element.find(".links");
            for (var i in this.$scope.links) {
                var s = this.$scope.$new();
                s.link = this.$scope.links[i];
                var $dom = this.$compile(dom)(s);
                $links.append($dom);
            }
        };
        MIXIN$0(NavBarController.prototype, proto$0);
        proto$0 = void 0;
        return NavBarController;
    }();
    app.directive("navBar", [ function() {
        return {
            priority: 1e3,
            templateUrl: "assets/templates/core/layout/navigation/navBar.html",
            controller: [ "$scope", "$element", "$compile", "NavService", "$location", "NavBarToggleService", NavBarController ]
        };
    } ]);
    var NavService = function() {
        "use strict";
        var proto$0 = {};
        function NavService(APIService) {
            this.APIService = APIService;
            this._init();
        }
        DP$0(NavService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            this._nav = [];
        };
        proto$0.fetch = function(cb) {
            var self = this;
            if (this._nav.length > 0) {
                return cb.apply(null, [ this._nav ]);
            } else {
                this.APIService.get("nav", {
                    cache: true
                }).success(function(data) {
                    self._nav = data.map(function(parent) {
                        for (var i in parent.children) {
                            parent.children[i].link = "/" + parent.name.toLowerCase() + "/" + parent.children[i].name.toLowerCase();
                        }
                        return parent;
                    });
                    cb.apply(null, [ self._nav ]);
                });
            }
        };
        MIXIN$0(NavService.prototype, proto$0);
        proto$0 = void 0;
        return NavService;
    }();
    app.service("NavService", [ "APIService", NavService ]);
    var NavBarParentController = function() {
        "use strict";
        var proto$0 = {};
        function NavBarParentController($scope, $element, $compile) {
            this.$scope = $scope;
            this.$element = $element;
            this.$compile = $compile;
            this._init();
        }
        DP$0(NavBarParentController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
            var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
            function GET_ITER$0(v) {
                if (v) {
                    if (Array.isArray(v)) return 0;
                    var f;
                    if (S_MARK$0) S_MARK$0(v);
                    if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                        if (S_MARK$0) S_MARK$0(void 0);
                        return f.call(v);
                    }
                    if (S_MARK$0) S_MARK$0(void 0);
                    if (v + "" === "[object Generator]") return v;
                }
                throw new Error(v + " is not iterable");
            }
            var $D$0;
            var $D$1;
            var $D$2;
            var $D$3;
            $D$3 = this.$scope.link.children;
            $D$0 = GET_ITER$0($D$3);
            $D$2 = $D$0 === 0;
            $D$1 = $D$2 ? $D$3.length : void 0;
            for (var child; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                child = $D$2 ? $D$3[$D$0++] : $D$1["value"];
                this.render(child);
            }
            $D$0 = $D$1 = $D$2 = $D$3 = void 0;
            this._initScope();
        };
        proto$0._initScope = function() {
            var self = this;
            this.$scope.$watch("link.__ACTIVE", function(newValue, oldValue) {
                if (newValue === true) {
                    return self.$element.find(".children").slideDown();
                }
                if (newValue === false) {
                    return self.$element.find(".children").slideUp();
                }
            });
        };
        proto$0.render = function(link) {
            var dom = "<li nav-bar-child></li>";
            var s = this.$scope.$new();
            s.link = link;
            var $dom = this.$compile(dom)(s);
            this.$element.find(".children").append($dom);
        };
        MIXIN$0(NavBarParentController.prototype, proto$0);
        proto$0 = void 0;
        return NavBarParentController;
    }();
    app.directive("navBarParent", [ function() {
        return {
            require: "^navBar",
            templateUrl: "assets/templates/core/layout/navigation/navBarParent.html",
            controller: [ "$scope", "$element", "$compile", NavBarParentController ],
            link: function(scope, element, attrs, Controller) {
                scope.open = function() {
                    Controller.open(scope.link);
                };
            }
        };
    } ]);
    var NavBarChildController = function() {
        "use strict";
        var proto$0 = {};
        function NavBarChildController($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
            this._init();
        }
        DP$0(NavBarChildController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {};
        MIXIN$0(NavBarChildController.prototype, proto$0);
        proto$0 = void 0;
        return NavBarChildController;
    }();
    app.directive("navBarChild", [ function() {
        return {
            require: "^navBarParent",
            templateUrl: "assets/templates/core/layout/navigation/navBarChild.html",
            controller: [ "$scope", "$element", NavBarChildController ],
            link: function(scope, element, attrs, ParentController) {}
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.config([ "$routeProvider", function($routeProvider) {
        $routeProvider.when("/:parent/:child", {
            templateUrl: function(params) {
                return ("assets/templates/apps/" + params.parent + "/" + params.child + "/main.html?e=").toLowerCase() + new Date().getTime();
            }
        }).when("/:parent/:child/perspective/:perspective", {
            templateUrl: function(params) {
                return ("assets/templates/apps/" + params.parent + "/" + params.child + "/main.html?e=").toLowerCase() + new Date().getTime();
            }
        });
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("AjaxQueueService", [ "APIService", function(APIService) {
        var queue = [];
        var ranQueue = false;
        var cache = {};
        var noCache = false;
        this.turnOffCaching = function() {
            noCache = true;
        };
        this.clearCache = function(forName) {
            cache[forName] = {};
        };
        this.clearSpecificCache = function(cacheObjName, call) {
            delete cache[cacheObjName][call];
        };
        this.register = function(name) {
            cache[name] = {};
        };
        this.addToQueue = function(call, cacheObjName, cb) {
            queue.push({
                call: call,
                cacheObj: cache[cacheObjName],
                cb: cb
            });
            runQueue();
        };
        var runQueue = function() {
            if (!ranQueue) {
                ranQueue = true;
                runNext();
            }
        };
        var runNext = function() {
            if (queue.length > 0) {
                var next = queue.shift();
                if (!noCache && next.cacheObj.hasOwnProperty(next.call)) {
                    next.cb.apply(null, [ next.cacheObj[next.call] ]);
                    runNext();
                } else {
                    APIService.get(next.call, {
                        cache: true
                    }).success(function(data) {
                        next.cacheObj[next.call] = data;
                        next.cb.apply(null, [ next.cacheObj[next.call] ]);
                        runNext();
                    });
                }
            } else {
                ranQueue = false;
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    app.directive("alertBox", [ "AlertMessageService", function(AlertMessageService) {
        return {
            restrict: "A",
            scope: {},
            controller: function($scope) {
                $scope.data = AlertMessageService.scope;
            },
            templateUrl: "assets/templates/core/shared/alertBox/alertBox.template.html"
        };
    } ]);
    app.directive("atAlertBoxButton", [ function() {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                if (scope.btn.dismiss) {
                    element.attr("data-dismiss", "modal");
                }
            }
        };
    } ]);
})();

angular.module("atCore").factory("AlertMessageService", function() {
    return {
        scope: {
            title: "",
            message: "",
            buttons: [],
            type: null
        },
        showError: function(title, message) {
            this.scope.type = "error";
            this.scope.title = title;
            this.scope.message = message;
            this.scope.buttons = [];
            $("#alertBox").modal();
        },
        showQuestion: function(title, message, buttons) {
            this.scope.type = "question";
            this.scope.title = title;
            this.scope.message = message;
            this.scope.buttons = buttons;
            $("#alertBox").modal();
        }
    };
});

(function() {
    var api = angular.module("atAPI");
    api.service("HttpBlockService", [ function() {
        this.blocked = false;
    } ]);
    api.service("APIUrlLocator", [ function() {
        var env = "DEV";
        var urls = {
            DEV: "/services/gbp/"
        };
        this.getUrl = function(call) {
            return urls[env] + call;
        };
    } ]);
    api.service("APIService", [ "$http", "HttpBlockService", "APIUrlLocator", function($http, HttpBlockService, APIUrlLocator) {
        this.getApiURL = function(call) {
            return APIUrlLocator.getUrl(call);
        };
        this.get = function(url, config) {
            config = config || {};
            return $http.get(this.getApiURL(url), config);
        };
        this.post = function(url, data, headers) {
            headers = headers || {};
            return $http({
                method: "POST",
                url: this.getApiURL(url),
                headers: headers,
                data: data
            });
        };
        this.put = function(url, data, headers) {
            headers = headers || {};
            return $http({
                method: "PUT",
                url: this.getApiURL(url),
                headers: headers,
                data: data
            });
        };
        this.delete = function(url, config) {
            config = config || {};
            return $http.delete(this.getApiURL(url), config);
        };
        this.nonBlockedGet = function(url, config) {
            config = config || {};
            return $http.get(this.getApiURL(url), config);
        };
        this.blocking = function(url) {
            HttpBlockService.blocked = true;
            this.nonBlockedGet(url).success(function(res) {
                console.log(res);
                HttpBlockService.blocked = false;
            }).error(function(err, status) {
                console.log(err, status);
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.config([ "$provide", function($provide) {
        $provide.decorator("APIService", [ "$delegate", "PromiseTemplateService", "AlertMessageService", "LogInService", "localStorageService", function($delegate, PromiseTemplateService, AlertMessageService, LogInService, localStorageService) {
            var getFn = $delegate.get;
            var postFn = $delegate.post;
            var putFn = $delegate.put;
            var deleteFn = $delegate.delete;
            var nonBlockedGetFn = $delegate.nonBlockedGet;
            var decor = this;
            this.getPromiseTemplate = function() {
                var p = PromiseTemplateService.get();
                p._init = function() {
                    var ref = this;
                    this._promise.success(function(proxy, status, headers, config) {
                        var h = headers("RefreshToken");
                        if (angular.isDefined(h)) {
                            localStorageService.set("token", h);
                        }
                        if (proxy.status === "OK") {
                            delete proxy.data[ref._argsConst];
                            if (config.hasOwnProperty("raw") && config.raw === true) {
                                ref._successCb(proxy.data, status, headers, config);
                                return true;
                            }
                            if (Object.keys(proxy.data).length == 0) {
                                ref._successCb(null, status, headers, config);
                                return true;
                            }
                            for (var i in proxy.data) {
                                var data = proxy.data[i];
                                ref._successCb(data, status, headers, config);
                                break;
                            }
                            return true;
                        }
                        if (proxy.status === "EXCEPTION") {
                            if (proxy.throwables[0].message === "Reauthenticate") {
                                LogInService.revokeStay(ref._successCb, arguments);
                                localStorageService.remove("token");
                                return true;
                            }
                            AlertMessageService.showError("Exception", ref._errorMessage(proxy));
                            return true;
                        }
                    });
                    this._promise.error(function(err, status, headers, config) {
                        if (ref._errorCb !== null) {
                            return ref._errorCb(err, status, headers, config);
                        }
                        if (status === 401) {
                            LogInService.revokeStay();
                            localStorageService.remove("token");
                            return;
                        }
                        if (status === 403) {
                            AlertMessageService.showError("Forbidden", "You are forbidden from making this action. Please contact your manager if you require access.");
                            return;
                        }
                        if (status === 501) {
                            AlertMessageService.showError("Not Implemented", "The feature you asked for is not implemented. Please contact an Admin for help.");
                            return;
                        }
                        AlertMessageService.showError("Error", "An unknown error has occured!");
                    });
                };
                return p;
            };
            $delegate.get = function(url, config) {
                config = config || {};
                var ourPromise = decor.getPromiseTemplate();
                ourPromise._promise = getFn.apply($delegate, [ url, config ]);
                ourPromise._init();
                return ourPromise;
            };
            $delegate.post = function(url, data, headers) {
                headers = headers || {};
                var ourPromise = decor.getPromiseTemplate();
                ourPromise._promise = postFn.apply($delegate, [ url, data, headers ]);
                ourPromise._init();
                return ourPromise;
            };
            $delegate.put = function(url, data, headers) {
                headers = headers || {};
                var ourPromise = decor.getPromiseTemplate();
                ourPromise._promise = putFn.apply($delegate, [ url, data, headers ]);
                ourPromise._init();
                return ourPromise;
            };
            $delegate.delete = function(url, config) {
                config = config || {};
                var ourPromise = decor.getPromiseTemplate();
                ourPromise._promise = deleteFn.apply($delegate, [ url, config ]);
                ourPromise._init();
                return ourPromise;
            };
            $delegate.nonBlockedGet = function(url, config) {
                config = config || {};
                var ourPromise = decor.getPromiseTemplate();
                ourPromise._promise = nonBlockedGetFn.apply($delegate, [ url, config ]);
                ourPromise._init();
                return ourPromise;
            };
            return $delegate;
        } ]);
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.config([ "$httpProvider", function($httpProvider) {
        $httpProvider.interceptors.push("HttpLoadingInterceptor");
        $httpProvider.interceptors.push("HttpQueueInterceptor");
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.factory("HttpLoadingInterceptor", [ "LoadingScreenService", "AlertMessageService", "$q", function(LoadingScreenService, AlertMessageService, $q) {
        var HttpLoadingInterceptor = {
            request: function(config) {
                if (config.hasOwnProperty("loadingScreen") && config.loadingScreen === false) {
                    return config;
                }
                if (config.url.indexOf(".html") === -1) {
                    LoadingScreenService.show();
                }
                return config;
            },
            response: function(res) {
                if (res.config.hasOwnProperty("loadingScreen") && res.config.loadingScreen === false) {
                    return res;
                }
                if (res.config.url.indexOf(".html") === -1) {
                    LoadingScreenService.hide();
                }
                return res;
            },
            responseError: function(res) {
                if (res.config.hasOwnProperty("loadingScreen") && res.config.loadingScreen === false) {
                    return $q.reject(res);
                }
                if (res.config.url.indexOf(".html") === -1) {
                    LoadingScreenService.hide();
                } else {
                    AlertMessageService.showError("Oh no!", "Unable to fulfill request.");
                }
                return $q.reject(res);
            }
        };
        return HttpLoadingInterceptor;
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    angular.module("atCore").service("QueueManagerService", [ function() {
        var _keepOn = true, _pause = null, _resume = null;
        this.onPause = function(cb) {
            _pause = cb;
        };
        this.onResume = function(cb) {
            _resume = cb;
        };
        this.resume = function() {
            _resume.apply(null, []);
        };
        this.pause = function() {
            _pause.apply(null, []);
        };
    } ]);
    app.factory("HttpQueueInterceptor", [ "$q", "$rootScope", "QueueManagerService", function($q, $rootScope, QueueManagerService) {
        QueueManagerService.onPause(function() {
            run = false;
        });
        QueueManagerService.onResume(function() {
            run = true;
            _executeTop();
        });
        var _queue = [], run = true;
        $rootScope.$on("proceed-with-http-calls", function() {
            _executeTop();
        });
        var _executeTop = function() {
            if (!run) {
                return;
            }
            if (_queue.length === 0) {
                return;
            }
            _queue[0].resolve();
        };
        var _addRequest = function(req) {
            _queue.push(req);
            if (_queue.length === 1) {
                _executeTop();
            }
        };
        var HttpQueueInterceptor = {
            request: function(config) {
                if (config.hasOwnProperty("skipQueue") && config.skipQueue === true) {
                    return config;
                }
                if (config.url.indexOf(".html") === -1) {
                    var deferred = $q.defer();
                    _addRequest({
                        resolve: function() {
                            deferred.resolve(config);
                        },
                        url: config.url
                    });
                    return deferred.promise;
                }
                return config;
            },
            response: function(response) {
                if (_queue.length === 0 || response.config.hasOwnProperty("skipQueue") && response.config.skipQueue === true) {
                    return response;
                }
                if (response.config.url.indexOf(".html") === -1) {
                    _queue.shift();
                    _executeTop();
                }
                return response;
            },
            responseError: function(responseError) {
                if (_queue.length === 0 || responseError.config.hasOwnProperty("skipQueue") && responseError.config.skipQueue === true) {
                    return $q.reject(responseError);
                }
                if (responseError.config.url.indexOf(".html") === -1) {
                    _queue.shift();
                    _executeTop();
                }
                return $q.reject(responseError);
            }
        };
        return HttpQueueInterceptor;
    } ]);
})();

(function() {
    var api = angular.module("atAPI");
    api.service("PromiseTemplateService", [ function() {
        this.get = function() {
            return {
                _promise: null,
                _successCb: null,
                _errorCb: null,
                _argsConst: "2147483647",
                _messages: {
                    RejectedRequestException: "The action you have attempted has been rejected by the system.",
                    Denied: "You are not authorized to complete this action."
                },
                _init: null,
                _errorMessage: function(proxy) {
                    if (this._messages.hasOwnProperty(proxy.throwables[0].message)) {
                        return this._messages[proxy.throwables[0].message];
                    }
                    return "An unknown exception has occured!";
                },
                success: function(cb) {
                    this._successCb = cb;
                    return this;
                },
                error: function(cb) {
                    this._errorCb = cb;
                    return this;
                }
            };
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    app.directive("atContextMenu", [ "$document", "ContextMenuService", function($document, ContextMenuService) {
        return {
            templateUrl: "assets/templates/core/shared/contextMenu/atcontextmenu.template.html",
            controller: function($scope, $element) {
                var _toggleMenu, _setInitLocation, _getContextMenuDOM;
                $scope.showMenu = false;
                $scope.items = [];
                $scope.fire = function(item) {
                    item.fireAction();
                    _toggleMenu();
                };
                ContextMenuService.onSummon(function($event) {
                    _toggleMenu($event);
                });
                _toggleMenu = function($event) {
                    $scope.showMenu = !$scope.showMenu;
                    if ($scope.showMenu) {
                        _setInitLocation($event);
                    } else {
                        $document.off("click");
                        $("#stage").off("scroll");
                    }
                };
                _getContextMenuDOM = function() {
                    return $element.find(".context-menu");
                };
                _setInitLocation = function($event) {
                    var $main = _getContextMenuDOM();
                    _fillItems();
                    $main.css({
                        top: $event.pageY + 5,
                        left: $event.pageX + 5
                    });
                    $document.on("click", function() {
                        $scope.$apply(function() {
                            _toggleMenu();
                        });
                    });
                    $("#stage").on("scroll", function() {
                        $scope.$apply(function() {
                            _toggleMenu();
                        });
                    });
                };
                _fillItems = function() {
                    $scope.items = ContextMenuService.getItems();
                };
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    app.service("ContextMenuService", [ function() {
        var _items = [], _summonCB;
        this.create = function($event, items) {
            _items = items;
            _summonCB.apply(null, [ $event ]);
        };
        this.onSummon = function(cb) {
            _summonCB = cb;
        };
        this.getItems = function() {
            return _items;
        };
    } ]);
    app.service("ContextMenuItemFactory", [ function() {
        function ContextMenuItem(name) {
            var _name, _icon, _disabled = false, _context = {}, _action;
            this.setName = function(name) {
                _name = name;
                return this;
            };
            this.setIcon = function(icon) {
                _icon = icon;
                return this;
            };
            this.setContext = function(context) {
                _context = context;
                return this;
            };
            this.disable = function() {
                _disabled = true;
                return true;
            };
            this.setAction = function(cb) {
                _action = cb;
                return this;
            };
            this.getName = function() {
                return _name;
            };
            this.getIcon = function() {
                return _icon;
            };
            this.isDisabled = function() {
                return _disabled;
            };
            this.getContext = function() {
                return _context;
            };
            this.fireAction = function() {
                _action.apply(null, [ _context ]);
            };
            this.setName(name);
        }
        this.build = function(name) {
            return new ContextMenuItem(name);
        };
    } ]);
})();

(function() {
    angular.module("atUI").factory("ServiceFactory", [ function() {
        return {};
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    var directive = function() {
        return {
            template: '<span class="label" ng-class="_le">{{label}}</span>',
            scope: {
                label: "=",
                options: "="
            },
            controller: function($scope, $element) {
                $scope._le = {};
                var _le = {};
                $scope.$watch("label", function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                        updateClasses();
                    }
                });
                var updateClasses = function() {
                    for (var clazz in $scope.options) {
                        _le[clazz] = $scope.options[clazz] === $scope.label;
                    }
                    $scope._le = _le;
                };
                updateClasses();
            }
        };
    };
    app.directive("atLabel", [ directive ]);
})();

(function() {
    var app = angular.module("atCore");
    app.factory("ListBoxFactory", [ function() {
        var ListBox = function() {
            "use strict";
            var PRS$0 = function(o, t) {
                o["__proto__"] = {
                    a: t
                };
                return o["a"] === t;
            }({}, {});
            var DP$0 = Object.defineProperty;
            var GOPD$0 = Object.getOwnPropertyDescriptor;
            var MIXIN$0 = function(t, s) {
                for (var p in s) {
                    if (s.hasOwnProperty(p)) {
                        DP$0(t, p, GOPD$0(s, p));
                    }
                }
                return t;
            };
            var DPS$0 = Object.defineProperties;
            var proto$0 = {};
            function ListBox(title, icon) {
                this.observers = {
                    search: [],
                    list: []
                };
                this.options = {
                    title: title,
                    icon: icon,
                    search: false
                };
                this._list = [];
            }
            DPS$0(ListBox.prototype, {
                title: {
                    get: $title_get$0,
                    configurable: true,
                    enumerable: true
                },
                icon: {
                    get: $icon_get$0,
                    configurable: true,
                    enumerable: true
                },
                list: {
                    get: $list_get$0,
                    set: $list_set$0,
                    configurable: true,
                    enumerable: true
                },
                search: {
                    get: $search_get$0,
                    configurable: true,
                    enumerable: true
                }
            });
            DP$0(ListBox, "prototype", {
                configurable: false,
                enumerable: false,
                writable: false
            });
            function $title_get$0() {
                return this.options.title;
            }
            function $icon_get$0() {
                return this.options.icon;
            }
            function $list_set$0(list) {
                var oldValue = angular.copy(this._list);
                this._list = list;
                this.notify("list", oldValue, this._list);
            }
            function $list_get$0() {
                return this._list;
            }
            function $search_get$0() {
                return this.options.search;
            }
            proto$0.enableSearch = function() {
                this.notify("search", false, true);
                this.options.search = true;
                return this;
            };
            proto$0.watch = function(subject, action) {
                this.observers[subject].push(action);
            };
            proto$0.notify = function(subject, oldValue, newValue) {
                for (var i in this.observers[subject]) {
                    this.observers[subject][i].apply(null, [ oldValue, newValue ]);
                }
            };
            MIXIN$0(ListBox.prototype, proto$0);
            proto$0 = void 0;
            return ListBox;
        }();
        return {
            build: function(title, icon) {
                return new ListBox(title, icon);
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    app.directive("listBoxFullHeight", [ function() {
        return {
            require: "listBox",
            terminal: true,
            link: function(scope, element, attrs) {
                var sizeUp = function() {
                    var stage_height = $("#stage").height();
                    var wrapper_bottom = parseInt($("#stage .wrapper").css("padding-bottom"));
                    var $mgma = $("#mgma");
                    var toolbar_height = $mgma.find(".toolbar").height() + parseInt($mgma.find(".toolbar").css("padding-top")) * 2 + parseInt($mgma.find(".toolbar").css("border-bottom-width"));
                    var mgma_stage_top = parseInt($mgma.find(".mgma-stage").css("padding-top"));
                    var element_height = stage_height - (wrapper_bottom + toolbar_height + mgma_stage_top);
                    element.css({
                        height: element_height
                    });
                    element.find(".list-viewer-wrapper").css({
                        height: function() {
                            var pad = (parseInt(element.css("padding-top")) + parseInt(element.css("border-top-width"))) * 2;
                            return element_height - pad - element.find(".list-viewer-toolbar").height() - parseInt($(this).css("margin-top"));
                        }
                    });
                };
                sizeUp();
                scope.$on("list-box-redo-full-height", function() {
                    sizeUp();
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    app.directive("listBox", [ "$sce", function($sce) {
        return {
            scope: {
                box: "="
            },
            templateUrl: "assets/templates/core/shared/listBox/main.html",
            priority: 10,
            controller: function($scope, $element, $attrs) {
                var box = $scope.box;
                $scope.title = box.title;
                $scope.icon = box.icon;
                $scope.isSearchEnabled = box.search;
                $scope.list = [];
                $scope.search = "";
                $scope.results = [];
                $scope.selected = false;
                $scope.active = 0;
                $scope.selectedOne = null;
                box.watch("search", function(oldValue, newValue) {
                    $scope.isSearchEnabled = newValue;
                    $scope.$emit("list-box-redo-full-height");
                });
                box.watch("list", function(oldValue, newValue) {
                    if (newValue.length > 0) {
                        $scope.list = newValue;
                    }
                });
                $scope.$watch("search", function(newValue, oldValue, scope) {
                    if (scope.results.length === 0 || scope.selected !== false && angular.isDefined(scope.selected) && newValue !== scope.results[scope.selected].original) {
                        scope.selected = false;
                    }
                    if (newValue !== oldValue && newValue !== "" && scope.selected === false) {
                        var m = fuzzy.filter(newValue, scope.list, {
                            pre: "<strong>",
                            post: "</strong>"
                        });
                        scope.results = [];
                        scope.active = 0;
                        for (var i in m) {
                            scope.results.push({
                                string: $sce.trustAsHtml(m[i].string),
                                original: m[i].original
                            });
                        }
                    }
                    if (newValue === "") {
                        scope.results = [];
                    }
                });
                $scope.onDownArrow = function() {
                    if (parseInt($scope.active) + 1 < $scope.results.length) {
                        $scope.$apply(function() {
                            $scope.active = parseInt($scope.active) + 1;
                        });
                    }
                };
                $scope.onUpArrow = function() {
                    if (parseInt($scope.active) - 1 >= 0) {
                        $scope.$apply(function() {
                            $scope.active = parseInt($scope.active) - 1;
                        });
                    }
                };
                $scope.onEnter = function() {
                    $scope.$apply(function() {
                        $scope.selectGroup($scope.active);
                    });
                };
            },
            link: function(scope, element) {
                scope.$watchGroup("results", function(newValue, oldValue) {
                    if (newValue.length > 0) {
                        element.on("keydown", function(e) {
                            if (e.which === 40) {
                                scope.onDownArrow();
                                return e.preventDefault();
                            } else if (e.which === 38) {
                                scope.onUpArrow();
                                return e.preventDefault();
                            } else if (e.which === 13) {
                                scope.onEnter();
                                return e.preventDefault();
                            }
                        });
                    } else {
                        element.off("keydown");
                    }
                });
                scope.$watch("active", function(newValue, oldValue) {
                    var $results = element.find(".list-viewer-wrapper");
                    var F = $results.outerHeight();
                    if (newValue !== oldValue) {
                        var T = element.find(".active").outerHeight();
                        var O = (parseInt(newValue) + 2) * T;
                        var X = Math.abs(F - O);
                        if (O > F) {
                            $results.scrollTop(X);
                        } else {
                            $results.scrollTop(0);
                        }
                    }
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atListViewer", [ function() {
        return {
            restrict: "A",
            scope: {
                list: "=",
                loaded: "=",
                newItem: "&",
                onSelect: "&",
                icon: "@",
                title: "@atTitle",
                newHoverTitle: "@"
            },
            templateUrl: "assets/templates/core/shared/listView/atlistviewer.template.html",
            controller: function($scope, $element) {
                $scope.isLoading = true;
                var unwatch = $scope.$watch("loaded", function(newValue, oldValue) {
                    if (newValue === true) {
                        $scope.isLoading = false;
                        unwatch();
                    }
                });
            },
            link: function(scope, element, attrs) {
                var stage_height = $("#stage").height();
                var wrapper_bottom = parseInt($("#stage .wrapper").css("padding-bottom"));
                var $mgma = $("#mgma");
                var toolbar_height = $mgma.find(".toolbar").height() + parseInt($mgma.find(".toolbar").css("padding-top")) * 2 + parseInt($mgma.find(".toolbar").css("border-bottom-width"));
                var mgma_stage_top = parseInt($mgma.find(".mgma-stage").css("padding-top"));
                var element_height = stage_height - (wrapper_bottom + toolbar_height + mgma_stage_top);
                element.css({
                    height: element_height
                });
                element.find(".list-viewer-wrapper").css({
                    height: function() {
                        var pad = (parseInt(element.css("padding-top")) + parseInt(element.css("border-top-width"))) * 2;
                        return element_height - pad - element.find(".list-viewer-toolbar").height() - parseInt($(this).css("margin-top"));
                    }
                });
            }
        };
    } ]);
    app.directive("atListViewerItem", [ function() {
        return {
            restrict: "A",
            scope: {
                item: "=",
                icon: "="
            },
            templateUrl: "assets/templates/core/shared/listView/atlistvieweritem.template.html"
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("LoadingScreenService", [ "$timeout", function($timeout) {
        var _queue = [];
        var _subs = {
            show: [],
            hide: []
        };
        var _debounce = null;
        var _dSpeed = 500;
        this.on = function(e, cb) {
            _subs[e].push(cb);
        };
        this.show = function() {
            if (_queue.length === 0) {
                if (_debounce !== null) {
                    $timeout.cancel(_debounce);
                }
                for (var i in _subs.show) {
                    _subs.show[i].call();
                }
            }
            _queue.push(1);
        };
        this.hide = function() {
            _queue.pop();
            if (_queue.length === 0) {
                _debounce = $timeout(function() {
                    _doHide();
                }, _dSpeed);
            }
        };
        var _doHide = function() {
            for (var i in _subs.hide) {
                _subs.hide[i].call();
            }
            _debounce = null;
        };
    } ]);
    app.directive("loadingScreen", [ "LoadingScreenService", "$log", function(LoadingScreenService, $log) {
        return {
            controller: function($scope) {
                $scope.show = false;
            },
            link: function(scope, element) {
                LoadingScreenService.on("show", function() {
                    scope.show = true;
                });
                LoadingScreenService.on("hide", function() {
                    scope.show = false;
                });
                var text = $("#footer").find(".patent").text();
                var s = text.split("");
                var r = chance.natural({
                    min: 5,
                    max: s.length - 1
                });
                s[r] = '<a href="javascript:void(0);">' + s[r] + "</a>";
                $("#footer").find(".patent").html(s.join(""));
                $("#footer").find("a").on("click", function() {
                    $log.log("###########################################################\n" + "# Look at you! You not only find me, you are also         #\n" + "# reading this! Which means you are a dev!! Yay!          #\n" + "# There really isn't much to say after that.              #\n" + "# Enjoy the UI!                                           #\n" + "###########################################################");
                    $("#loading-screen").find(".spinner").removeClass("ball-grid-pulse");
                    $("#loading-screen").find(".spinner").children().remove();
                    $("#loading-screen").find(".spinner").append($('<img style="width: 57px;" src="assets/img/_loading_.gif">'));
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("StoreService", [ "$log", "$location", "$window", function($log, $location, $window) {
        var _canUse = simpleStorage.canUse();
        this.leftOffHere = function(name, cb) {
            cb = cb || null;
            if (_canUse) {
                simpleStorage.set("leftOff", {
                    name: name,
                    location: $location.url()
                });
                if (cb !== null) {
                    cb.apply(null, []);
                }
            }
        };
        this.getWhereWeLeftOff = function() {
            var _port = $location.port();
            if (_port !== "80") {
                return $location.protocol() + "://" + $window.location.hostname + ":" + _port + $window.location.pathname + "#" + simpleStorage.get("leftOff").location;
            }
            return $location.protocol() + "://" + $window.location.hostname + $window.location.pathname + "#" + simpleStorage.get("leftOff").location;
        };
        this.getRawLeftOff = function() {
            return simpleStorage.get("leftOff");
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("FilesStoreService", [ "$log", function($log) {
        var ref = this;
        this.firstLoad = true;
        this.idbIsReady = false;
        this.filesStore = new IDBStore({
            dbVersion: 1,
            storeName: "savedFiles",
            keyPath: "id",
            autoIncrement: true,
            onStoreReady: function() {
                $log.info("Files Store is ready!");
                ref.idbIsReady = true;
                ref.firstLoadHousekeeping();
            }
        });
        this.firstLoadHousekeeping = function() {
            if (this.firstLoad) {
                this.firstLoad = false;
                this.filesStore.getAll(function(files) {
                    for (var i in files) {
                        if (files[i].isDeleted) {
                            ref.filesStore.remove(files[i].id, function() {
                                $log.info("Removed a deleted file!");
                            });
                        }
                    }
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    app.service("LogInService", [ "$http", "APIUrlLocator", "QueueManagerService", "$rootScope", "localStorageService", "$timeout", "$log", function($http, APIUrlLocator, QueueManagerService, $rootScope, localStorageService, $timeout, $log) {
        var openModalCB = null;
        var ctrl = null;
        var successCb = null;
        var successArgs = [];
        var ref = this;
        this.setModalCB = function(cb, ref) {
            openModalCB = cb;
            crtl = ref;
        };
        this.revokeStay = function(cb, args) {
            QueueManagerService.pause();
            successCb = cb;
            successArgs = args;
            if (openModalCB === null) {
                $timeout(function() {
                    openModalCB.apply(crtl, []);
                }, 10);
            } else {
                openModalCB.apply(crtl, []);
            }
        };
        this.doLogIn = function(creds, cb) {
            $http.post(APIUrlLocator.getUrl("auth/login/do"), creds, {
                skipQueue: true
            }).success(function(res) {
                if (res.status === "OK") {
                    localStorageService.set("token", res.data[100]);
                    QueueManagerService.resume();
                    if (angular.isDefined(ref.successCb)) {
                        ref.successCb.apply(null, successArgs);
                    }
                    $rootScope.$broadcast("refresh-failed-ping");
                    cb();
                } else {
                    $log.error(res.throwables[0].message);
                }
            }).error(function(data, status) {
                $log.log(data, status);
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    app.directive("loginModal", [ "LogInService", function(LogInService) {
        return {
            templateUrl: "assets/templates/core/shared/login/login_modal.html",
            controller: function($scope, $element, $attrs) {
                $scope.user = {
                    loginID: null,
                    password: null,
                    remember: false
                };
                var _checkIfRemembered = function() {
                    var _loginID = simpleStorage.get("loginID");
                    if (angular.isDefined(_loginID)) {
                        $scope.user.loginID = _loginID;
                        $scope.user.remember = true;
                    }
                };
                _checkIfRemembered();
                $scope.doLogIn = function() {
                    LogInService.doLogIn({
                        loginID: $scope.user.loginID,
                        password: $scope.user.password
                    }, function() {
                        if ($scope.user.remember) {
                            simpleStorage.set("loginID", $scope.user.loginID.toLowerCase());
                        } else {
                            simpleStorage.deleteKey("loginID");
                        }
                        $element.find(".modal").modal("hide");
                    });
                };
                $scope.canLogIn = function() {
                    if ($scope.user.loginID !== null && $scope.user.loginID !== "") {
                        if ($scope.user.password !== null && $scope.user.password !== "") {
                            return false;
                        }
                    }
                    return true;
                };
                this.openModal = function(element) {
                    element.find(".modal").modal({
                        backdrop: "static",
                        keyboard: false
                    });
                };
                LogInService.setModalCB(function() {
                    this.openModal($element);
                }, this);
            },
            link: function(scope, element, attrs, crtl) {
                scope.$on("login-modal-requested", function() {
                    crtl.openModal(element);
                });
                element.find(".modal").on("shown.bs.modal", function() {
                    element.find(".loginID-field").focus();
                });
                element.find(".modal").on("hidden.bs.modal", function() {
                    scope.user.password = null;
                    if (scope.user.remember === false) {
                        scope.user.loginID = null;
                    }
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    app.directive("atModal", [ "ModalService", function(ModalService) {
        return {
            templateUrl: "assets/templates/core/shared/modal/modal.html",
            scope: {
                modalId: "@",
                modalSize: "@"
            },
            transclude: true,
            controller: function($scope, $element) {
                ModalService.register($scope.modalId, function() {
                    $element.find(".modal").modal();
                });
                $scope.$on("$destroy", function() {
                    ModalService.unregister($scope.modalId);
                });
            }
        };
    } ]);
    var ModalService = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function ModalService() {
            this._setupScope();
            this._init();
        }
        DP$0(ModalService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._setupScope = function() {};
        proto$0._init = function() {
            this._modals = [];
        };
        proto$0.register = function(id, openCb) {
            var modal = {
                id: id,
                summon: openCb
            };
            this._modals.push(modal);
        };
        proto$0.unregister = function(id) {
            for (var i in this._modals) {
                if (id === this._modals[i].id) {
                    this._modals.splice(i, 1);
                    return;
                }
            }
        };
        proto$0.summon = function(id) {
            var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
            var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
            function GET_ITER$0(v) {
                if (v) {
                    if (Array.isArray(v)) return 0;
                    var f;
                    if (S_MARK$0) S_MARK$0(v);
                    if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                        if (S_MARK$0) S_MARK$0(void 0);
                        return f.call(v);
                    }
                    if (S_MARK$0) S_MARK$0(void 0);
                    if (v + "" === "[object Generator]") return v;
                }
                throw new Error(v + " is not iterable");
            }
            var $D$0;
            var $D$1;
            var $D$2;
            var $D$3;
            var modal = null;
            $D$3 = this._modals;
            $D$0 = GET_ITER$0($D$3);
            $D$2 = $D$0 === 0;
            $D$1 = $D$2 ? $D$3.length : void 0;
            for (var m; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                m = $D$2 ? $D$3[$D$0++] : $D$1["value"];
                if (id === m.id) {
                    modal = m;
                    break;
                }
            }
            $D$0 = $D$1 = $D$2 = $D$3 = void 0;
            if (modal === null) {
                throw new Exception("No Modal registered under [" + id + "]");
            }
            modal.summon.apply(null, []);
        };
        MIXIN$0(ModalService.prototype, proto$0);
        proto$0 = void 0;
        return ModalService;
    }();
    app.service("ModalService", [ ModalService ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atNotificationCenter", [ "NotificationQueue", function(NotificationQueue) {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                scope.queue = NotificationQueue.queue;
            }
        };
    } ]);
    app.directive("atNotification", [ "$timeout", "NotificationQueue", function($timeout, NotificationQueue) {
        return {
            restrict: "A",
            templateUrl: "assets/templates/core/shared/notification/atnotification.template.html",
            link: function(scope, element, attrs) {
                $timeout(function() {
                    scope.$apply(function() {
                        NotificationQueue.remove(scope.$index);
                    });
                }, 9e3);
            }
        };
    } ]);
    app.service("NotificationQueue", [ function() {
        this.queue = {
            q: []
        };
        this.push = function(msg) {
            this.queue.q.push(msg);
        };
        this.remove = function(i) {
            this.queue.q.splice(i, 1);
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    var PlatformService = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var DPS$0 = Object.defineProperties;
        var proto$0 = {};
        var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
        var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
        function GET_ITER$0(v) {
            if (v) {
                if (Array.isArray(v)) return 0;
                var f;
                if (S_MARK$0) S_MARK$0(v);
                if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                    if (S_MARK$0) S_MARK$0(void 0);
                    return f.call(v);
                }
                if (S_MARK$0) S_MARK$0(void 0);
                if (v + "" === "[object Generator]") return v;
            }
            throw new Error(v + " is not iterable");
        }
        function PlatformService(APIService, localStorageService) {
            this.APIService = APIService;
            this.localStorageService = localStorageService;
            this.currentPlatform = this.localStorageService.get("lastPlatform");
            this.platforms = [];
            this.cbs = [];
            this.apis = {
                CLEAN_CREATE: "platform",
                DELETE: "platform/",
                CLONE_OFF: "platform/clone/"
            };
        }
        DPS$0(PlatformService.prototype, {
            current: {
                get: $current_get$0,
                set: $current_set$0,
                configurable: true,
                enumerable: true
            }
        });
        DP$0(PlatformService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        function $current_get$0() {
            return this.currentPlatform;
        }
        function $current_set$0(platform) {
            var $D$0;
            var $D$1;
            var $D$2;
            var $D$3;
            var changed = false;
            if (this.currentPlatform !== null) {
                changed = true;
            }
            this.currentPlatform = platform;
            this.localStorageService.set("lastPlatform", this.currentPlatform);
            if (changed) {
                $D$3 = this.cbs;
                $D$0 = GET_ITER$0($D$3);
                $D$2 = $D$0 === 0;
                $D$1 = $D$2 ? $D$3.length : void 0;
                for (var cb; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                    cb = $D$2 ? $D$3[$D$0++] : $D$1["value"];
                    cb.apply(null, []);
                }
                $D$0 = $D$1 = $D$2 = $D$3 = void 0;
            }
        }
        proto$0.cleanCreate = function(deployment, cb) {
            this.APIService.put(this.apis.CLEAN_CREATE, deployment).success(function() {
                cb.apply(null, []);
            });
        };
        proto$0.cloneBasedOnThis = function(newDeployment, basedOff, cb) {
            this.APIService.put(this.apis.CLONE_OFF + basedOff.id, newDeployment).success(function() {
                cb.apply(null, []);
            });
        };
        proto$0.deletePlatform = function(deployment, cb) {
            this.APIService.delete(this.apis.DELETE + deployment.id).success(function() {
                cb.apply(null, []);
            });
        };
        proto$0.onChange = function(cb) {
            this.cbs.push(cb);
        };
        proto$0.getPlatforms = function() {
            return this.platforms;
        };
        proto$0.fetchPlatforms = function(cb) {
            var self = this;
            this.APIService.get("platform/all").success(function(platforms) {
                var $D$4;
                var $D$5;
                var $D$6;
                var $D$7;
                var changed = false;
                if (!angular.equals(platforms, self.platforms)) {
                    changed = true;
                }
                self.platforms = platforms;
                var currentFound = false;
                $D$7 = self.platforms;
                $D$4 = GET_ITER$0($D$7);
                $D$6 = $D$4 === 0;
                $D$5 = $D$6 ? $D$7.length : void 0;
                for (var p; $D$6 ? $D$4 < $D$5 : !($D$5 = $D$4["next"]())["done"]; ) {
                    p = $D$6 ? $D$7[$D$4++] : $D$5["value"];
                    if (angular.equals(p, self.currentPlatform)) {
                        currentFound = true;
                        break;
                    }
                }
                $D$4 = $D$5 = $D$6 = $D$7 = void 0;
                if (self.currentPlatform === null || currentFound === false) {
                    self.current = self.platforms[0];
                }
                if (changed) {
                    $D$7 = self.cbs;
                    $D$4 = GET_ITER$0($D$7);
                    $D$6 = $D$4 === 0;
                    $D$5 = $D$6 ? $D$7.length : void 0;
                    for (var cb$0; $D$6 ? $D$4 < $D$5 : !($D$5 = $D$4["next"]())["done"]; ) {
                        cb$0 = $D$6 ? $D$7[$D$4++] : $D$5["value"];
                        cb$0.apply(null, []);
                    }
                    $D$4 = $D$5 = $D$6 = $D$7 = void 0;
                }
                cb.apply(null, []);
            });
        };
        MIXIN$0(PlatformService.prototype, proto$0);
        proto$0 = void 0;
        return PlatformService;
    }();
    app.service("PlatformService", [ "APIService", "localStorageService", PlatformService ]);
})();

(function() {
    var rp = angular.module("RealProgress", []);
    rp.service("RealProgressService", [ function() {
        var _steps = [];
        var _initCallback = null;
        var _onCompleteCallback = null;
        var _onReady = null;
        this.init = function(steps) {
            _steps = steps.map(function(step, i) {
                var show = false;
                var badges = [];
                var status = "pending";
                if (i === 0) {
                    show = true;
                    badges = [ "fa-spin", "fa-cog" ];
                    status = "running";
                }
                return {
                    showBadge: show,
                    badges: badges,
                    status: status,
                    title: step
                };
            });
            _initCallback.apply(null, [ _steps ]);
            return this;
        };
        this.startStep = function(step) {
            var _c = true;
            angular.forEach(_steps, function(_step, i, s) {
                if (_c === false) {
                    return;
                }
                if (_step.title !== step) {
                    if (_step.status === "pending") {
                        s[i] = _markSkipped(_step);
                    }
                } else {
                    _c = false;
                    s[i] = _markRunning(_step);
                }
            });
            return this;
        };
        this.markComplete = function(step) {
            var i = _steps.map(function(e) {
                return e.title;
            }).indexOf(step);
            _steps[i] = _markComplete({
                title: step
            });
            _checkComplete();
            return this;
        };
        var _markRunning = function(step) {
            return {
                showBadge: true,
                badges: [ "fa-spin", "fa-cog" ],
                status: "running",
                title: step.title
            };
        };
        var _markComplete = function(step) {
            return {
                showBadge: true,
                badges: [ "fa-check" ],
                status: "complete",
                title: step.title
            };
        };
        var _markSkipped = function(step) {
            return {
                showBadge: true,
                badges: [ "fa-fast-forward" ],
                status: "skipped",
                title: step.title
            };
        };
        var _checkComplete = function() {
            if (_steps[_steps.length - 1].status === "complete") {
                _onCompleteCallback.apply(null, []);
            }
        };
        this._onInit = function(cb) {
            _initCallback = cb;
            _onReady.apply(null, []);
        };
        this._onComplete = function(cb) {
            _onCompleteCallback = cb;
        };
        this.ready = function(cb) {
            _onReady = cb;
        };
    } ]);
    rp.directive("realProgress", [ "RealProgressService", "$timeout", function(RealProgressService, $timeout) {
        return {
            template: '<div class="modal fade" tabindex="-1" role="dialog"><div class="modal-dialog modal-sm"><div class="modal-content"><div class="modal-body"><ul class="list-group" style="margin: 0;"><li class="list-group-item" ng-repeat="step in steps"><span class="badge" ng-if="step.showBadge"><i class="fa" ng-class="step.badges"></i></span>{{step.title}}</li></ul></div></div></div</div>',
            controller: function($scope, $element) {
                $scope.steps = [];
                RealProgressService._onInit(function(steps) {
                    $scope.steps = steps;
                    $element.find(".modal").modal({
                        backdrop: "static",
                        keyboard: false
                    });
                });
                RealProgressService._onComplete(function() {
                    $timeout(function() {
                        $element.find(".modal").modal("hide");
                    }, 500);
                });
                $element.find(".modal").on("hidden.bs.modal", function() {
                    $scope.$apply(function() {
                        $scope.steps = [];
                    });
                });
            }
        };
    } ]);
})();

angular.module("atUI").service("anchorSmoothScroll", [ function() {
    var scrollCB = null;
    this.onScroll = function(cb) {
        scrollCB = cb;
    };
    this.scrollTo = function(eID) {
        scrollCB.apply(null, [ eID ]);
    };
} ]);

(function() {
    angular.module("atUI").directive("scrollAgent", [ "anchorSmoothScroll", function(anchorSmoothScroll) {
        return {
            controller: function($scope, $element) {
                anchorSmoothScroll.onScroll(function(to) {
                    var $target = $("#" + to);
                    var targetTop = $target.offset().top;
                    var stageScrollTop = $element.scrollTop();
                    var offset = -60;
                    $element.animate({
                        scrollTop: parseInt(stageScrollTop) + parseInt(targetTop) + offset
                    }, 1e3, "swing");
                });
            }
        };
    } ]);
    angular.module("atUI").factory("spyScrollService", function() {
        var spy = {
            linkActive: "",
            links: []
        };
        return spy;
    });
    angular.module("atUI").directive("spyScroll", [ "$window", "$timeout", function($window, $timeout) {
        return {
            link: function(scope, element, attrs) {
                if ($("body").width() > 768) {
                    function setActiveLink(ref) {
                        var refPageYOffset = parseInt(ref.scrollTop());
                        for (var i in scope.spy.links) {
                            var targetOffsetTop = parseInt($("#" + scope.spy.links[i]["target_id"]).offset().top - 60);
                            var nextTargetOffsetTop = parseInt($("#" + scope.spy.links[parseInt(i) + 1]["target_id"]).offset().top - 60);
                            if (!angular.isUndefined(scope.spy.links[parseInt(i) + 1])) {
                                if (refPageYOffset >= targetOffsetTop && refPageYOffset < nextTargetOffsetTop) {
                                    scope.$apply(function() {
                                        scope.spy.linkActive = scope.spy.links[i]["target_id"];
                                    });
                                }
                            } else {
                                if (refPageYOffset >= parseInt($("#" + scope.spy.links[i]["target_id"]).offset().top - 60) || ref.innerHeight + ref.scrollY >= $("#stage").height()) {
                                    scope.$apply(function() {
                                        scope.spy.linkActive = scope.spy.links[i]["target_id"];
                                    });
                                }
                            }
                        }
                    }
                    angular.element($("#stage")).bind("scroll", function() {
                        setActiveLink($("#stage"));
                    });
                    $timeout(function() {
                        scope.spy.linkActive = scope.spy.links[0]["target_id"];
                    }, 2200);
                }
            }
        };
    } ]);
    angular.module("atUI").directive("spyScrollLink", [ "spyScrollService", function(spyScrollService) {
        return {
            link: function(scope, element, attrs) {
                var spy = spyScrollService;
                var link = {
                    target_id: element.attr("data-target")
                };
                spy.links.push(link);
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("SyncService", [ function() {
        var _queue = {};
        var _onComplete = {};
        this.addKey = function(key) {
            _queue[key] = [];
        };
        this.addTo = function(key, name) {
            _queue[key].push(name);
        };
        this.syncComplete = function(key, name) {
            var i = _queue[key].indexOf(name);
            _queue[key].splice(i, 1);
            if (_queue[key].length === 0) {
                _fireComplete(key);
            }
        };
        this.onComplete = function(key, cb) {
            _onComplete[key] = cb;
        };
        var _fireComplete = function(key) {
            _onComplete[key].apply(null, []);
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atTreeview", [ function() {
        return {
            restrict: "A",
            scope: {
                nodes: "=nodes"
            },
            templateUrl: "assets/templates/core/shared/treeView/attreeview.template.html",
            link: function(scope, element, attrs) {
                var stage_height = $("#stage").height();
                var wrapper_bottom = parseInt($("#stage .wrapper").css("padding-bottom"));
                var $mgma = $("#mgma");
                var toolbar_height = $mgma.find(".toolbar").height() + parseInt($mgma.find(".toolbar").css("padding-top")) * 2 + parseInt($mgma.find(".toolbar").css("border-bottom-width"));
                var mgma_stage_top = parseInt($mgma.find(".mgma-stage").css("padding-top"));
                element.css({
                    height: stage_height - (wrapper_bottom + toolbar_height + mgma_stage_top)
                });
            }
        };
    } ]);
    app.directive("atTreeParentNode", [ "ObjectToNodeService", "$compile", function(ObjectToNodeService, $compile) {
        return {
            restrict: "A",
            templateUrl: "assets/templates/core/shared/treeView/attreeparentnode.template.html",
            link: function(scope, element, attrs) {
                var ref = this;
                var node_id = "node-" + md5(JSON.stringify(scope.node.data));
                element.attr("id", node_id);
                scope.node.node_id = node_id;
                this.createChildren = function(_parent_scope, el) {
                    for (var i in _parent_scope.node.children) {
                        var $child = $('<div class="node node-type-' + _parent_scope.node.children[i].node_type + ' closed" at-tree-' + _parent_scope.node.children[i].node_type + "-node></div>");
                        var child_scope = _parent_scope.$new();
                        child_scope.node = _parent_scope.node.children[i];
                        var child = $compile($child)(child_scope);
                        el.find(".node-children").append(child);
                    }
                };
                this.toggleParent = function(el) {
                    var _p = angular.element(el).parent();
                    if (_p.hasClass("opened")) {
                        _p.removeClass("opened").addClass("closed");
                    } else {
                        if (_p.scope().node.children.length > 0) {
                            _p.removeClass("closed").addClass("opened");
                        } else {
                            this.getChildren(_p);
                        }
                    }
                };
                this.getChildren = function(_p) {
                    _p.addClass("loading");
                    ObjectToNodeService.setParentNode(_p.scope().node);
                    ObjectToNodeService.getChildren(function() {
                        ref.createChildren(_p.scope(), _p);
                        _p.removeClass("loading");
                        _p.removeClass("closed").addClass("opened");
                    }, function() {
                        _p.removeClass("loading").addClass("error");
                    });
                };
                if (element.hasClass("opened") && scope.node.children.length === 0) {
                    this.getChildren(element);
                }
                element.find(".node-indicator").on("click", function() {
                    ref.toggleParent(this);
                });
                element.find(".node-name").on("dblclick", function() {
                    ref.toggleParent(this);
                });
                element.find(".node-name").on("mousedown", function(e) {
                    if (e.button == 2) {
                        var _p = angular.element(this).parent();
                        var $menu = $("<div at-context-menu></div>");
                        var child_scope = _p.scope().$new();
                        child_scope.mouse = {
                            x: e.pageX,
                            y: e.pageY
                        };
                        var child = $compile($menu)(child_scope);
                        _p.append(child);
                        return false;
                    }
                });
                this.createChildren(scope, element);
            }
        };
    } ]);
    app.directive("atTreeSterileNode", [ function() {
        return {
            restrict: "A",
            templateUrl: "assets/templates/core/shared/treeView/attreesterilnode.template.html",
            link: function(scope, element, attrs) {
                var ref = this;
                var node_id = "node-" + md5(JSON.stringify(scope.node.data));
                element.attr("id", node_id);
                scope.node.node_id = node_id;
            }
        };
    } ]);
    app.filter("atTreeNodeName", function() {
        return function(node) {
            switch (node.type) {
              case "platform":
              case "gbif":
                return node.data.name + " - v" + node.data.version;
                break;

              case "field":
                return node.name.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/\w\S*/g, function(txt) {
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                });
                break;
            }
            return node.name;
        };
    });
})();

(function() {
    var app = angular.module("atUI");
    app.factory("ObjectToNodeService", [ "$log", "APIService", "AlertMessageService", function($log, APIService, AlertMessageService) {
        var service = {};
        var _parentNode = null;
        var convert = function(data) {
            switch (_parentNode.child_type) {
              case "gbif":
                return convertGbif(data);

              case "gbif_type":
                return convertGbifType(data);

              case "gbif_subtype":
                return convertGbifSubtype(data);

              case "segment":
                return convertSegment(data);

              case "mixed":
                return convertMixed(data);
            }
        };
        var convertGbif = function(gbif) {
            return {
                node_type: "parent",
                type: _parentNode.child_type,
                name: gbif.name,
                data: gbif,
                child_call: "platform/" + _parentNode.data.id + "/gbif/" + gbif.id + "/gbif_types",
                children: [],
                child_type: "gbif_type",
                context_menu: [ {
                    name: "New GBIF Type",
                    icon: "fa-gbif_type",
                    action: "newGbifType",
                    context: gbif,
                    disabled: false
                }, {
                    name: "Delete",
                    icon: "fa-trash",
                    action: "deleteGbifType",
                    context: gbif,
                    disabled: true
                } ]
            };
        };
        var convertGbifType = function(gbif_type) {
            return {
                node_type: "parent",
                type: _parentNode.child_type,
                name: gbif_type.name,
                data: gbif_type,
                child_call: "platform/" + _parentNode.data.platform_id + "/gbif/" + _parentNode.data.id + "/gbif_type/" + gbif_type.id + "/gbif_subtypes",
                children: [],
                child_type: "gbif_subtype",
                context_menu: []
            };
        };
        var convertGbifSubtype = function(gbif_subtype) {
            return {
                node_type: "parent",
                type: _parentNode.child_type,
                name: gbif_subtype.name,
                data: gbif_subtype,
                child_call: _parentNode.child_call.substring(0, _parentNode.child_call.length - 1) + "/" + gbif_subtype.id + "/segment/topparent",
                children: [],
                child_type: "segment",
                context_menu: []
            };
        };
        var convertSegment = function(segment) {
            var parent_child_call = _parentNode.child_call;
            var ex = parent_child_call.split("/");
            ex = ex.splice(0, ex.length - 2);
            ex = ex.join("/");
            return {
                node_type: "parent",
                type: _parentNode.child_type,
                name: segment.name,
                data: segment,
                child_call: ex + "/parent_segment/" + segment.id + "/segments_and_fields",
                children: [],
                child_type: "mixed",
                context_menu: []
            };
        };
        var convertMixed = function(mixed) {
            var parent_child_call = _parentNode.child_call;
            var ex = parent_child_call.split("/");
            ex = ex.splice(0, ex.length - 2);
            ex = ex.join("/");
            var r = {
                node_type: "parent",
                type: "",
                name: mixed.name,
                data: mixed,
                child_call: ex + "/parent_segment/" + mixed.id + "/segments_and_fields",
                children: [],
                child_type: "mixed",
                context_menu: []
            };
            if (Object.keys(mixed).length > 5) {
                r.type = "field";
                r.node_type = "sterile";
            } else {
                r.type = "segment";
            }
            return r;
        };
        service.setParentNode = function(parent) {
            _parentNode = parent;
        };
        service.getChildren = function(cb, errorCb) {
            if (_parentNode === null) {
                $log.error("No parent node set!");
                return null;
            }
            APIService.get(_parentNode.child_call).success(function(data) {
                var converted = [];
                for (var i in data) {
                    converted.push(convert(data[i]));
                }
                _parentNode.children = converted;
                cb();
            }).error(function(status) {
                errorCb();
                AlertMessageService.showError("Oh no!", "Unable to get child nodes.");
            });
        };
        return service;
    } ]);
})();

(function() {
    angular.module("atUI").directive("undoBox", [ "UndoService", function(UndoService) {
        return {
            restrict: "A",
            template: '<div id="undo" style="display: none;">{{message}}. If it was a mistake click <a href="" ng-click="undoNow()" class="undo-trigger">here</a> to undo.<div class="dismiss"><a ng-click="dismissNow()" href="" title="Click here to dismiss"><i class="fa fa-times"></i></a></div></div>',
            controller: function($scope, $element) {
                var ref = this;
                var defaultMessage = "Nice! Your action completed successfully";
                UndoService.on("show", function(message) {
                    message = message || defaultMessage;
                    $scope.message = message;
                    ref.openMessage.apply(ref, [ message ]);
                });
                UndoService.on("hide", function() {
                    ref.closeMessage.apply(ref, []);
                });
                this.openMessage = function() {
                    $element.find("#undo").css({
                        display: "block",
                        opacity: 0
                    });
                    $element.find("#undo").animate({
                        opacity: 1
                    }, 1e3);
                };
                this.closeMessage = function() {
                    UndoService.cancelTimeout();
                    $element.find("#undo").css({
                        display: "block",
                        opacity: 1
                    });
                    $element.find("#undo").animate({
                        opacity: 0
                    }, 1e3, function() {
                        $(this).css({
                            display: "none"
                        });
                        $scope.message = defaultMessage;
                    });
                };
                $scope.undoNow = function() {
                    UndoService.runLastAction(function() {
                        ref.closeMessage();
                    });
                };
                $scope.dismissNow = function() {
                    UndoService.clearLastAction();
                    ref.closeMessage();
                };
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("UndoService", [ "$timeout", function($timeout) {
        var _lastAction = null;
        var _actionContext = null;
        var _showing = false;
        var _promise = null;
        var _events = {
            show: [],
            hide: []
        };
        var service = this;
        var _runEvents = function(event, message) {
            message = message || null;
            for (var i in _events[event]) {
                _events[event][i].apply(null, [ message ]);
            }
        };
        this.on = function(action, cb) {
            _events[action].push(cb);
        };
        var trigger = {
            _service: service,
            _undoAction: null,
            _undoContext: null,
            _dismissAction: null,
            _params: [],
            onUndo: function(action) {
                this._undoAction = action;
                return this;
            },
            contextIs: function(context) {
                this._undoContext = context;
                return this;
            },
            onDismiss: function(cb) {
                this._dismissAction = cb;
                return this;
            },
            passTheseParamsOnUndo: function(params) {
                this._params = params;
                return this;
            }
        };
        this.triggerMessage = function(message) {
            message = message || null;
            _runEvents("show", message);
            this.clearLastAction();
            _promise = $timeout(function() {
                _runEvents("hide");
                if (trigger._dismissAction !== null) {
                    trigger._dismissAction.apply(trigger._undoContext, trigger._params);
                }
            }, 1e4);
            return trigger;
        };
        this.cancelTimeout = function() {
            if (_promise !== null) {
                if ($timeout.cancel(_promise)) {
                    _promise = null;
                }
            }
        };
        this.runLastAction = function(cb) {
            cb = cb || null;
            if (trigger._undoAction !== null) {
                trigger._undoAction.apply(trigger._undoContext, trigger._params);
            }
            if (cb !== null) {
                cb.apply(null, []);
            }
        };
        this.clearLastAction = function() {
            trigger._undoAction = null;
            trigger._undoContext = null;
            trigger._dismissAction = null;
            trigger._params = [];
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    var UserProfileController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function UserProfileController($scope, $element, UserService) {
            this.$scope = $scope;
            this.$element = $element;
            this.UserService = UserService;
            this._init();
        }
        DP$0(UserProfileController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.user = null;
            this.$scope.userImg = null;
            this.UserService.getUserImage(function(img) {
                self.$scope.userImg = img;
            });
            this.UserService.getUserInfo(function(user) {
                self.$scope.user = user;
            });
        };
        MIXIN$0(UserProfileController.prototype, proto$0);
        proto$0 = void 0;
        return UserProfileController;
    }();
    app.directive("userProfile", [ function() {
        return {
            templateUrl: "assets/templates/core/shared/user/userProfile.html",
            controller: [ "$scope", "$element", "UserService", UserProfileController ]
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("UserService", [ "APIService", "AlertMessageService", "jwtHelper", "AjaxQueueService", "$q", function(APIService, AlertMessageService, jwtHelper, AjaxQueueService, $q) {
        var _queue = [];
        var _userCache = {};
        var _currentUser = false;
        var _userImgPath = "http://zoomglobal/my/User%20Photos/Profile%20Pictures/{USER_ID}_MThumb.jpg?t=";
        var _checkCache = function(id) {
            if (_userCache.hasOwnProperty(id)) {
                return _userCache[id];
            }
            return false;
        };
        var _cache = function(user) {
            _userCache[user.userID] = user;
        };
        AjaxQueueService.register("userService");
        this.searchForUser = function(query, cb) {
            APIService.get("user/q/" + query).success(function(users) {
                cb.apply(null, [ users ]);
            });
        };
        this.getFilePermissions = function(cb) {
            APIService.get("user/file_permissions").success(function(data) {
                cb(data);
            }).error(function(status) {
                AlertMessageService.showError("Oh No!", "Unable to get user information! [" + status + "]");
            });
        };
        this.getPerspectives = function(cb) {
            APIService.get("user/perspectives").success(function(data) {
                data.sort(function(a, b) {
                    if (a.rank > b.rank) return -1;
                    if (a.rank < b.rank) return 1;
                    return 0;
                });
                for (var i in data) {
                    data[i].active = false;
                }
                data[data.length - 1].active = true;
                cb(data);
            });
        };
        this.getUser = function(id, cb) {
            AjaxQueueService.addToQueue("user/id/" + id, "userService", function(user) {
                cb.apply(null, [ user ]);
            });
        };
        this.ping = function(cb) {
            APIService.get("ping").success(function(token) {
                var claims = jwtHelper.decodeToken(token);
                cb.apply(null, []);
            });
        };
        this.touch = function(cb) {
            APIService.get("user/info").success(function() {
                cb();
            });
        };
        this.getUserImage = function(cb) {
            var self = this;
            this.getUserInfo(function(user) {
                self.getThisUserImage(user, cb);
            });
        };
        this._getImageUrl = function(user) {
            return _userImgPath.replace("{USER_ID}", user.logonID.toLowerCase()) + Date.now();
        };
        this._checkIfImage = function(url) {
            var deferred = $q.defer();
            var image = new Image();
            image.onerror = function() {
                deferred.resolve(false);
            };
            image.onload = function() {
                deferred.resolve(true);
            };
            image.src = url;
            return deferred.promise;
        };
        this.getThisUserImage = function(user, cb) {
            var url = this._getImageUrl(user);
            this._checkIfImage(url).then(function(r) {
                if (r) {
                    return cb.apply(null, [ url ]);
                }
                cb.apply(null, [ "/assets/img/user.jpg" ]);
            });
        };
        this.getUserInfo = function(cb) {
            cb = cb || null;
            AjaxQueueService.addToQueue("user/info", "userService", function(user) {
                if (cb !== null) {
                    cb.apply(null, [ user ]);
                }
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atCore");
    var UserWidgetController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function UserWidgetController($scope, $element, $attrs, UserService) {
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            this.UserService = UserService;
            this._init();
        }
        DP$0(UserWidgetController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            if (this.$attrs.hasOwnProperty("atType")) {
                this.$scope.type = this.$attrs.atType;
            } else {
                this.$scope.type = "default";
            }
            this.$scope.background = false;
            this.$scope.backgroundImg = null;
            this.$scope.userImg = null;
            this.UserService.getThisUserImage(this.$scope.atUser, function(img) {
                self.$scope.userImg = img;
            });
        };
        MIXIN$0(UserWidgetController.prototype, proto$0);
        proto$0 = void 0;
        return UserWidgetController;
    }();
    app.directive("userWidget", [ function() {
        return {
            templateUrl: "assets/templates/core/shared/user/userWidget.html",
            scope: {
                atUser: "="
            },
            controller: [ "$scope", "$element", "$attrs", "UserService", UserWidgetController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("UsersService", [ "AjaxQueueService", "localStorageService", "APIService", function(AjaxQueueService, localStorageService, APIService) {
        AjaxQueueService.register("users");
        var _usersCache = {
            data: [],
            expireOn: null
        };
        var _groupsCache = {
            data: [],
            expireOn: null
        };
        this.findUserById = function(id, cb) {
            AjaxQueueService.addToQueue("user/info/" + id, "users", cb);
        };
        this.clearCache = function(which) {
            if (which === "groups") {
                _groupsCache = {
                    data: [],
                    expireOn: null
                };
            } else {
                _usersCache = {
                    data: [],
                    expireOn: null
                };
            }
        };
        this.deleteGroup = function(group, cb) {
            APIService.delete("group/" + group.groupID).success(function() {
                cb.apply(null, []);
            });
        };
        this.ldapSearch = function(surname, cb) {
            APIService.get("user/q/" + surname).success(function(results) {
                var r = [];
                var count = 0;
                for (var i in results) {
                    count = results[i].length;
                    break;
                }
                for (var i$0 = 0; i$0 < count; i$0++) {
                    var tmp = {};
                    for (var o in results) {
                        tmp[o] = results[o][i$0];
                    }
                    r.push(tmp);
                }
                cb.apply(null, [ r ]);
            });
        };
        this.getAllUsers = function(cb) {
            var users = _usersCache.data;
            if (users.length === 0) {
                users = localStorageService.get("users");
                if (users === null) {
                    return AjaxQueueService.addToQueue("api/users", "users", function(_users) {
                        _usersCache.data = _users;
                        _usersCache.expireOn = new Date().setDate(new Date().getDate() + 1);
                        localStorageService.set("users", _usersCache);
                        cb.apply(null, [ _usersCache.data ]);
                    });
                } else {
                    if (users.expireOn > new Date()) {
                        localStorageService.remove("users");
                    }
                    users = users.data;
                }
            }
            return cb.apply(null, [ users ]);
        };
        this.getUsersOfGroup = function(groupID) {
            return APIService.get("group/" + groupID + "/users");
        };
        this.getAllGroups = function(cb) {
            var groups = _groupsCache.data;
            if (groups.length === 0) {
                groups = localStorageService.get("groups");
                if (groups === null) {
                    return AjaxQueueService.addToQueue("api/groups", "users", function(_groups) {
                        _groupsCache.data = _groups;
                        _groupsCache.expireOn = new Date().setDate(new Date().getDate() + 1);
                        localStorageService.set("groups", _groupsCache);
                        cb.apply(null, [ _groupsCache.data ]);
                    });
                } else {
                    if (groups.expireOn > new Date()) {
                        localStorageService.remove("groups");
                    }
                    groups = groups.data;
                }
            }
            return cb.apply(null, [ groups ]);
        };
    } ]);
})();

angular.module("atUI").factory("ErrorMessagesService", function() {
    return {
        msgs: []
    };
});

(function() {
    angular.module("atUI").directive("requiredIfNotDisabled", function() {
        return {
            restrict: "A",
            link: function(scope, el) {
                var elm = angular.element(el[0]);
                var $dep = $("#" + elm.attr("data-dep-on"));
                $dep.bind("change", function() {
                    if (elm.is(":disabled")) {
                        elm.removeAttr("required");
                        var $group = elm.closest(".form-group");
                        $group.removeClass("has-error");
                        $group.removeClass("has-success");
                    } else {
                        elm.attr("required", "required");
                    }
                });
            }
        };
    });
})();

(function() {
    angular.module("atUI").directive("showErrors", function() {
        return {
            restrict: "A",
            link: function(scope, element) {
                var toggleSuccess = function() {
                    var inputNgEl = getInputNG();
                    element.toggleClass("has-error", inputNgEl.hasClass("ng-invalid") && inputNgEl.hasClass("ng-dirty"));
                    if (inputNgEl.val() === "" || inputNgEl.val() === null) {
                        element.removeClass("has-success");
                    }
                };
                var toggleError = function() {
                    var inputNgEl = getInputNG();
                    element.toggleClass("has-error", inputNgEl.hasClass("ng-invalid"));
                };
                var getInputNG = function() {
                    var inputEl = element[0].querySelector(".form-control");
                    var inputNgEl = angular.element(inputEl);
                    return inputNgEl;
                };
                var toggleAll = function() {
                    var inputNgEl = getInputNG();
                    element.toggleClass("has-success", inputNgEl.hasClass("ng-valid") && inputNgEl.hasClass("ng-dirty"));
                    if (inputNgEl.attr("required") === undefined) {
                        toggleSuccess();
                    } else {
                        toggleError();
                    }
                };
                var inputNgEl = getInputNG();
                inputNgEl.bind("blur", function() {
                    toggleAll();
                });
            }
        };
    });
})();

(function() {
    var app = angular.module("atUI");
    app.directive("validation-phone", [ "$log", function($log) {
        return {
            restrict: "AC",
            link: function(scope, element, attrs) {
                $log.log(scope.arc[element.id]);
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("ValidationService", [ "APIService", function(APIService) {
        this.getValidationRulesFor = function(field, rules) {
            for (var i in rules) {
                if (rules[i].field_id === field.field_id) {
                    return rules[i];
                }
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var GroupsController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function GroupsController($scope, UsersService, AdminModalService, NotificationQueue) {
            this.$scope = $scope;
            this.$scope.groups = [];
            this.UsersService = UsersService;
            this.AdminModalService = AdminModalService;
            this.NotificationQueue = NotificationQueue;
            this.getGroups();
            this.setupEvents();
        }
        DP$0(GroupsController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0.editGroup = function(group) {
            this.AdminModalService.up("groups", group);
        };
        proto$0.getGroups = function() {
            var self = this;
            this.UsersService.getAllGroups(function(groups) {
                self.$scope.groups = groups;
            });
        };
        proto$0.newGroup = function() {
            this.AdminModalService.up("groups", {});
        };
        proto$0.deleteGroup = function(group) {
            var self = this;
            this.UsersService.deleteGroup(group, function() {
                self.NotificationQueue.push({
                    icon: "thumbs-o-up",
                    text: "Group has been deleted!"
                });
                self.UsersService.clearCache("groups");
                self.getGroups();
            });
        };
        proto$0.setupEvents = function() {
            var self = this;
            this.$scope.$on("groups-controller-refresh", function() {
                self.getGroups();
            });
            this.$scope.onEdit = function(group) {
                self.editGroup(group);
            };
            this.$scope.startNew = function() {
                self.newGroup();
            };
            this.$scope.onDelete = function(group) {
                self.deleteGroup(group);
            };
        };
        MIXIN$0(GroupsController.prototype, proto$0);
        proto$0 = void 0;
        return GroupsController;
    }();
    app.controller("GroupsController", [ "$scope", "UsersService", "AdminModalService", "NotificationQueue", GroupsController ]);
})();

(function() {
    var app = angular.module("atUI");
    function GroupsModal(APIService, AdminModalService, UsersService, NotificationQueue) {
        return {
            controller: function($scope, $element) {
                var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
                var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
                function GET_ITER$0(v) {
                    if (v) {
                        if (Array.isArray(v)) return 0;
                        var f;
                        if (S_MARK$0) S_MARK$0(v);
                        if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                            if (S_MARK$0) S_MARK$0(void 0);
                            return f.call(v);
                        }
                        if (S_MARK$0) S_MARK$0(void 0);
                        if (v + "" === "[object Generator]") return v;
                    }
                    throw new Error(v + " is not iterable");
                }
                $scope.group = {};
                $scope.users = [];
                $scope.usersOut = [];
                $scope.usersToRemove = [];
                $scope.usersToMove = [];
                AdminModalService.register("groups", function() {
                    var group = arguments[0];
                    if (group === void 0) group = {};
                    $scope.group = group;
                    UsersService.getAllUsers(function(users) {
                        $scope.users = users;
                    });
                    if ($scope.group.hasOwnProperty("groupID")) {
                        UsersService.getUsersOfGroup($scope.group.groupID).success(function(u) {
                            $scope.usersOut = u;
                            $scope.users = $scope.users.filter(function(e, i, a) {
                                var $D$0;
                                var $D$1;
                                var $D$2;
                                var $D$3;
                                $D$3 = this.users;
                                $D$0 = GET_ITER$0($D$3);
                                $D$2 = $D$0 === 0;
                                $D$1 = $D$2 ? $D$3.length : void 0;
                                for (var u; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                                    u = $D$2 ? $D$3[$D$0++] : $D$1["value"];
                                    if (e.userID === u.userID) {
                                        return false;
                                    }
                                }
                                $D$0 = $D$1 = $D$2 = $D$3 = void 0;
                                return true;
                            }, {
                                users: u
                            });
                        });
                    }
                    $element.modal();
                });
                $scope.moveUsers = function() {
                    var $D$4;
                    var $D$5;
                    var $D$6;
                    var $D$7;
                    $D$7 = $scope.usersToMove;
                    $D$4 = GET_ITER$0($D$7);
                    $D$6 = $D$4 === 0;
                    $D$5 = $D$6 ? $D$7.length : void 0;
                    for (var userID; $D$6 ? $D$4 < $D$5 : !($D$5 = $D$4["next"]())["done"]; ) {
                        userID = $D$6 ? $D$7[$D$4++] : $D$5["value"];
                        var fI = $scope.users.map(function(x) {
                            return parseInt(x.userID);
                        }).indexOf(parseInt(userID));
                        $scope.usersOut.push($scope.users[fI]);
                        $scope.users.splice(fI, 1);
                    }
                    $D$4 = $D$5 = $D$6 = $D$7 = void 0;
                    $scope.usersToMove = [];
                };
                $scope.removeUsers = function() {
                    var $D$8;
                    var $D$9;
                    var $D$10;
                    var $D$11;
                    $D$11 = $scope.usersToRemove;
                    $D$8 = GET_ITER$0($D$11);
                    $D$10 = $D$8 === 0;
                    $D$9 = $D$10 ? $D$11.length : void 0;
                    for (var userID; $D$10 ? $D$8 < $D$9 : !($D$9 = $D$8["next"]())["done"]; ) {
                        userID = $D$10 ? $D$11[$D$8++] : $D$9["value"];
                        var fI = $scope.usersOut.map(function(x) {
                            return parseInt(x.userID);
                        }).indexOf(parseInt(userID));
                        $scope.users.push($scope.usersOut[fI]);
                        $scope.usersOut.splice(fI, 1);
                    }
                    $D$8 = $D$9 = $D$10 = $D$11 = void 0;
                    $scope.usersToRemove = [];
                };
                $scope.save = function() {
                    if ($scope.group.hasOwnProperty("name") === false || $scope.group.name === null || $scope.group.name === "") {
                        NotificationQueue.push({
                            icon: "frown-o",
                            text: "Group needs a name!"
                        });
                        return;
                    }
                    if ($scope.group.hasOwnProperty("description") === false || $scope.group.description === null || $scope.group.description === "") {
                        NotificationQueue.push({
                            icon: "frown-o",
                            text: "Group needs a description!"
                        });
                        return;
                    }
                    APIService.post("group", {
                        group: $scope.group,
                        users: $scope.usersOut
                    }).success(function(res) {
                        UsersService.clearCache("groups");
                        NotificationQueue.push({
                            icon: "thumbs-o-up",
                            text: "Group saved!"
                        });
                        $scope.$broadcast("groups-controller-refresh");
                        $element.modal("hide");
                    });
                };
            }
        };
    }
    app.directive("groupsModal", [ "APIService", "AdminModalService", "UsersService", "NotificationQueue", GroupsModal ]);
})();

(function() {
    var app = angular.module("atUI");
    var AdminModalService = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function AdminModalService(APIService) {
            this.APIService = APIService;
            this.modals = {};
        }
        DP$0(AdminModalService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0.register = function(name, onUp) {
            this.modals[name] = onUp;
        };
        proto$0.up = function(name, data) {
            this.modals[name].apply(null, [ data ]);
        };
        MIXIN$0(AdminModalService.prototype, proto$0);
        proto$0 = void 0;
        return AdminModalService;
    }();
    app.service("AdminModalService", [ "APIService", AdminModalService ]);
})();

(function() {
    var app = angular.module("atUI");
    var UsersController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function UsersController($scope, UsersService, AdminModalService, NotificationQueue, UserService) {
            this.$scope = $scope;
            this.$scope.users = [];
            this.UsersService = UsersService;
            this.AdminModalService = AdminModalService;
            this.NotificationQueue = NotificationQueue;
            this.UserService = UserService;
            this.getUsers();
            this.setupEvents();
        }
        DP$0(UsersController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0.getUsers = function() {
            var self = this;
            this.UsersService.getAllUsers(function(users) {
                var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
                var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
                function GET_ITER$0(v) {
                    if (v) {
                        if (Array.isArray(v)) return 0;
                        var f;
                        if (S_MARK$0) S_MARK$0(v);
                        if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                            if (S_MARK$0) S_MARK$0(void 0);
                            return f.call(v);
                        }
                        if (S_MARK$0) S_MARK$0(void 0);
                        if (v + "" === "[object Generator]") return v;
                    }
                    throw new Error(v + " is not iterable");
                }
                var $D$0;
                var $D$1;
                var $D$2;
                var $D$3;
                self.$scope.users = users;
                $D$3 = self.$scope.users;
                $D$0 = GET_ITER$0($D$3);
                $D$2 = $D$0 === 0;
                $D$1 = $D$2 ? $D$3.length : void 0;
                for (var u; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                    u = $D$2 ? $D$3[$D$0++] : $D$1["value"];
                    (function(u) {
                        self.UserService.getThisUserImage(u, function(img) {
                            u.img = img;
                        });
                    })(u);
                }
                $D$0 = $D$1 = $D$2 = $D$3 = void 0;
            });
        };
        proto$0.newUser = function() {
            this.AdminModalService.up("users", {});
        };
        proto$0.deleteUser = function(user) {
            var self = this;
            this.UsersService.deleteUser(user, function() {
                self.NotificationQueue.push({
                    icon: "thumbs-o-up",
                    text: "User has been deleted!"
                });
                self.UsersService.clearCache("users");
                self.getUsers();
            });
        };
        proto$0.setupEvents = function() {
            var self = this;
            this.$scope.$on("users-controller-refresh", function() {
                self.getUsers();
            });
            this.$scope.startNew = function() {
                self.newUser();
            };
            this.$scope.onDelete = function(user) {
                self.deleteUser(user);
            };
        };
        MIXIN$0(UsersController.prototype, proto$0);
        proto$0 = void 0;
        return UsersController;
    }();
    app.controller("UsersController", [ "$scope", "UsersService", "AdminModalService", "NotificationQueue", "UserService", UsersController ]);
})();

(function() {
    var app = angular.module("atUI");
    function UsersModal(APIService, AdminModalService, UsersService, NotificationQueue) {
        return {
            controller: function($scope, $element) {
                $scope.ldapUsers = [];
                $scope.surname = null;
                $scope.$watch("surname", function(oldValue, newValue, scope) {
                    if (scope.surname !== null && scope.surname.length > 2) {
                        runSearch();
                    }
                });
                var runSearch = function() {
                    UsersService.ldapSearch($scope.surname, function(results) {
                        $scope.ldapUsers = results.map(function(u) {
                            u.logonID = u.userPrincipalName.replace(/(\@.*$)/, "");
                            return u;
                        });
                    });
                };
                AdminModalService.register("users", function() {
                    $element.modal();
                });
                $scope.save = function() {};
            }
        };
    }
    app.directive("usersModal", [ "APIService", "AdminModalService", "UsersService", "NotificationQueue", UsersModal ]);
})();

(function() {
    var app = angular.module("atUI");
    var controller = function($scope, ApiPermissionsService, $sce, UsersService) {
        $scope.apis = [];
        $scope.iC = null;
        $scope.methods = [ "GET", "POST", "PUT", "DELETE" ];
        $scope.users = [];
        $scope.groups = [];
        ApiPermissionsService.fetch(function(apis) {
            $scope.apis = apis;
        });
        UsersService.getAllUsers(function(users) {
            $scope.users = users;
        });
        UsersService.getAllGroups(function(groups) {
            $scope.groups = groups;
        });
        $scope.prettyPath = function(api) {
            var path = api.path;
            return path.replace(/(\/services\/gbp)(.+)/i, '<span class="path-prefix">$1</span><span class="path-call">$2</span>').replace(/(\{[0-9a-zA-Z_]+\})/g, '<span class="path-param">$1</span>');
        };
        $scope.onEdit = function(api) {
            $scope.iC = api;
            ApiPermissionsService.up("edit");
        };
        $scope.startNew = function() {
            ApiPermissionsService.up("new");
        };
        $scope.onDelete = function(api) {
            ApiPermissionsService.delete(api.methodID, function() {
                for (var index in $scope.apis) {
                    if ($scope.apis[index].methodID === api.methodID) {
                        $scope.apis.splice(index, 1);
                        break;
                    }
                }
            });
        };
    };
    app.controller("ApiPermissionsController", [ "$scope", "ApiPermissionsService", "$sce", "UsersService", controller ]);
    var apiModal = function(ApiPermissionsService) {
        return {
            controller: function($scope, $element) {
                $scope.edit = null;
                $scope.perms = {
                    groups: {},
                    users: {}
                };
                var _mode = "edit";
                ApiPermissionsService.onUp(function(mode) {
                    if (mode === "edit") {
                        $scope.edit = angular.copy($scope.iC);
                        ApiPermissionsService.getPermissions($scope.edit.methodID, function(perm) {
                            for (var p in perm) {
                                if (perm[p].controlType === "GROUP") {
                                    $scope.perms.groups[perm[p].controlID] = true;
                                } else {
                                    $scope.perms.users[perm[p].controlID] = true;
                                }
                            }
                        });
                    } else {
                        $scope.edit = {
                            path: "/services/gbp/",
                            requestMethod: "GET",
                            description: null
                        };
                    }
                    _mode = mode;
                    $element.modal();
                });
                $element.on("hidden.bs.modal", function() {
                    $scope.iC = null;
                    $scope.edit = null;
                    $scope.perms.users = {};
                    $scope.perms.groups = {};
                });
                $element.on("shown.bs.modal", function() {
                    $element.find("#requestMethod").focus();
                });
                $scope.save = function() {
                    if (_mode === "edit") {
                        ApiPermissionsService.save({
                            accessMethod: $scope.edit,
                            accessControl: $scope.perms
                        }, function(api) {
                            for (var index in $scope.apis) {
                                if ($scope.apis[index].methodID === api.methodID) {
                                    $scope.apis[index] = api;
                                    break;
                                }
                            }
                            $element.modal("hide");
                        });
                    } else {
                        ApiPermissionsService.create({
                            accessMethod: $scope.edit,
                            accessControl: $scope.perms
                        }, function(api) {
                            $scope.apis.push(api);
                            $element.modal("hide");
                        });
                    }
                };
            }
        };
    };
    app.directive("apiModal", [ "ApiPermissionsService", apiModal ]);
})();

(function() {
    var app = angular.module("atUI");
    var service = function(APIService) {
        var _apis = [], _onUp = null, _FETCH = "api", _SAVE = "api", _CREATE = "api", _DELETE = "api/", _GET_PERMS = "api/{id}/permissions";
        this.fetch = function(cb) {
            APIService.get(_FETCH).success(function(data) {
                _apis = data.sort(function(a, b) {
                    if (a.path < b.path) {
                        return -1;
                    }
                    if (a.path > b.path) {
                        return 1;
                    }
                    return 0;
                });
                cb.apply(null, [ _apis ]);
            });
        };
        this.getPermissions = function(id, cb) {
            APIService.get(_GET_PERMS.replace("{id}", id)).success(function(res) {
                cb.apply(null, [ res ]);
            });
        };
        this.save = function(permission, cb) {
            APIService.post(_SAVE, permission).success(function(res) {
                cb.apply(null, [ res ]);
            });
        };
        this.create = function(permission, cb) {
            APIService.put(_CREATE, permission).success(function(res) {
                cb.apply(null, [ res ]);
            });
        };
        this.delete = function(id, cb) {
            APIService.delete(_DELETE + id).success(function() {
                cb.apply(null, []);
            });
        };
        this.onUp = function(cb) {
            _onUp = cb;
        };
        this.up = function(mode) {
            _onUp.apply(null, [ mode ]);
        };
    };
    app.service("ApiPermissionsService", [ "APIService", service ]);
})();

(function() {
    var PRS$0 = function(o, t) {
        o["__proto__"] = {
            a: t
        };
        return o["a"] === t;
    }({}, {});
    var DP$0 = Object.defineProperty;
    var GOPD$0 = Object.getOwnPropertyDescriptor;
    var MIXIN$0 = function(t, s) {
        for (var p in s) {
            if (s.hasOwnProperty(p)) {
                DP$0(t, p, GOPD$0(s, p));
            }
        }
        return t;
    };
    var app = angular.module("atUI");
    var DeploymentLevelPathService = function() {
        "use strict";
        var proto$0 = {};
        function DeploymentLevelPathService() {
            this._levelPaths = {
                Layout: "layout/all/",
                Segment: "segment/all/raw/",
                "Code Group": "code/groups/p/"
            };
        }
        DP$0(DeploymentLevelPathService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0.getPath = function(path, deploymentID) {
            return this._levelPaths[path] + deploymentID;
        };
        MIXIN$0(DeploymentLevelPathService.prototype, proto$0);
        proto$0 = void 0;
        return DeploymentLevelPathService;
    }();
    app.service("DeploymentLevelPathService", [ DeploymentLevelPathService ]);
    var DeploymentCompareController = function() {
        "use strict";
        var proto$0 = {};
        function DeploymentCompareController($scope, PlatformService, NavBarToggleService, ModalService, APIService, DiffService, DeploymentLevelPathService, StoreService, $route) {
            this.$scope = $scope;
            this.PlatformService = PlatformService;
            this.NavBarToggleService = NavBarToggleService;
            this.ModalService = ModalService;
            this.APIService = APIService;
            this.DiffService = DiffService;
            this.DeploymentLevelPathService = DeploymentLevelPathService;
            this.StoreService = StoreService;
            this.$route = $route;
            this._setupScope();
            this._init();
        }
        DP$0(DeploymentCompareController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._setupScope = function() {
            var self = this;
            this._setupGlobalScope();
            this._setupScopeForDiffSelectDeployments();
            this._setupLevelScope();
        };
        proto$0._init = function() {
            this.StoreService.leftOffHere("Deployment Compare");
            this._globalInit();
        };
        proto$0._deploymentsSelected = function() {
            this.NavBarToggleService.doClose();
            this.$scope.deploymentsSelected = true;
            this.ModalService.summon("diff-step1-modal");
        };
        proto$0._globalInit = function() {
            this._MAX_DIFFS = 3;
        };
        proto$0._setupGlobalScope = function() {
            var self = this;
            this.$scope.diffDeployments = [];
            this.$scope.deploymentPanels = {};
            this.$scope.deploymentsSelected = false;
            this.$scope.reset = function() {
                self.reset();
            };
            this.$scope.$on("$destroy", function() {
                self.DiffService.onDestroy();
            });
        };
        proto$0.reset = function() {
            this.$route.reload();
        };
        proto$0._setupLevelScope = function() {
            var self = this;
            this.$scope.levels = [ "Layout", "Segment", "Code Group" ];
            this.$scope.currentLevel = this.$scope.levels[0];
            this.$scope.selectLevel = function(level) {
                self.selectLevel(level);
            };
            this.$scope.fetchLevel = function() {
                self.fetchLevel();
            };
            this.$scope.$on("mouseover-diff-item", function(e, item) {
                self.$scope.$broadcast("mouseover-" + item.__LEVEL + "-" + item.index);
                e.preventDefault();
                e.stopPropagation();
            });
            this.$scope.$on("mouseleave-diff-item", function(e, item) {
                self.$scope.$broadcast("mouseleave-" + item.__LEVEL + "-" + item.index);
                e.preventDefault();
                e.stopPropagation();
            });
            this.$scope.$on("open-diff-item", function(e, item) {
                self.$scope.$broadcast("open-" + item.__LEVEL + "-" + item.index);
                e.preventDefault();
                e.stopPropagation();
            });
        };
        proto$0._getPath = function(level, id) {
            return this.DeploymentLevelPathService.getPath(level, id);
        };
        proto$0.selectLevel = function(level) {
            this.$scope.currentLevel = level;
        };
        proto$0.fetchLevel = function() {
            var $that$0 = this;
            var self = this;
            for (var deploymentID in this.$scope.deploymentPanels) {
                (function(deploymentID) {
                    $that$0.APIService.get($that$0._getPath($that$0.$scope.currentLevel, deploymentID)).success(function(items) {
                        var ii = items.map(function(c) {
                            if (typeof c !== "object") {
                                return {
                                    name: c
                                };
                            }
                            return c;
                        });
                        self.$scope.deploymentPanels[deploymentID].setItems(ii);
                    });
                })(deploymentID);
            }
        };
        proto$0._setupScopeForDiffSelectDeployments = function() {
            var self = this;
            this.$scope.deployments = [];
            this._fetchDeployments();
            this.$scope.selectDeployment = function(deployment) {
                self.selectDeployment(deployment);
            };
            this.$scope.addForDiff = function() {
                self.addForDiff();
            };
            this.$scope.doDeploymentsSelected = function() {
                self._deploymentsSelected();
            };
        };
        proto$0._fetchDeployments = function() {
            var self = this;
            this.PlatformService.fetchPlatforms(function() {
                self.$scope.deployments = angular.copy(self.PlatformService.getPlatforms());
                self.$scope.currentSelectedDeployment = self.$scope.deployments[0];
            });
        };
        proto$0.selectDeployment = function(deployment) {
            this.$scope.currentSelectedDeployment = deployment;
        };
        proto$0.addForDiff = function() {
            var deployment = this.$scope.currentSelectedDeployment;
            if (this.$scope.diffDeployments.length === this._MAX_DIFFS) {
                return;
            }
            this.$scope.diffDeployments.push(deployment);
            this.$scope.deploymentPanels[deployment.id] = {
                _cb: null,
                items: [],
                onUpdate: function(cb) {
                    this._cb = cb;
                },
                setItems: function(items) {
                    this.items = items;
                    this._cb.apply(null, [ this.items ]);
                }
            };
            this.DiffService.addPanel(deployment.id);
            for (var i in this.$scope.deployments) {
                if (this.$scope.deployments[i].id === deployment.id) {
                    this.$scope.deployments.splice(i, 1);
                    this.$scope.currentSelectedDeployment = this.$scope.deployments[0];
                    if (this.$scope.diffDeployments.length === this._MAX_DIFFS) {
                        this._deploymentsSelected();
                    }
                    return;
                }
            }
        };
        MIXIN$0(DeploymentCompareController.prototype, proto$0);
        proto$0 = void 0;
        return DeploymentCompareController;
    }();
    app.controller("DeploymentCompareController", [ "$scope", "PlatformService", "NavBarToggleService", "ModalService", "APIService", "DiffService", "DeploymentLevelPathService", "StoreService", "$route", DeploymentCompareController ]);
    app.directive("fullHeightPanel", [ "$timeout", function($timeout) {
        return {
            link: function(scope, element) {
                $timeout(function() {
                    var stageHeight = parseInt($("#stage").height());
                    var wrapperPadding = parseInt($("#stage > .wrapper").css("paddingTop")) * 2;
                    var headingHeight = parseInt(element.find(".panel-heading").outerHeight(true));
                    var panelHeight = parseInt(element.outerHeight(true)) - parseInt(element.outerHeight());
                    element.find(".panel-body").css("height", stageHeight - wrapperPadding - headingHeight - panelHeight - 2);
                }, 100);
            }
        };
    } ]);
    app.directive("syncedScrollManager", [ function() {
        return {
            controller: [ "$scope", "$element", function($scope, $element) {
                $scope.panels = [];
                var _scroll = {
                    left: 0,
                    top: 0
                };
                var _attachListener = function(panel) {
                    $(panel).on("scroll", function(e) {
                        _syncScrollFire(e);
                    });
                    return panel;
                };
                var _syncScrollFire = function(e) {
                    var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
                    var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
                    function GET_ITER$0(v) {
                        if (v) {
                            if (Array.isArray(v)) return 0;
                            var f;
                            if (S_MARK$0) S_MARK$0(v);
                            if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                                if (S_MARK$0) S_MARK$0(void 0);
                                return f.call(v);
                            }
                            if (S_MARK$0) S_MARK$0(void 0);
                            if (v + "" === "[object Generator]") return v;
                        }
                        throw new Error(v + " is not iterable");
                    }
                    var $D$0;
                    var $D$1;
                    var $D$2;
                    var $D$3;
                    if (e.isTrigger) {
                        $(e.target).scrollLeft(_scroll.left);
                        $(e.target).scrollTop(_scroll.top);
                    } else {
                        _scroll.left = e.target.scrollLeft;
                        _scroll.top = e.target.scrollTop;
                        $D$3 = $scope.panels;
                        $D$0 = GET_ITER$0($D$3);
                        $D$2 = $D$0 === 0;
                        $D$1 = $D$2 ? $D$3.length : void 0;
                        for (var el; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                            el = $D$2 ? $D$3[$D$0++] : $D$1["value"];
                            if (!$(el)[0].isSameNode(e.target)) {
                                $(el).trigger("scroll");
                            }
                        }
                        $D$0 = $D$1 = $D$2 = $D$3 = void 0;
                    }
                };
                this.addPanel = function(panel) {
                    $scope.panels.push(_attachListener(panel));
                };
            } ]
        };
    } ]);
    app.directive("syncedScroll", [ function() {
        return {
            require: "^syncedScrollManager",
            link: function(scope, element, attrs, controller) {
                controller.addPanel(element);
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var DiffService = function(super$0) {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var SP$0 = Object.setPrototypeOf || function(o, p) {
            if (PRS$0) {
                o["__proto__"] = p;
            } else {
                DP$0(o, "__proto__", {
                    value: p,
                    configurable: true,
                    enumerable: false,
                    writable: true
                });
            }
            return o;
        };
        var OC$0 = Object.create;
        if (!PRS$0) MIXIN$0(DiffService, super$0);
        var proto$0 = {};
        function DiffService() {
            super$0.call(this);
        }
        if (super$0 !== null) SP$0(DiffService, super$0);
        DiffService.prototype = OC$0(super$0 !== null ? super$0.prototype : null, {
            constructor: {
                value: DiffService,
                configurable: true,
                writable: true
            }
        });
        DP$0(DiffService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._getUniquePanels = function(panels) {
            var unique = [];
            for (var i in panels) {
                for (var ii in panels[i].data) {
                    unique.push(panels[i].data[ii]);
                }
            }
            return unique.reduce(function(p, c) {
                var found = false;
                for (var i in p) {
                    if (p[i].name === c.name) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    p.push(c);
                }
                return p;
            }, []);
        };
        proto$0._initDiff = function() {
            var newP = {};
            for (var i in this._panels) {
                newP[i] = [];
            }
            var panels = angular.copy(this._panels);
            var unique = this._getUniquePanels(panels);
            for (var i$0 in panels) {
                for (var a in unique) {
                    var found = false;
                    for (var ii in panels[i$0].data) {
                        if (unique[a].name === panels[i$0].data[ii].name) {
                            found = panels[i$0].data[ii];
                            break;
                        }
                    }
                    if (found !== false) {
                        newP[i$0].push(found);
                    } else {
                        var newItem = angular.copy(unique[a]);
                        newItem.__MISSING = true;
                        newP[i$0].push(newItem);
                    }
                }
            }
            this._complete(newP);
        };
        MIXIN$0(DiffService.prototype, proto$0);
        proto$0 = void 0;
        return DiffService;
    }(BaseDiff);
    app.service("DiffService", [ DiffService ]);
})();

(function() {
    var app = angular.module("atUI");
    var DynamicPanelItemController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DynamicPanelItemController($scope, $element, $compile, DiffService) {
            this.$scope = $scope;
            this.$element = $element;
            this.$compile = $compile;
            this.DiffService = DiffService;
            this._initScope();
            this._init();
        }
        DP$0(DynamicPanelItemController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._initScope = function() {
            this.$scope.items = [];
        };
        proto$0._init = function() {
            this._setupDataStream();
        };
        proto$0._setupDataStream = function() {
            var self = this;
            this.DiffService.onComplete(self.$scope.deploymentId, function(diff) {
                self.$scope.items = diff;
                self._render();
            });
            this.$scope.itemData.onUpdate(function(items) {
                self.DiffService.setData(self.$scope.deploymentId, items.map(function(i) {
                    i.index = i.name;
                    return i;
                }));
            });
            this.$scope.mouseOver = function(item) {
                self.$scope.$emit("mouseover-diff-item", item);
            };
            this.$scope.mouseLeave = function(item) {
                self.$scope.$emit("mouseleave-diff-item", item);
            };
        };
        proto$0._getLevel = function() {
            var tmp = this.$scope.level.toLowerCase();
            return tmp.replace(" ", "-");
        };
        proto$0._render = function() {
            var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
            var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
            function GET_ITER$0(v) {
                if (v) {
                    if (Array.isArray(v)) return 0;
                    var f;
                    if (S_MARK$0) S_MARK$0(v);
                    if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                        if (S_MARK$0) S_MARK$0(void 0);
                        return f.call(v);
                    }
                    if (S_MARK$0) S_MARK$0(void 0);
                    if (v + "" === "[object Generator]") return v;
                }
                throw new Error(v + " is not iterable");
            }
            var $D$0;
            var $D$1;
            var $D$2;
            var $D$3;
            $D$3 = this.$scope.items;
            $D$0 = GET_ITER$0($D$3);
            $D$2 = $D$0 === 0;
            $D$1 = $D$2 ? $D$3.length : void 0;
            for (var item; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                item = $D$2 ? $D$3[$D$0++] : $D$1["value"];
                var dom = '<div ng-mouseenter="mouseOver(item)" ng-mouseleave="mouseLeave(item)" class="diff-item" diff-' + this._getLevel() + "-item></div>";
                var newScope = this.$scope.$new();
                newScope.deploymentID = this.$scope.deploymentId;
                item.__LEVEL = this._getLevel();
                newScope.item = item;
                var el = this.$compile(dom)(newScope);
                this.$element.append(el);
            }
            $D$0 = $D$1 = $D$2 = $D$3 = void 0;
        };
        MIXIN$0(DynamicPanelItemController.prototype, proto$0);
        proto$0 = void 0;
        return DynamicPanelItemController;
    }();
    app.directive("dynamicPanelItem", [ function() {
        return {
            scope: {
                itemData: "=",
                level: "=",
                deploymentId: "="
            },
            controller: [ "$scope", "$element", "$compile", "DiffService", DynamicPanelItemController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var CodeDetailDiffService = function(super$0) {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var SP$0 = Object.setPrototypeOf || function(o, p) {
            if (PRS$0) {
                o["__proto__"] = p;
            } else {
                DP$0(o, "__proto__", {
                    value: p,
                    configurable: true,
                    enumerable: false,
                    writable: true
                });
            }
            return o;
        };
        var OC$0 = Object.create;
        if (!PRS$0) MIXIN$0(CodeDetailDiffService, super$0);
        var proto$0 = {};
        function CodeDetailDiffService($sce) {
            super$0.call(this);
            this.$sce = $sce;
            this.__init();
        }
        if (super$0 !== null) SP$0(CodeDetailDiffService, super$0);
        CodeDetailDiffService.prototype = OC$0(super$0 !== null ? super$0.prototype : null, {
            constructor: {
                value: CodeDetailDiffService,
                configurable: true,
                writable: true
            }
        });
        DP$0(CodeDetailDiffService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0.__init = function() {
            this._colors = {
                added: "#2DAA46",
                removed: "#AA2D2D"
            };
            this._defaults = {
                codeValue: 1,
                comments: "",
                description: "",
                displayOrder: 0,
                shortName: ""
            };
        };
        proto$0._initDiff = function() {
            var ordered = [];
            var newP = {};
            for (var i in this._panels) {
                var data = angular.copy(this._panels[i].data);
                if (!angular.isDefined(data)) {
                    data = angular.copy(this._defaults);
                }
                for (var a in this._defaults) {
                    if (data[a] === null) {
                        data[a] = this._defaults[a];
                    }
                }
                ordered.push({
                    order: this._panels[i].order,
                    id: i,
                    data: data
                });
                newP[i] = {};
            }
            ordered = ordered.sort(function(a, b) {
                if (a.order > b.order) {
                    return 1;
                }
                if (a.order < b.order) {
                    return -1;
                }
                return 0;
            });
            newP = this._markDifferences(ordered);
            this._complete(newP);
        };
        proto$0._markDifferences = function(panels) {
            var newP = {};
            for (var i in panels) {
                newP[panels[i].id] = panels[i].data;
            }
            for (var i in panels) {
                var next = parseInt(parseInt(i) + 1);
                if (i === "0") {
                    for (var a in this._defaults) {
                        newP[panels[i].id]["__" + a] = panels[i].data[a];
                    }
                }
                if (typeof panels[next] !== "undefined") {
                    for (var a in this._defaults) {
                        if (typeof panels[i].data[a] === "string") {
                            var diff = JsDiff.diffWords(panels[i].data[a], panels[next].data[a]);
                            newP[panels[next].id]["__" + a] = this._realCompile(diff);
                        } else {
                            newP[panels[next].id]["__" + a] = panels[next].data[a];
                        }
                    }
                }
            }
            return newP;
        };
        proto$0._compileDiff = function(diff) {
            var str = "";
            for (var i in diff) {
                str += diff[i].value;
            }
            return str;
        };
        proto$0._realCompile = function(diff) {
            var str = "";
            for (var i in diff) {
                if (angular.isDefined(diff[i].added) && diff[i].added === true) {
                    str += "<ins>" + diff[i].value + "</ins>";
                    continue;
                }
                if (angular.isDefined(diff[i].removed) && diff[i].removed === true) {
                    str += "<del>" + diff[i].value + "</del>";
                    continue;
                }
                str += diff[i].value;
            }
            return this.$sce.trustAsHtml(str);
        };
        MIXIN$0(CodeDetailDiffService.prototype, proto$0);
        proto$0 = void 0;
        return CodeDetailDiffService;
    }(BaseDiff);
    app.service("CodeDetailDiffService", [ "$sce", CodeDetailDiffService ]);
})();

(function() {
    var app = angular.module("atUI");
    var CodeDiffService = function(super$0) {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var SP$0 = Object.setPrototypeOf || function(o, p) {
            if (PRS$0) {
                o["__proto__"] = p;
            } else {
                DP$0(o, "__proto__", {
                    value: p,
                    configurable: true,
                    enumerable: false,
                    writable: true
                });
            }
            return o;
        };
        var OC$0 = Object.create;
        if (!PRS$0) MIXIN$0(CodeDiffService, super$0);
        var proto$0 = {};
        function CodeDiffService() {
            super$0.call(this);
        }
        if (super$0 !== null) SP$0(CodeDiffService, super$0);
        CodeDiffService.prototype = OC$0(super$0 !== null ? super$0.prototype : null, {
            constructor: {
                value: CodeDiffService,
                configurable: true,
                writable: true
            }
        });
        DP$0(CodeDiffService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._getUniquePanels = function(panels) {
            var unique = [];
            for (var i in panels) {
                for (var ii in panels[i].data) {
                    unique.push(panels[i].data[ii]);
                }
            }
            return unique.reduce(function(p, c) {
                var found = false;
                for (var i in p) {
                    if (p[i].shortName === c.shortName) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    p.push(c);
                }
                return p;
            }, []);
        };
        proto$0._initDiff = function() {
            var newP = {};
            for (var i in this._panels) {
                newP[i] = [];
            }
            var panels = angular.copy(this._panels);
            var unique = this._getUniquePanels(panels);
            for (var i$0 in panels) {
                for (var a in unique) {
                    var found = false;
                    for (var ii in panels[i$0].data) {
                        if (unique[a].shortName === panels[i$0].data[ii].shortName) {
                            found = panels[i$0].data[ii];
                            break;
                        }
                    }
                    if (found !== false) {
                        newP[i$0].push(found);
                    } else {
                        var newItem = angular.copy(unique[a]);
                        newItem.__MISSING = true;
                        newP[i$0].push(newItem);
                    }
                }
            }
            this._complete(newP);
        };
        MIXIN$0(CodeDiffService.prototype, proto$0);
        proto$0 = void 0;
        return CodeDiffService;
    }(BaseDiff);
    app.service("CodeDiffService", [ CodeDiffService ]);
})();

(function() {
    var app = angular.module("atUI");
    var DiffGroupCodeItemController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DiffGroupCodeItemController($scope, $element, CodeDiffService, APIService, $compile) {
            this.$scope = $scope;
            this.$element = $element;
            this.CodeDiffService = CodeDiffService;
            this.APIService = APIService;
            this.$compile = $compile;
            this._init();
        }
        DP$0(DiffGroupCodeItemController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.item.index = this.$scope.item.name;
            this.$scope.codes = null;
            this.$scope.exploded = false;
            if (!this.$scope.item.hasOwnProperty("__MISSING")) {
                this.$scope.$on("mouseover-code-group-" + this.$scope.item.name, function() {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner").addClass("over");
                    } else {
                        self.$element.find(".diff-item-inner").removeClass("over");
                    }
                });
                this.$scope.$on("mouseleave-code-group-" + this.$scope.item.name, function() {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner").removeClass("over");
                    }
                });
            }
            this.$scope.openCodes = function() {
                if (self.$scope.exploded === false) {
                    self.$scope.$emit("open-diff-item", self.$scope.item);
                }
            };
            this.$scope.$on("open-code-group-" + this.$scope.item.index, function() {
                self.openCodes();
            });
            this.$scope.$on("$destroy", function() {
                self.CodeDiffService.onDestroy();
            });
        };
        proto$0.openCodes = function() {
            var self = this;
            this.CodeDiffService.addPanel(this.$scope.deploymentID);
            this.CodeDiffService.onComplete(this.$scope.deploymentID, function(codes) {
                self.$scope.codes = codes;
                self._render();
            });
            this.APIService.get("code/name/" + this.$scope.item.name + "/p/" + this.$scope.deploymentID).success(function(codes) {
                self.CodeDiffService.setData(self.$scope.deploymentID, codes);
                self.$scope.exploded = true;
            });
        };
        proto$0._render = function() {
            var $panel = this.$element.find(".codes-panel:first");
            var dom = "<div diff-code-item></div>";
            for (var i in this.$scope.codes) {
                var newScope = this.$scope.$new();
                newScope.item = this.$scope.codes[i];
                newScope.deploymentID = this.$scope.deploymentID;
                var $dom = this.$compile(dom)(newScope);
                $panel.append($dom);
            }
        };
        MIXIN$0(DiffGroupCodeItemController.prototype, proto$0);
        proto$0 = void 0;
        return DiffGroupCodeItemController;
    }();
    app.directive("diffCodeGroupItem", [ function() {
        return {
            templateUrl: "assets/templates/apps/data/deploymentcompare/items/codegroup/diffGroupCodeItem.html",
            controller: [ "$scope", "$element", "CodeDiffService", "APIService", "$compile", DiffGroupCodeItemController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var DiffCodeItemController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DiffCodeItemController($scope, $element, CodeDetailDiffService, CodesService) {
            this.$scope = $scope;
            this.$element = $element;
            this.CodeDetailDiffService = CodeDetailDiffService;
            this.CodesService = CodesService;
            this._init();
        }
        DP$0(DiffCodeItemController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.exploded = false;
            this.$scope.item.index = this.$scope.item.shortName;
            this.$scope.details = null;
            this.$scope.parent = null;
            this.$scope.item.__LEVEL = "code";
            if (this.$scope.item.parentID === 0) {
                this.$scope.parent = {
                    shortName: "",
                    groupingName: "NONE"
                };
            } else {
                this.CodesService.findById(this.$scope.item.parentID, function(parent) {
                    self.$scope.parent = parent;
                });
            }
            if (!this.$scope.item.hasOwnProperty("__MISSING")) {
                this.$scope.$on("mouseover-code-" + this.$scope.item.index, function() {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner").addClass("over");
                    } else {
                        self.$element.find(".diff-item-inner").removeClass("over");
                    }
                });
                this.$scope.$on("mouseleave-code-" + this.$scope.item.index, function() {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner").removeClass("over");
                    }
                });
            }
            this.$scope.openCode = function() {
                if (self.$scope.exploded === false) {
                    self.$scope.$emit("open-diff-item", self.$scope.item);
                }
            };
            this.$scope.$on("open-code-" + this.$scope.item.index, function() {
                self.openCode();
            });
            this.$scope.$on("$destroy", function() {
                self.CodeDetailDiffService.onDestroy();
            });
        };
        proto$0.openCode = function() {
            var self = this;
            this.CodeDetailDiffService.addPanel(this.$scope.deploymentID);
            this.CodeDetailDiffService.onComplete(this.$scope.deploymentID, function(details) {
                self.$scope.details = details;
                self.$scope.exploded = true;
            });
            this.CodeDetailDiffService.setData(this.$scope.deploymentID, this.$scope.item);
        };
        MIXIN$0(DiffCodeItemController.prototype, proto$0);
        proto$0 = void 0;
        return DiffCodeItemController;
    }();
    app.directive("diffCodeItem", [ function() {
        return {
            templateUrl: "assets/templates/apps/data/deploymentcompare/items/codegroup/code/diffCodeItem.html",
            controller: [ "$scope", "$element", "CodeDetailDiffService", "CodesService", DiffCodeItemController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var DiffFieldItemController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DiffFieldItemController($scope, $element, FieldDetailDiffService) {
            this.$scope = $scope;
            this.$element = $element;
            this.FieldDetailDiffService = FieldDetailDiffService;
            this._init();
        }
        DP$0(DiffFieldItemController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.exploded = false;
            this.$scope.details = null;
            this.$scope.item.index = "";
            this.$scope.item.__LEVEL = "field";
            if (this.$scope.item.hasOwnProperty("layoutName")) {
                this.$scope.item.index = this.$scope.item.layoutName + "-";
            }
            this.$scope.item.index += this.$scope.item.segmentName + "-" + this.$scope.item.fieldNumber;
            if (!this.$scope.item.hasOwnProperty("__MISSING")) {
                this.$scope.$on("mouseover-field-" + this.$scope.item.index, function(e) {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner:first").addClass("over");
                    } else {
                        self.$element.find(".diff-item-inner:first").removeClass("over");
                    }
                    e.preventDefault();
                });
                this.$scope.$on("mouseleave-field-" + this.$scope.item.index, function(e) {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner:first").removeClass("over");
                    }
                    e.preventDefault();
                });
            }
            this.$scope.$on("open-field-" + this.$scope.item.index, function(e) {
                if (self.$scope.exploded === false) {
                    self.openField();
                }
            });
            this.$scope.openField = function() {
                self.$scope.item.__LEVEL = "field";
                self.$scope.$emit("open-diff-item", self.$scope.item);
            };
            this.$scope.$on("$destroy", function() {
                self.FieldDetailDiffService.onDestroy();
            });
        };
        proto$0.openField = function() {
            var self = this;
            this.FieldDetailDiffService.addPanel(this.$scope.deploymentID);
            this.FieldDetailDiffService.onComplete(this.$scope.deploymentID, function(details) {
                self.$scope.details = details;
                self.$scope.exploded = true;
            });
            this.FieldDetailDiffService.setData(this.$scope.deploymentID, this.$scope.item);
        };
        MIXIN$0(DiffFieldItemController.prototype, proto$0);
        proto$0 = void 0;
        return DiffFieldItemController;
    }();
    app.directive("diffFieldItem", [ function() {
        return {
            templateUrl: "assets/templates/apps/data/deploymentcompare/items/fields/diffFieldItem.html",
            controller: [ "$scope", "$element", "FieldDetailDiffService", DiffFieldItemController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var FieldDetailDiffService = function(super$0) {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var SP$0 = Object.setPrototypeOf || function(o, p) {
            if (PRS$0) {
                o["__proto__"] = p;
            } else {
                DP$0(o, "__proto__", {
                    value: p,
                    configurable: true,
                    enumerable: false,
                    writable: true
                });
            }
            return o;
        };
        var OC$0 = Object.create;
        if (!PRS$0) MIXIN$0(FieldDetailDiffService, super$0);
        var proto$0 = {};
        function FieldDetailDiffService($sce) {
            super$0.call(this);
            this.$sce = $sce;
            this.__init();
        }
        if (super$0 !== null) SP$0(FieldDetailDiffService, super$0);
        FieldDetailDiffService.prototype = OC$0(super$0 !== null ? super$0.prototype : null, {
            constructor: {
                value: FieldDetailDiffService,
                configurable: true,
                writable: true
            }
        });
        DP$0(FieldDetailDiffService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0.__init = function() {
            this._colors = {
                added: "#2DAA46",
                removed: "#AA2D2D"
            };
            this._defaults = {
                codeTableName: "",
                dataTypeName: "",
                description: "",
                fieldNumber: 0,
                length: 0,
                name: ""
            };
        };
        proto$0._initDiff = function() {
            var ordered = [];
            var newP = {};
            for (var i in this._panels) {
                var data = angular.copy(this._panels[i].data);
                if (!angular.isDefined(data)) {
                    data = angular.copy(this._defaults);
                }
                for (var a in this._defaults) {
                    if (data[a] === null) {
                        data[a] = this._defaults[a];
                    }
                }
                ordered.push({
                    order: this._panels[i].order,
                    id: i,
                    data: data
                });
                newP[i] = {};
            }
            ordered = ordered.sort(function(a, b) {
                if (a.order > b.order) {
                    return 1;
                }
                if (a.order < b.order) {
                    return -1;
                }
                return 0;
            });
            newP = this._markDifferences(ordered);
            this._complete(newP);
        };
        proto$0._markDifferences = function(panels) {
            var newP = {};
            for (var i in panels) {
                newP[panels[i].id] = panels[i].data;
            }
            for (var i in panels) {
                var next = parseInt(parseInt(i) + 1);
                if (i === "0") {
                    for (var a in this._defaults) {
                        newP[panels[i].id]["__" + a] = panels[i].data[a];
                    }
                }
                if (typeof panels[next] !== "undefined") {
                    for (var a in this._defaults) {
                        if (typeof panels[i].data[a] === "string") {
                            var diff = JsDiff.diffWords(panels[i].data[a], panels[next].data[a]);
                            newP[panels[next].id]["__" + a] = this._realCompile(diff);
                        } else {
                            newP[panels[next].id]["__" + a] = panels[next].data[a];
                        }
                    }
                }
            }
            return newP;
        };
        proto$0._compileDiff = function(diff) {
            var str = "";
            for (var i in diff) {
                str += diff[i].value;
            }
            return str;
        };
        proto$0._realCompile = function(diff) {
            var str = "";
            for (var i in diff) {
                if (angular.isDefined(diff[i].added) && diff[i].added === true) {
                    str += "<ins>" + diff[i].value + "</ins>";
                    continue;
                }
                if (angular.isDefined(diff[i].removed) && diff[i].removed === true) {
                    str += "<del>" + diff[i].value + "</del>";
                    continue;
                }
                str += diff[i].value;
            }
            return this.$sce.trustAsHtml(str);
        };
        MIXIN$0(FieldDetailDiffService.prototype, proto$0);
        proto$0 = void 0;
        return FieldDetailDiffService;
    }(BaseDiff);
    app.service("FieldDetailDiffService", [ "$sce", FieldDetailDiffService ]);
})();

(function() {
    var app = angular.module("atUI");
    var FieldDiffService = function(super$0) {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var SP$0 = Object.setPrototypeOf || function(o, p) {
            if (PRS$0) {
                o["__proto__"] = p;
            } else {
                DP$0(o, "__proto__", {
                    value: p,
                    configurable: true,
                    enumerable: false,
                    writable: true
                });
            }
            return o;
        };
        var OC$0 = Object.create;
        if (!PRS$0) MIXIN$0(FieldDiffService, super$0);
        var proto$0 = {};
        function FieldDiffService() {
            super$0.call(this);
        }
        if (super$0 !== null) SP$0(FieldDiffService, super$0);
        FieldDiffService.prototype = OC$0(super$0 !== null ? super$0.prototype : null, {
            constructor: {
                value: FieldDiffService,
                configurable: true,
                writable: true
            }
        });
        DP$0(FieldDiffService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._getUniquePanels = function(panels) {
            var unique = [];
            for (var i in panels) {
                for (var ii in panels[i].data) {
                    unique.push(panels[i].data[ii]);
                }
            }
            return unique.reduce(function(p, c) {
                var found = false;
                for (var i in p) {
                    if (p[i].name === c.name) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    p.push(c);
                }
                return p;
            }, []);
        };
        proto$0._findMissing = function(panels, unique, newP) {
            for (var i in panels) {
                for (var a in unique) {
                    var found = false;
                    for (var ii in panels[i].data) {
                        if (unique[a].name === panels[i].data[ii].name) {
                            found = panels[i].data[ii];
                            break;
                        }
                    }
                    if (found !== false) {
                        newP[i].push(found);
                    } else {
                        var newItem = angular.copy(unique[a]);
                        newItem.__MISSING = true;
                        newP[i].push(newItem);
                    }
                }
            }
            return newP;
        };
        proto$0._initDiff = function() {
            var newP = {};
            for (var i in this._panels) {
                newP[i] = [];
            }
            var panels = angular.copy(this._panels);
            var unique = this._getUniquePanels(panels);
            newP = this._findMissing(panels, unique, newP);
            this._complete(newP);
        };
        MIXIN$0(FieldDiffService.prototype, proto$0);
        proto$0 = void 0;
        return FieldDiffService;
    }(BaseDiff);
    app.service("FieldDiffService", [ FieldDiffService ]);
})();

(function() {
    var app = angular.module("atUI");
    var DiffLayoutItemController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DiffLayoutItemController($scope, $element, $compile, DeploymentLevelPathService, APIService, SegmentTreeDiffService) {
            this.$scope = $scope;
            this.$element = $element;
            this.$compile = $compile;
            this.DeploymentLevelPathService = DeploymentLevelPathService;
            this.APIService = APIService;
            this.SegmentTreeDiffService = SegmentTreeDiffService;
            this._init();
        }
        DP$0(DiffLayoutItemController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.layout = null;
            this.$scope.segments = null;
            this.$scope.exploded = false;
            if (!this.$scope.item.hasOwnProperty("__MISSING")) {
                this.$scope.$on("mouseover-layout-" + this.$scope.item.name, function() {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner").addClass("over");
                    } else {
                        self.$element.find(".diff-item-inner").removeClass("over");
                    }
                });
                this.$scope.$on("mouseleave-layout-" + this.$scope.item.name, function() {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner").removeClass("over");
                    }
                });
            }
            this.$scope.openSegments = function() {
                if (self.$scope.exploded === false) {
                    self.$scope.$emit("open-diff-item", self.$scope.item);
                }
            };
            this.$scope.$on("open-layout-" + this.$scope.item.name, function() {
                self.openSegments();
            });
            this.$scope.$on("$destroy", function() {
                self.SegmentTreeDiffService.onDestroy();
            });
        };
        proto$0.openSegments = function() {
            var self = this;
            this.SegmentTreeDiffService.addPanel(this.$scope.deploymentID);
            this.SegmentTreeDiffService.onComplete(this.$scope.deploymentID, function(segments) {
                self.$scope.segments = segments;
                self._injectLayoutName(self.$scope.segments);
                self._render();
            });
            this.APIService.get("layout/latest/" + this.$scope.item.id + "/p/" + this.$scope.deploymentID).success(function(layout) {
                self.$scope.layout = layout;
                if (self.$scope.layout === null) {
                    self.SegmentTreeDiffService.setData(self.$scope.deploymentID, []);
                    self.$scope.layout = {
                        description: "MISSING"
                    };
                    self.$scope.exploded = true;
                } else {
                    self.APIService.get("layout/segments/" + self.$scope.layout.id).success(function(segments) {
                        self.SegmentTreeDiffService.setData(self.$scope.deploymentID, segments);
                        self.$scope.exploded = true;
                    });
                }
            });
        };
        proto$0._injectLayoutName = function(segment) {
            segment.layoutName = this.$scope.item.name;
            if (segment.children.length > 0) {
                for (var i in segment.children) {
                    this._injectLayoutName(segment.children[i]);
                }
            }
        };
        proto$0._render = function() {
            var dom = "<div diff-layout-segment-item></div>";
            var newScope = this.$scope.$new();
            newScope.item = this.$scope.segments;
            newScope.deploymentID = this.$scope.deploymentID;
            var $dom = this.$compile(dom)(newScope);
            this.$element.find(".segments-panel").append($dom);
        };
        MIXIN$0(DiffLayoutItemController.prototype, proto$0);
        proto$0 = void 0;
        return DiffLayoutItemController;
    }();
    app.directive("diffLayoutItem", [ function() {
        return {
            templateUrl: "assets/templates/apps/data/deploymentcompare/items/layout/diffLayoutItem.html",
            controller: [ "$scope", "$element", "$compile", "DeploymentLevelPathService", "APIService", "SegmentTreeDiffService", DiffLayoutItemController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var SegmentTreeDiffService = function(super$0) {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var SP$0 = Object.setPrototypeOf || function(o, p) {
            if (PRS$0) {
                o["__proto__"] = p;
            } else {
                DP$0(o, "__proto__", {
                    value: p,
                    configurable: true,
                    enumerable: false,
                    writable: true
                });
            }
            return o;
        };
        var OC$0 = Object.create;
        if (!PRS$0) MIXIN$0(SegmentTreeDiffService, super$0);
        var proto$0 = {};
        function SegmentTreeDiffService(RecordLayoutUtilityService) {
            super$0.call(this);
            this.RecordLayoutUtilityService = RecordLayoutUtilityService;
            this.index = 0;
        }
        if (super$0 !== null) SP$0(SegmentTreeDiffService, super$0);
        SegmentTreeDiffService.prototype = OC$0(super$0 !== null ? super$0.prototype : null, {
            constructor: {
                value: SegmentTreeDiffService,
                configurable: true,
                writable: true
            }
        });
        DP$0(SegmentTreeDiffService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._initDiff = function() {
            var newP = {};
            var trees = {};
            for (var i in this._panels) {
                newP[i] = [];
            }
            var panels = angular.copy(this._panels);
            for (var i$0 in panels) {
                if (panels[i$0].data.length > 0) {
                    trees[i$0] = this.RecordLayoutUtilityService._initLayout(panels[i$0].data);
                } else {
                    trees[i$0] = {
                        children: [],
                        __MISSING: true
                    };
                }
            }
            var mergedTree = this._mergeTrees(trees);
            trees = this._markMissing(trees, mergedTree);
            this._complete(trees);
        };
        proto$0._markMissing = function(trees, mergedTree) {
            var newTrees = {};
            for (var i in trees) {
                newTrees[i] = angular.copy(mergedTree);
                newTrees[i] = this._markBranchMissing(newTrees[i], trees[i]);
            }
            return newTrees;
        };
        proto$0._markBranchMissing = function(mainBranch, checkBranch) {
            if (checkBranch.hasOwnProperty("__MISSING")) {
                mainBranch.__MISSING = true;
            }
            for (var ii in mainBranch.children) {
                var check = mainBranch.children[ii];
                var found = false;
                for (var iii in checkBranch.children) {
                    if (check.name === checkBranch.children[iii].name) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    mainBranch.children[ii].__MISSING = true;
                }
                if (mainBranch.children[ii].children.length > 0 && checkBranch.children[ii] !== undefined) {
                    mainBranch.children[ii] = this._markBranchMissing(mainBranch.children[ii], checkBranch.children[ii]);
                }
            }
            return mainBranch;
        };
        proto$0._markWithindex = function() {
            var m = this.index;
            this.index++;
            return m;
        };
        proto$0._mergeTrees = function(trees) {
            var merged = {
                name: "DRC",
                version: 0,
                latest: true,
                children: [],
                index: this._markWithindex(),
                __LEVEL: "layout-segment"
            };
            for (var i in trees) {
                merged = this._merge(merged, trees[i]);
            }
            return merged;
        };
        proto$0._merge = function(target, src) {
            for (var i in src.children) {
                var found = false;
                for (var ii in target.children) {
                    if (target.children[ii].name === src.children[i].name) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    var n = {
                        name: src.children[i].name,
                        version: src.children[i].version,
                        latest: src.children[i].latest,
                        children: [],
                        index: this._markWithindex(),
                        __LEVEL: "layout-segment"
                    };
                    target.children.push(n);
                    if (src.children[i].children.length > 0) {
                        target.children[target.children.length - 1] = this._merge(target.children[target.children.length - 1], src.children[i]);
                    }
                }
            }
            return target;
        };
        MIXIN$0(SegmentTreeDiffService.prototype, proto$0);
        proto$0 = void 0;
        return SegmentTreeDiffService;
    }(BaseDiff);
    app.service("SegmentTreeDiffService", [ "RecordLayoutUtilityService", SegmentTreeDiffService ]);
})();

(function() {
    var app = angular.module("atUI");
    var DiffLayoutSegmentItemController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DiffLayoutSegmentItemController($scope, $element, FieldDiffService, APIService, $compile, SegmentDetailsDiffService) {
            this.$scope = $scope;
            this.$element = $element;
            this.FieldDiffService = FieldDiffService;
            this.APIService = APIService;
            this.$compile = $compile;
            this.SegmentDetailsDiffService = SegmentDetailsDiffService;
            this._init();
        }
        DP$0(DiffLayoutSegmentItemController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.exploded = false;
            this.$scope.fields = null;
            this.$scope.segment = null;
            if (!this.$scope.item.hasOwnProperty("__MISSING")) {
                this.$scope.$on("mouseover-layout-segment-" + this.$scope.item.index, function(e) {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner:first").addClass("over");
                    } else {
                        self.$element.find(".diff-item-inner:first").removeClass("over");
                    }
                    e.preventDefault();
                });
                this.$scope.$on("mouseleave-layout-segment-" + this.$scope.item.index, function(e) {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner:first").removeClass("over");
                    }
                    e.preventDefault();
                });
            }
            this.$scope.$on("open-layout-segment-" + this.$scope.item.index, function(e) {
                if (self.$scope.exploded === false) {
                    self.openSegment();
                }
            });
            this.$scope.openSegment = function() {
                self.$scope.$emit("open-diff-item", self.$scope.item);
            };
            this.$scope.$on("$destroy", function() {
                self.SegmentDetailsDiffService.onDestroy();
            });
        };
        proto$0.openSegment = function() {
            var self = this;
            this.FieldDiffService.addPanel(this.$scope.deploymentID);
            this.SegmentDetailsDiffService.addPanel(this.$scope.deploymentID);
            this.FieldDiffService.onComplete(this.$scope.deploymentID, function(fields) {
                self.$scope.fields = fields.map(function(f) {
                    f.layoutName = self.$scope.item.layoutName;
                    return f;
                });
                self._render();
            });
            this.SegmentDetailsDiffService.onComplete(this.$scope.deploymentID, function(segment) {
                self.$scope.segment = segment;
            });
            this.APIService.get("segment/latest/" + this.$scope.item.name + "/p/" + this.$scope.deploymentID, {
                raw: true
            }).success(function(data) {
                self.SegmentDetailsDiffService.setData(self.$scope.deploymentID, data[0]);
                self.FieldDiffService.setData(self.$scope.deploymentID, data[3]);
                self.$scope.exploded = true;
            });
        };
        proto$0._render = function() {
            var $panel = this.$element.find(".fields-panel:first");
            var dom = "<div diff-field-item></div>";
            for (var i in this.$scope.fields) {
                var newScope = this.$scope.$new();
                newScope.item = this.$scope.fields[i];
                newScope.deploymentID = this.$scope.deploymentID;
                var $dom = this.$compile(dom)(newScope);
                $panel.append($dom);
            }
        };
        MIXIN$0(DiffLayoutSegmentItemController.prototype, proto$0);
        proto$0 = void 0;
        return DiffLayoutSegmentItemController;
    }();
    app.directive("diffLayoutSegmentItem", [ "$compile", function($compile) {
        return {
            templateUrl: "assets/templates/apps/data/deploymentcompare/items/layout/segment/diffLayoutSegmentItem.html",
            controller: [ "$scope", "$element", "FieldDiffService", "APIService", "$compile", "SegmentDetailsDiffService", DiffLayoutSegmentItemController ],
            link: function(scope, element) {
                this._render = function(item) {
                    var dom = "<div diff-layout-segment-item></div>";
                    var newScope = scope.$new();
                    newScope.item = item;
                    newScope.deploymentID = scope.deploymentID;
                    if (newScope.item.hasOwnProperty("__MISSING")) {
                        for (var i in newScope.item.children) {
                            newScope.item.children[i].__MISSING = true;
                        }
                    }
                    var $dom = $compile(dom)(newScope);
                    element.find(".children").append($dom);
                };
                if (scope.item.children.length > 0) {
                    for (var i in scope.item.children) {
                        this._render(scope.item.children[i]);
                    }
                }
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var SegmentDetailsDiffService = function(super$0) {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var SP$0 = Object.setPrototypeOf || function(o, p) {
            if (PRS$0) {
                o["__proto__"] = p;
            } else {
                DP$0(o, "__proto__", {
                    value: p,
                    configurable: true,
                    enumerable: false,
                    writable: true
                });
            }
            return o;
        };
        var OC$0 = Object.create;
        if (!PRS$0) MIXIN$0(SegmentDetailsDiffService, super$0);
        var proto$0 = {};
        function SegmentDetailsDiffService($sce) {
            super$0.call(this);
            this.$sce = $sce;
            this.__init();
        }
        if (super$0 !== null) SP$0(SegmentDetailsDiffService, super$0);
        SegmentDetailsDiffService.prototype = OC$0(super$0 !== null ? super$0.prototype : null, {
            constructor: {
                value: SegmentDetailsDiffService,
                configurable: true,
                writable: true
            }
        });
        DP$0(SegmentDetailsDiffService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0.__init = function() {
            this._colors = {
                added: "#2DAA46",
                removed: "#AA2D2D"
            };
        };
        proto$0._initDiff = function() {
            var ordered = [];
            var newP = {};
            for (var i in this._panels) {
                var data = angular.copy(this._panels[i].data);
                if (!angular.isDefined(data)) {
                    data = {
                        description: "",
                        shortDescription: ""
                    };
                }
                if (data.description === null) {
                    data.description = "";
                }
                if (data.shortDescription === null) {
                    data.shortDescription = "";
                }
                ordered.push({
                    order: this._panels[i].order,
                    id: i,
                    data: data
                });
                newP[i] = {};
            }
            ordered = ordered.sort(function(a, b) {
                if (a.order > b.order) {
                    return 1;
                }
                if (a.order < b.order) {
                    return -1;
                }
                return 0;
            });
            newP = this._markDifferences(ordered);
            this._complete(newP);
        };
        proto$0._markDifferences = function(panels) {
            var newP = {};
            for (var i in panels) {
                newP[panels[i].id] = panels[i].data;
            }
            for (var i in panels) {
                var next = parseInt(parseInt(i) + 1);
                if (i === "0") {
                    newP[panels[i].id].__description = panels[i].data.description;
                    newP[panels[i].id].__shortDescription = panels[i].data.shortDescription;
                }
                if (typeof panels[next] !== "undefined") {
                    var diff = JsDiff.diffWords(panels[i].data.description, panels[next].data.description);
                    newP[panels[next].id].__description = this._realCompile(diff);
                    diff = JsDiff.diffWords(panels[i].data.shortDescription, panels[next].data.shortDescription);
                    newP[panels[next].id].__shortDescription = this._realCompile(diff);
                }
            }
            return newP;
        };
        proto$0._compileDiff = function(diff) {
            var str = "";
            for (var i in diff) {
                str += diff[i].value;
            }
            return str;
        };
        proto$0._realCompile = function(diff) {
            var str = "";
            for (var i in diff) {
                if (angular.isDefined(diff[i].added) && diff[i].added === true) {
                    str += "<ins>" + diff[i].value + "</ins>";
                    continue;
                }
                if (angular.isDefined(diff[i].removed) && diff[i].removed === true) {
                    str += "<del>" + diff[i].value + "</del>";
                    continue;
                }
                str += diff[i].value;
            }
            return this.$sce.trustAsHtml(str);
        };
        MIXIN$0(SegmentDetailsDiffService.prototype, proto$0);
        proto$0 = void 0;
        return SegmentDetailsDiffService;
    }(BaseDiff);
    app.service("SegmentDetailsDiffService", [ "$sce", SegmentDetailsDiffService ]);
})();

(function() {
    var app = angular.module("atUI");
    var DiffSegmentItemController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DiffSegmentItemController($scope, $element, FieldDiffService, SegmentDetailsDiffService, APIService, $compile) {
            this.$scope = $scope;
            this.$element = $element;
            this.FieldDiffService = FieldDiffService;
            this.SegmentDetailsDiffService = SegmentDetailsDiffService;
            this.APIService = APIService;
            this.$compile = $compile;
            this._init();
        }
        DP$0(DiffSegmentItemController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.exploded = false;
            this.$scope.fields = null;
            this.$scope.segment = null;
            if (!this.$scope.item.hasOwnProperty("__MISSING")) {
                this.$scope.$on("mouseover-segment-" + this.$scope.item.index, function(e) {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner:first").addClass("over");
                    } else {
                        self.$element.find(".diff-item-inner:first").removeClass("over");
                    }
                    e.preventDefault();
                });
                this.$scope.$on("mouseleave-segment-" + this.$scope.item.index, function(e) {
                    if (!self.$scope.exploded) {
                        self.$element.find(".diff-item-inner:first").removeClass("over");
                    }
                    e.preventDefault();
                });
            }
            this.$scope.$on("open-segment-" + this.$scope.item.index, function(e) {
                self.openSegment();
            });
            this.$scope.openSegment = function() {
                self.$scope.$emit("open-diff-item", self.$scope.item);
            };
            this.$scope.$on("$destroy", function() {
                self.SegmentDetailsDiffService.onDestroy();
                self.FieldDiffService.onDestroy();
            });
        };
        proto$0.openSegment = function() {
            var self = this;
            this.FieldDiffService.addPanel(this.$scope.deploymentID);
            this.SegmentDetailsDiffService.addPanel(this.$scope.deploymentID);
            this.FieldDiffService.onComplete(this.$scope.deploymentID, function(fields) {
                self.$scope.fields = fields;
                self._render();
            });
            this.SegmentDetailsDiffService.onComplete(this.$scope.deploymentID, function(segment) {
                self.$scope.segment = segment;
            });
            this.APIService.get("segment/latest/" + this.$scope.item.name + "/p/" + this.$scope.deploymentID, {
                raw: true
            }).success(function(data) {
                self.SegmentDetailsDiffService.setData(self.$scope.deploymentID, data[0]);
                self.FieldDiffService.setData(self.$scope.deploymentID, data[3]);
                self.$scope.exploded = true;
            });
        };
        proto$0._render = function() {
            var $panel = this.$element.find(".fields-panel:first");
            var dom = "<div diff-field-item></div>";
            for (var i in this.$scope.fields) {
                var newScope = this.$scope.$new();
                newScope.item = this.$scope.fields[i];
                newScope.deploymentID = this.$scope.deploymentID;
                var $dom = this.$compile(dom)(newScope);
                $panel.append($dom);
            }
        };
        MIXIN$0(DiffSegmentItemController.prototype, proto$0);
        proto$0 = void 0;
        return DiffSegmentItemController;
    }();
    app.directive("diffSegmentItem", [ function() {
        return {
            templateUrl: "assets/templates/apps/data/deploymentcompare/items/segment/diffSegmentItem.html",
            controller: [ "$scope", "$element", "FieldDiffService", "SegmentDetailsDiffService", "APIService", "$compile", DiffSegmentItemController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var DeploymentsController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DeploymentsController($scope, PlatformService, NotificationQueue, AlertMessageService, StoreService) {
            this.PlatformService = PlatformService;
            this.$scope = $scope;
            this.NotificationQueue = NotificationQueue;
            this.AlertMessageService = AlertMessageService;
            this.StoreService = StoreService;
            this._setupScope();
            this._init();
        }
        DP$0(DeploymentsController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._setupScope = function() {
            var self = this;
            this._baseDeployment = {
                name: "",
                version: 10,
                createDate: "",
                createUserID: 0
            };
            this._resetNewDeployment();
            this.$scope.cleanCreate = function() {
                self.cleanCreate();
            };
            this.$scope.cloneBasedOnThis = function(deployment) {
                self.cloneBasedOnThis(deployment);
            };
            this.$scope.onClone = function(deployment) {
                self.onClone(deployment);
            };
            this.$scope.onDelete = function(deployment) {
                self.onDelete(deployment);
            };
            this.$scope._cloneIntent = null;
        };
        proto$0._init = function() {
            this._refreshPlatforms();
            this.StoreService.leftOffHere("Deployments");
        };
        proto$0._refreshPlatforms = function() {
            var self = this;
            this.PlatformService.fetchPlatforms(function() {
                self.$scope.deployments = self.PlatformService.getPlatforms();
            });
        };
        proto$0._resetNewDeployment = function() {
            this.$scope.newDeployment = angular.copy(this._baseDeployment);
        };
        proto$0.onClone = function(deployment) {
            this.$scope._cloneIntent = deployment;
            $("#clone-deployment-modal").modal();
        };
        proto$0.onDelete = function(deployment) {
            var self = this;
            this.AlertMessageService.showQuestion("Hold on!", "Deleting this Deployment will also delete ALL associated data. Continue?", [ {
                "class": "btn-danger",
                action: function() {
                    self.deleteDeployment(deployment);
                },
                label: "DELETE",
                dismiss: true
            }, {
                "class": "btn-default",
                label: "Cancel",
                dismiss: true
            } ]);
        };
        proto$0.deleteDeployment = function(deployment) {
            var self = this;
            this.PlatformService.deletePlatform(deployment, function() {
                self._refreshPlatforms();
                self.NotificationQueue.push({
                    icon: "thumbs-o-up",
                    text: "Successfully delete Deployment!"
                });
            });
        };
        proto$0.cleanCreate = function() {
            var self = this;
            this.PlatformService.cleanCreate(this.$scope.newDeployment, function() {
                self._refreshPlatforms();
                self.NotificationQueue.push({
                    icon: "thumbs-o-up",
                    text: "Successfully created a new Deployment!"
                });
                self._resetNewDeployment();
            });
        };
        proto$0.cloneBasedOnThis = function(deployment) {
            var self = this;
            this.PlatformService.cloneBasedOnThis(this.$scope.newDeployment, deployment, function() {
                self._refreshPlatforms();
                self.NotificationQueue.push({
                    icon: "thumbs-o-up",
                    text: "Successfully cloned new Deployment!"
                });
                self._resetNewDeployment();
            });
        };
        MIXIN$0(DeploymentsController.prototype, proto$0);
        proto$0 = void 0;
        return DeploymentsController;
    }();
    app.controller("DeploymentsController", [ "$scope", "PlatformService", "NotificationQueue", "AlertMessageService", "StoreService", DeploymentsController ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("CodeTableStateService", [ function(super$0) {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var SP$0 = Object.setPrototypeOf || function(o, p) {
            if (PRS$0) {
                o["__proto__"] = p;
            } else {
                DP$0(o, "__proto__", {
                    value: p,
                    configurable: true,
                    enumerable: false,
                    writable: true
                });
            }
            return o;
        };
        var OC$0 = Object.create;
        if (!PRS$0) MIXIN$0(CodeTableStateService, super$0);
        function CodeTableStateService() {
            super$0.call(this);
            this.dirty = false;
            this.register("state");
        }
        if (super$0 !== null) SP$0(CodeTableStateService, super$0);
        CodeTableStateService.prototype = OC$0(super$0 !== null ? super$0.prototype : null, {
            constructor: {
                value: CodeTableStateService,
                configurable: true,
                writable: true
            },
            state: {
                get: $state_get$0,
                set: $state_set$0,
                configurable: true,
                enumerable: true
            }
        });
        DP$0(CodeTableStateService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        function $state_set$0(dirty) {
            var _old = this.dirty;
            this.dirty = dirty;
            this.notify("state", _old, this.dirty);
        }
        function $state_get$0() {
            return this.dirty;
        }
        return CodeTableStateService;
    }(Observer) ]);
    app.controller("CodeTableManagementController", [ "$scope", "CodesService", "UserService", "AlertMessageService", "CodeTableStateService", "NotificationQueue", "PlatformService", "hotkeys", function($scope, CodesService, UserService, AlertMessageService, CodeTableStateService, NotificationQueue, PlatformService, hotkeys) {
        $scope.codes = [];
        $scope.deletedCodes = [];
        $scope.modalCodes = [];
        $scope.dirty = false;
        $scope.newGroupingName = "";
        $scope.trashMode = false;
        hotkeys.add({
            combo: "alt+a",
            description: "Add new code",
            callback: function() {
                $scope.addNewCode();
            }
        });
        $scope.toggleTrashMode = function() {
            $scope.trashMode = !$scope.trashMode;
        };
        CodeTableStateService.watch("state", function(oldValue, newValue) {
            $scope.dirty = newValue;
        });
        var newCodeTemplate = {
            groupingName: "",
            codeValue: null,
            shortName: null,
            description: null,
            comments: null,
            parentID: 0,
            displayOrder: 0,
            createdBy: null,
            createdTimestamp: null,
            updatedBy: null,
            updatedTimestamp: null,
            lockedIndicator: "NOT LOCKED",
            changed: true,
            platformID: null
        };
        $scope.deleteMe = function(code) {
            for (var i in $scope.codes) {
                if ($scope.codes[i].codeID === code.codeID) {
                    var d = $scope.codes.splice(i, 1);
                    $scope.deletedCodes.push(d[0]);
                    CodeTableStateService.state = true;
                    return;
                }
            }
        };
        $scope.clearCodes = function() {
            $scope.codes = [];
            $scope.deletedCodes = [];
        };
        $scope.addNewCode = function() {
            UserService.getUserInfo(function(user) {
                var tmp = angular.copy(newCodeTemplate);
                tmp.createdBy = user.userID;
                tmp.updatedBy = user.userID;
                tmp.createdTimestamp = new Date();
                tmp.updatedTimestamp = new Date();
                tmp.groupingName = $scope.newGroupingName;
                tmp.codeValue = 0;
                if ($scope.codes.length > 0) {
                    tmp.codeValue = parseInt($scope.codes[$scope.codes.length - 1].codeValue) + 1;
                }
                tmp.platformID = PlatformService.current.id;
                $scope.codes.push(tmp);
                CodeTableStateService.state = true;
            });
        };
        $scope.$on("autocomplete-box-item-selected", function(e, group) {
            newCodeTemplate.groupingName = group;
            $scope.newGroupingName = group;
            changeCodeTable(group);
        });
        var changeCodeTable = function(group) {
            CodeTableStateService.state = false;
            $scope.$emit("code-table-discard-changes");
            $scope.codes = [];
            $scope.trashMode = false;
            CodesService.findByGroupingName(group, function(codes) {
                codes.sort(function(a, b) {
                    if (parseInt(a.code_value) < parseInt(b.code_value)) {
                        return -1;
                    }
                    if (parseInt(a.code_value) > parseInt(b.code_value)) {
                        return 1;
                    }
                    return 0;
                }).map(function(c) {
                    c.changed = false;
                    return c;
                });
                $scope.codes = angular.copy(codes);
            });
        };
        $scope.$on("autocomplete-box-modal-item-selected", function(e, group) {
            _itemSelected(group);
        });
        var _itemSelected = function(group) {
            $scope.trashMode = false;
            CodeTableStateService.state = false;
            $scope.modalCodes = [];
            CodesService.findByGroupingName(group, function(codes) {
                codes.sort(function(a, b) {
                    if (parseInt(a.code_value) < parseInt(b.code_value)) {
                        return -1;
                    }
                    if (parseInt(a.code_value) > parseInt(b.code_value)) {
                        return 1;
                    }
                    return 0;
                });
                $scope.modalCodes = codes;
            });
        };
        $scope.cancel = function() {
            $scope.clearCodes();
            $scope.trashMode = false;
            $scope.$broadcast("cancel-new-group");
        };
        $scope.saveChanges = function() {
            var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
            var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
            function GET_ITER$0(v) {
                if (v) {
                    if (Array.isArray(v)) return 0;
                    var f;
                    if (S_MARK$0) S_MARK$0(v);
                    if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                        if (S_MARK$0) S_MARK$0(void 0);
                        return f.call(v);
                    }
                    if (S_MARK$0) S_MARK$0(void 0);
                    if (v + "" === "[object Generator]") return v;
                }
                throw new Error(v + " is not iterable");
            }
            var $D$0;
            var $D$1;
            var $D$2;
            var $D$3;
            var changedCodes = [];
            $D$3 = $scope.codes;
            $D$0 = GET_ITER$0($D$3);
            $D$2 = $D$0 === 0;
            $D$1 = $D$2 ? $D$3.length : void 0;
            for (var code; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                code = $D$2 ? $D$3[$D$0++] : $D$1["value"];
                if (code.changed) {
                    if (code.shortName === null || code.shortName === "") {
                        NotificationQueue.push({
                            text: "Invalid codes found! Please fix.",
                            icon: "thumbs-o-down"
                        });
                        return;
                    }
                    changedCodes.push(code);
                }
            }
            $D$0 = $D$1 = $D$2 = $D$3 = void 0;
            CodesService.save({
                codes: changedCodes,
                deleted: $scope.deletedCodes
            }, function() {
                NotificationQueue.push({
                    text: "Saved all changed!",
                    icon: "thumbs-o-up"
                });
                $scope.cancel();
                $scope.trashMode = false;
                var group = $scope.newGroupingNamee;
                CodesService.clearSpecificCache("code/name/" + group);
                _itemSelected(group);
                $scope.$broadcast("code-table-saved");
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("codesTable", [ "$timeout", function($timeout) {
        return {
            controller: function($scope) {
                $scope.deSelect = function() {
                    $scope.$broadcast("codes-multiedit-deselect");
                };
            },
            link: function(scope, element, attrs) {
                $timeout(function() {
                    var stage_height = $("#stage").height();
                    var wrapper_bottom = parseInt($("#stage .wrapper").css("padding-bottom"));
                    var $mgma = $("#mgma");
                    var toolbar_height = $mgma.find(".toolbar").height() + parseInt($mgma.find(".toolbar").css("padding-top")) * 2 + parseInt($mgma.find(".toolbar").css("border-bottom-width"));
                    var mgma_stage_top = parseInt($mgma.find(".mgma-stage").css("padding-top"));
                    var bottom = $("#code-table-action-button").outerHeight();
                    var panel_heading = element.find(".panel-heading").outerHeight();
                    var table_heading = element.find(".segment-field-heading").outerHeight();
                    var element_height = stage_height - (wrapper_bottom + toolbar_height + mgma_stage_top) - (table_heading + panel_heading) - bottom - 22;
                    element.find(".segment-fields").css({
                        height: element_height
                    });
                }, 1e3);
            }
        };
    } ]);
    app.directive("sidebarBox", [ function() {
        return {
            templateUrl: "assets/templates/apps/data/metadatamanagement/codetablemanagement/autocompleteBox/_partial.html",
            link: function(scope, element) {
                var stage_height = $("#stage").height();
                var wrapper_bottom = parseInt($("#stage .wrapper").css("padding-bottom"));
                var $mgma = $("#mgma");
                var toolbar_height = $mgma.find(".toolbar").height() + parseInt($mgma.find(".toolbar").css("padding-top")) * 2 + parseInt($mgma.find(".toolbar").css("border-bottom-width"));
                var mgma_stage_top = parseInt($mgma.find(".mgma-stage").css("padding-top"));
                var element_height = stage_height - (wrapper_bottom + toolbar_height + mgma_stage_top);
                element.css({
                    height: element_height
                });
                element.find(".list-viewer-wrapper").css({
                    height: function() {
                        var pad = (parseInt(element.css("padding-top")) + parseInt(element.css("border-top-width"))) * 2;
                        return element_height - pad - element.find(".list-viewer-toolbar").height() - parseInt($(this).css("margin-top"));
                    }
                });
            }
        };
    } ]);
    app.directive("autocompleteBoxModal", [ function() {
        return {
            controller: function($scope, $element) {
                $scope.$on("autocomplete-box-modal-deselect", function() {
                    $scope.selected = false;
                    $scope.active = 0;
                    $scope.selectedOne = null;
                });
                $scope.selectGroup = function(index, name) {
                    index = typeof index !== "undefined" ? index : null;
                    if (index === null) {
                        $scope.selectedOne = name;
                        index = name;
                    } else {
                        $scope.selectedOne = $scope.results[index].original;
                    }
                    $scope.search = "";
                    $scope.selected = index;
                    $scope.$emit("autocomplete-box-modal-item-selected", $scope.selectedOne);
                };
            }
        };
    } ]);
    app.directive("autocompleteBoxMain", [ "CodeTableStateService", "AlertMessageService", "CodesService", "NotificationQueue", function(CodeTableStateService, AlertMessageService, CodesService, NotificationQueue) {
        return {
            controller: function($scope, $element) {
                $scope.dirty = false;
                $scope.newGroupMode = false;
                CodeTableStateService.watch("state", function(oldValue, newValue) {
                    $scope.dirty = newValue;
                });
                $scope.newGrouping = function() {
                    $scope.newGroupMode = true;
                    $scope.$parent.newGroupingName = $scope.search;
                    $scope.$parent.clearCodes();
                    $scope.$parent.addNewCode($scope.$parent.newGrouping);
                };
                $scope.$on("cancel-new-group", function() {
                    $scope.newGroupMode = false;
                    $scope.dirty = false;
                });
                $scope.askDeleteGroup = function(item) {
                    var buttons = [];
                    buttons.push({
                        "class": "btn-danger",
                        label: "DELETE",
                        action: function() {
                            CodesService.deleteGrouping(item, function() {
                                NotificationQueue.push({
                                    icon: "thumbs-up",
                                    text: "Successfully deleted Code Group!"
                                });
                                $scope.$emit("code-table-saved");
                            });
                        },
                        dismiss: true
                    });
                    buttons.push({
                        "class": "btn-default",
                        label: "Cancel",
                        dismiss: true
                    });
                    AlertMessageService.showQuestion("Hold on!", "This will delete the entire Group including all of the attached codes. Continue?", buttons);
                };
                $scope.selectGroup = function(index, name) {
                    if ($scope.dirty) {
                        AlertMessageService.showQuestion("Unsaved Changes!", "You have unsaved changes, do you wish to discard them?", [ {
                            "class": "btn-danger",
                            label: "Discard",
                            action: function() {
                                _selectGroup(index, name);
                            },
                            dismiss: true
                        }, {
                            "class": "btn-default",
                            label: "No",
                            dismiss: true
                        } ]);
                        return;
                    }
                    _selectGroup(index, name);
                };
                var _selectGroup = function(index, name) {
                    index = typeof index !== "undefined" ? index : null;
                    $scope.newGroupMode = false;
                    $scope.dirty = false;
                    if (index === null) {
                        $scope.selectedOne = name;
                        index = name;
                    } else {
                        $scope.selectedOne = $scope.results[index].original;
                    }
                    $scope.search = "";
                    $scope.selected = index;
                    $scope.$emit("autocomplete-box-item-selected", $scope.selectedOne);
                };
            }
        };
    } ]);
    app.directive("autocompleteBox", [ "$sce", "CodesService", function($sce, CodesService) {
        return {
            scope: true,
            controller: function($scope, $element, $attrs) {
                $scope.search = "";
                $scope.results = [];
                $scope.selected = false;
                $scope.active = 0;
                $scope.selectedOne = null;
                $scope.canCreate = false;
                $scope.canDelete = true;
                $scope.trashMode = false;
                $scope.$on("cancel-new-group", function() {
                    $scope.search = "";
                    $scope.active = 0;
                    $scope.selectedOne = null;
                    $scope.selected = false;
                });
                $scope.list = [];
                $scope.fetchGroups = function() {
                    var cb = arguments[0];
                    if (cb === void 0) cb = null;
                    CodesService.fetchGroups(function(groups) {
                        $scope.list = groups;
                        if (cb !== null) {
                            cb.apply();
                        }
                    });
                };
                $scope.fetchGroups();
                $scope.toggleDelete = function() {
                    $scope.trashMode = !$scope.trashMode;
                };
                $scope.$on("code-table-saved", function() {
                    var _search = $scope.search;
                    $scope.search = "";
                    $scope.fetchGroups(function() {
                        $scope.active = $scope.list.indexOf(_search);
                        $scope.selectedOne = $scope.list[$scope.active];
                    });
                    $scope.trashMode = false;
                });
                $scope.$on("code-table-has-changed", function() {
                    $scope.dirty = true;
                });
                $scope.$on("code-table-refresh-selected", function() {
                    $scope.selectGroup($scope.selectedOne);
                });
                $scope.$watch("search", function(newValue, oldValue, scope) {
                    var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
                    var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
                    function GET_ITER$0(v) {
                        if (v) {
                            if (Array.isArray(v)) return 0;
                            var f;
                            if (S_MARK$0) S_MARK$0(v);
                            if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                                if (S_MARK$0) S_MARK$0(void 0);
                                return f.call(v);
                            }
                            if (S_MARK$0) S_MARK$0(void 0);
                            if (v + "" === "[object Generator]") return v;
                        }
                        throw new Error(v + " is not iterable");
                    }
                    var $D$0;
                    var $D$1;
                    var $D$2;
                    if (scope.results.length === 0 || scope.selected !== false && angular.isDefined(scope.selected) && newValue !== scope.results[scope.selected].original) {
                        scope.selected = false;
                    }
                    if (newValue !== oldValue && newValue !== "" && scope.selected === false) {
                        var m = fuzzy.filter(newValue, scope.list, {
                            pre: "<strong>",
                            post: "</strong>"
                        });
                        scope.results = [];
                        var found = false;
                        $D$0 = GET_ITER$0(m);
                        $D$2 = $D$0 === 0;
                        $D$1 = $D$2 ? m.length : void 0;
                        for (var r; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                            r = $D$2 ? m[$D$0++] : $D$1["value"];
                            if (newValue === r.original) {
                                found = true;
                                scope.canCreate = false;
                                break;
                            }
                        }
                        $D$0 = $D$1 = $D$2 = void 0;
                        if (found === false) {
                            scope.canCreate = true;
                        }
                        scope.active = 0;
                        for (var i in m) {
                            scope.results.push({
                                string: $sce.trustAsHtml(m[i].string),
                                original: m[i].original
                            });
                        }
                    }
                    if (newValue === "") {
                        scope.results = [];
                        scope.canCreate = false;
                    }
                });
                $scope.onDownArrow = function() {
                    if (parseInt($scope.active) + 1 < $scope.results.length) {
                        $scope.$apply(function() {
                            $scope.active = parseInt($scope.active) + 1;
                        });
                    }
                };
                $scope.onUpArrow = function() {
                    if (parseInt($scope.active) - 1 >= 0) {
                        $scope.$apply(function() {
                            $scope.active = parseInt($scope.active) - 1;
                        });
                    }
                };
                $scope.onEnter = function() {
                    $scope.$apply(function() {
                        $scope.selectGroup($scope.active);
                    });
                };
            },
            link: function(scope, element, attrs) {
                scope.$watchGroup("results", function(newValue, oldValue) {
                    if (newValue.length > 0) {
                        element.on("keydown", function(e) {
                            if (e.which === 40) {
                                scope.onDownArrow();
                                return e.preventDefault();
                            } else if (e.which === 38) {
                                scope.onUpArrow();
                                return e.preventDefault();
                            } else if (e.which === 13) {
                                scope.onEnter();
                                return e.preventDefault();
                            }
                        });
                    } else {
                        element.off("keydown");
                    }
                });
                scope.$watch("active", function(newValue, oldValue) {
                    var $results = element.find(".list-viewer-wrapper");
                    var F = $results.outerHeight();
                    if (newValue !== oldValue) {
                        var T = element.find(".active").outerHeight();
                        var O = (parseInt(newValue) + 2) * T;
                        var X = Math.abs(F - O);
                        if (O > F) {
                            $results.scrollTop(X);
                        } else {
                            $results.scrollTop(0);
                        }
                    }
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("code", [ "UserService", "CodesService", "CodeTableStateService", function(UserService, CodesService, CodeTableStateService) {
        return {
            templateUrl: "assets/templates/apps/data/metadatamanagement/codetablemanagement/code/_partial.html",
            controller: function($scope) {
                $scope.isReadOnly = false;
                $scope.createdByName = "";
                $scope.updatedByName = "";
                $scope.parent = "None";
                $scope.selected = false;
                $scope.changed = false;
                $scope.original = angular.copy($scope.code);
                var unwatch = $scope.$watchCollection("code", function(newValue, oldValue, scope) {
                    if (newValue !== oldValue) {
                        if (JSON.stringify(angular.copy(newValue)) !== JSON.stringify(scope.original)) {
                            scope.changed = true;
                        } else {
                            scope.changed = false;
                        }
                        scope.code.changed = scope.changed;
                        CodeTableStateService.state = scope.changed;
                    }
                });
                $scope.$on("code-table-saved", function() {
                    $scope.code.changed = false;
                    $scope.original = angular.copy($scope.code);
                    $scope.changed = false;
                    CodeTableStateService.state = $scope.changed;
                });
                $scope.chooseParent = function() {
                    $scope.selected = true;
                    $scope.$emit("codes-parent-chooser-open", $scope.code.parentID);
                };
                $scope.$on("codes-parent-chosen", function(e, parentId) {
                    if ($scope.selected) {
                        $scope.selected = false;
                        if (parentId === null) {
                            $scope.code.parentID = 0;
                            $scope.parent = "None";
                        } else {
                            $scope.code.parentID = parentId;
                            getParent();
                        }
                    }
                });
                $scope.$on("codes-multiedit-deselect", function() {
                    $scope.selected = false;
                });
                var getParent = function() {
                    if (parseInt($scope.code.parentID) > 0) {
                        CodesService.findById($scope.code.parentID, function(code) {
                            $scope.parent = code;
                        });
                    }
                };
                getParent();
                var getUserInfo = function() {
                    UserService.getUser($scope.code.createdBy, function(user) {
                        $scope.createdByName = user.name;
                    });
                    UserService.getUser($scope.code.updatedBy, function(user) {
                        $scope.updatedByName = user.name;
                    });
                };
                getUserInfo();
                var isLocked = function() {
                    if (parseInt($scope.code.lockedIndicator) === "LOCKED") {
                        $scope.isReadOnly = true;
                    }
                };
                isLocked();
                $scope.$on("$destroy", function() {
                    unwatch();
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("codeParentModal", [ "CodesService", function(CodesService) {
        return {
            templateUrl: "assets/templates/apps/data/metadatamanagement/codetablemanagement/codeTableParent/_partial.html",
            controller: function($scope, $element) {
                $scope.parents = [];
                $scope.choosen = null;
                $scope.modalCodes = [];
                $scope.chooseParent = function(parentId) {
                    $scope.$broadcast("codes-parent-chosen", parentId);
                    $scope.choosen = null;
                    $element.modal("hide");
                };
                $scope.unselectParent = function() {
                    $scope.$broadcast("codes-parent-chosen", null);
                    $scope.choosen = null;
                    $element.modal("hide");
                };
                $scope.$on("codes-parent-chooser-open", function(e, parent) {
                    $element.modal();
                    $scope.choosen = parent;
                });
                $element.on("hidden.bs.modal", function() {
                    $scope.$apply(function() {
                        $scope.modalCodes = [];
                        $scope.$broadcast("autocomplete-box-modal-deselect");
                        $scope.$broadcast("codes-multiedit-deselect");
                    });
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("RecordLayoutManagementController", [ "$scope", "RecordLayoutService", "APIService", "$cookies", "$log", function($scope, RecordLayoutService, APIService, $cookies, $log) {
        var ref = this;
        this.folder_name = "data/metadatamanagement/recordlayoutmanagement";
        $scope.testingAPI = false;
        $scope.listLoaded = false;
        $scope.layoutList = [];
        RecordLayoutService.onUpdate(function(layouts) {
            $scope.layoutList = layouts;
            $scope.listLoaded = true;
        });
        RecordLayoutService.refresh();
        $scope.newLayout = function() {
            RecordLayoutService.select(false);
            $scope.current_view = "assets/templates/apps/" + ref.folder_name + "/newLayout/_newLayoutView.html";
        };
        $scope.selectLayout = function(layout) {
            RecordLayoutService.select(layout);
            $scope.$emit("at-layout-change-to-edit-mode");
        };
        $scope.$on("at-layout-reset", function() {
            RecordLayoutService.refresh();
            $scope.current_view = null;
        });
        $scope.current_view = null;
        $scope.$on("at-layout-locked-layout", function() {
            var s = RecordLayoutService.getSelected();
            $scope.current_view = "assets/templates/apps/" + ref.folder_name + "/lockedLayout/_lockedLayoutView.html?t=" + s.name + "&t=" + moment().toISOString();
        });
        $scope.$on("at-layout-change-to-edit-mode", function() {
            var s = RecordLayoutService.getSelected();
            $scope.current_view = "assets/templates/apps/" + ref.folder_name + "/editLayout/_editLayoutView.html?t=" + s.name + "&t=" + moment().toISOString();
        });
    } ]);
    app.directive("atLayoutPanels", [ function() {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                var listview_height = $("#record-layout-list-viewer").outerHeight();
                var layout_action_button_height = $("#layout-action-button").outerHeight();
                var h = listview_height - (parseInt(element.prev(".row").outerHeight()) + layout_action_button_height);
                element.css({
                    height: h
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("RecordLayoutCommonService", [ "APIService", "AlertMessageService", "$log", "RecordLayoutUtilityService", "PlatformService", function(APIService, AlertMessageService, $log, RecordLayoutUtilityService, PlatformService) {
        var _postProcess = function(layout) {
            var _layout = angular.copy(layout);
            var _init_segments = {
                arc: _layout.arcid,
                drc: _layout.drcid,
                zrc: _layout.zrcid
            };
            delete _layout["createDate"];
            delete _layout["createUserID"];
            delete _layout["updateDate"];
            delete _layout["updateUserID"];
            delete _layout["checkedOutDate"];
            delete _layout["checkedOutUserID"];
            delete _layout["lockedDate"];
            delete _layout["lockedOutUserID"];
            delete _layout["arcid"];
            delete _layout["drcid"];
            delete _layout["zrcid"];
            delete _layout["typeID"];
            _layout.version = (parseInt(layout.version) / 100).toString();
            _layout.created = {
                on: moment(new Date(layout.createDate)).format("MM/DD/YYYY"),
                by: layout.createUserID
            };
            _layout.updated = {
                on: moment(new Date(layout.updateDate)).format("MM/DD/YYYY"),
                by: layout.updateUserID
            };
            _layout.checked_out = {
                is: layout.checkedOutDate === null ? false : true,
                on: moment(new Date(layout.checkedOutDate)).format("MM/DD/YYYY"),
                by: layout.checkedOutUserID
            };
            _layout.locked = {
                is: layout.lockedDate === null ? false : true,
                on: moment(new Date(layout.lockedDate)).format("MM/DD/YYYY"),
                by: layout.lockedUserID
            };
            _layout.type = layout.typeID;
            _layout.segments = {};
            return [ _layout, _init_segments ];
        };
        this.deleteLayout = function(layout, cb) {
            APIService.delete("layout/" + layout.id).success(function() {
                cb.apply(null, []);
            });
        };
        this.getTypeByID = function(id, cb) {
            APIService.get("datatype/" + id).success(function(type) {
                cb.apply(null, [ type ]);
            });
        };
        this.getTypes = function(cb) {
            APIService.get("layout/types").success(function(types) {
                cb.apply(null, [ types ]);
            }).error(function(err) {
                AlertMessageService.showError("Oh no!", "Unable to fetch types! [" + err + "]");
            });
        };
        this.clone = function(layoutID, cb) {
            APIService.put("layout/clone", layoutID).success(function(layout) {
                cb.apply(null, [ layout ]);
            });
        };
        this.getLayoutVersions = function(typeID, cb) {
            APIService.get("layout/versions/type/" + typeID).success(function(versions) {
                cb.apply(null, [ versions ]);
            });
        };
        this.getLayoutsByType = function(typeId, cb) {
            APIService.get("layout/type/" + typeId).success(function(data) {
                cb.apply(null, [ data ]);
            });
        };
        this.addChildrenProp = function(segments) {
            for (var i in segments) {
                var latest = false;
                if (parseInt(i) === parseInt(segments.length - 1)) {
                    latest = true;
                }
                segments[i] = {
                    id: segments[i].id,
                    name: segments[i].name,
                    version: segments[i].version,
                    latest: latest,
                    children: []
                };
            }
            return segments;
        };
        this.getLatestLayout = function(type, cb) {
            APIService.get("layout/latest/" + type.id + "/p/" + PlatformService.current.id).success(function(data) {
                cb.apply(null, _postProcess(data));
            }).error(function(error, status) {
                console.log(error, status);
            });
        };
        var _versionPostProxess = function(name, segs) {
            var all = [];
            for (var i in segs) {
                all.push({
                    id: segs[i].id,
                    version: (parseInt(segs[i].version) / 100).toString(),
                    name: name
                });
            }
            return all;
        };
        this.getLayoutSegments = function(layoutID, cb) {
            APIService.get("layout/segments/" + layoutID).success(function(data) {
                var _layout = RecordLayoutUtilityService._initLayout(data);
                cb.apply(null, [ _layout ]);
            }).error(function(error, status) {
                console.log(error, status);
            });
        };
        this.getInitSegments = function(cb) {
            var p = {
                arc: null,
                drc: null,
                zrc: null
            };
            var ref = this;
            APIService.get("segment/versions/ARC/p/" + PlatformService.current.id).success(function(arc) {
                p.arc = _versionPostProxess("ARC", arc);
                APIService.get("segment/versions/DRC/p/" + PlatformService.current.id).success(function(drc) {
                    p.drc = _versionPostProxess("DRC", drc);
                    APIService.get("segment/versions/ZRC/p/" + PlatformService.current.id).success(function(zrc) {
                        p.zrc = _versionPostProxess("ZRC", zrc);
                        cb.apply(null, [ p ]);
                    }).error(function(err, status) {
                        ref.initSegmentError("ZRC", status);
                    });
                }).error(function(err, status) {
                    ref.initSegmentError("DRC", status);
                });
            }).error(function(err, status) {
                ref.initSegmentError("ARC", status);
            });
            this.initSegmentError = function(name, err) {
                AlertMessageService.showError("Oh no!", "Unable to fetch " + name + " segments!");
                $log.error("Unable to fetch " + name + " segment due to [" + err + "]");
            };
        };
        var _preProcess = function(layout, init_segments) {
            var _layout = angular.copy(layout);
            var _init_segments = angular.copy(init_segments);
            _layout.init_segments = init_segments;
            if (_layout.hasOwnProperty("user")) {
                _layout.updated.by = _layout.user;
                delete _layout["user"];
            }
            delete _layout["lockedUserID"];
            _layout.version = parseFloat(layout.version) * 100;
            _layout.platformID = PlatformService.current.id;
            return _layout;
        };
        this.update = function(layout, init_segments, cb) {
            var _layout = _preProcess(layout, init_segments);
            APIService.post("layout", _layout).success(function(r) {
                cb.apply(null, [ r ]);
            });
        };
        this.create = function(layout, init_segments, cb) {
            var _layout = _preProcess(layout, init_segments);
            APIService.put("layout", _layout).success(function(r) {
                cb.apply(null, [ r ]);
            });
        };
    } ]);
    app.service("RecordLayoutService", [ "APIService", "AlertMessageService", "PlatformService", function(APIService, AlertMessageService, PlatformService) {
        var _list = [];
        var _listeners = [];
        this.data = {
            list: []
        };
        var _runOnUpdate = function() {
            angular.forEach(_listeners, function(cb) {
                cb.apply(null, [ _list ]);
            });
        };
        this.onUpdate = function(cb) {
            _listeners.push(cb);
        };
        this.getSelected = function() {
            var r = _list.filter(function(item) {
                return item.isSelected;
            });
            if (r.length > 0) {
                return r[0];
            }
            return {};
        };
        this.select = function(layout) {
            if (layout === false) {
                _list = _list.map(function(item) {
                    item.isSelected = false;
                    return item;
                });
            } else {
                _list.forEach(function(l) {
                    if (l.typeID === layout.typeID) {
                        l.isSelected = true;
                    } else {
                        l.isSelected = false;
                    }
                }, layout);
            }
        };
        this.getList = function(cb) {
            APIService.get("layout/all/" + PlatformService.current.id).success(function(data) {
                cb.apply(null, [ data ]);
            }).error(function(err) {
                AlertMessageService.showError("Unable to fetch layout list! [" + err + "]");
            });
        };
        this.refresh = function(cb) {
            cb = cb || null;
            this.getList(function(list) {
                _list = list.map(function(l) {
                    return {
                        name: l.name,
                        typeID: l.id,
                        show_in_list: true,
                        isSelected: false
                    };
                });
                if (cb !== null) cb.apply(null, [ _list ]);
                _runOnUpdate();
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("RecordLayoutUtilityService", [ function() {
        var _layout = null;
        this._segmentMold = function(sName, sVersion) {
            var tmp = {
                name: sName,
                version: sVersion / 100,
                latest: true,
                children: []
            };
            if (sVersion > 0) {
                tmp.latest = false;
            }
            return tmp;
        };
        this._findDRC = function() {
            var drc = _layout.filter(function(s) {
                if (s.segmentName === "DRC") {
                    return s;
                }
            });
            return drc;
        };
        this._initLayout = function(layout) {
            _layout = layout;
            var drc = this._findDRC();
            var l = this._segmentMold(drc[0].segmentName, drc[0].segmentVersion);
            l.children = this._findChildren(drc);
            return l;
        };
        this._findSegment = function(name, version) {
            var segments = _layout.filter(function(s) {
                if (this.name === s.segmentName && this.version === s.segmentVersion) {
                    return s;
                }
            }, {
                name: name,
                version: version
            });
            return segments;
        };
        this._findChildren = function(parent) {
            var children = [];
            for (var i in parent) {
                children.push(this._segmentMold(parent[i].childSegmentName, parent[i].childSegmentVersion));
                var _tmp = this._findSegment(parent[i].childSegmentName, parent[i].childSegmentVersion);
                if (_tmp.length > 0) {
                    children[children.length - 1].children = this._findChildren(_tmp);
                }
            }
            return children;
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atLayoutDropzone", [ "SegmentGrabService", "$document", "NotificationQueue", function(SegmentGrabService, $document, NotificationQueue) {
        return {
            restrict: "A",
            templateUrl: "assets/templates/apps/data/metadatamanagement/recordlayoutmanagement/dropZone/_atLayoutDropzone.html",
            controller: function($scope, $element, $attrs) {
                $scope.canEdit = true;
                $scope.$on("layout-can-edit", function(e, status) {
                    $scope.canEdit = status;
                });
                $scope.segmentsLocation = SegmentGrabService.segmentsLocation;
                var clipboard = null;
                var ref = this;
                var stripElementId = function(segment) {
                    for (var i in segment.children) {
                        delete segment.children[i].$element_id;
                        if (segment.children[i].children.length > 0) {
                            stripElementId(segment.children[i]);
                        }
                    }
                };
                this.canIPaste = function() {
                    return !(clipboard === null);
                };
                this.copy = function(context) {
                    var segmentCopy = angular.copy(context.scope.segment);
                    delete segmentCopy.$element_id;
                    stripElementId(segmentCopy);
                    NotificationQueue.push({
                        icon: "files-o",
                        text: "Copied segment to clipboard!"
                    });
                    clipboard = segmentCopy;
                };
                this.cut = function(context) {
                    this.copy(context);
                    this.remove(context);
                };
                this.remove = function(context) {
                    var parent = context.scope.$parent;
                    var grand = parent.$parent;
                    for (var i in grand.segment.children) {
                        if (grand.segment.children[i].$element_id === context.scope.segment.$element_id) {
                            grand.segment.children.splice(i, 1);
                            break;
                        }
                    }
                    parent.$destroy();
                };
                this.paste = function(context) {
                    context.scope.segment.children.push(clipboard);
                    clipboard = null;
                    $scope.$broadcast("dz-segment-" + context.scope.segment.$element_id, context.scope.segment.$element_id);
                };
                $scope.$on("$destroy", function() {
                    $document.off("mouseup");
                });
            },
            link: function(scope, element, attrs) {
                var panel_height = element.parent().parent().outerHeight();
                var panel_heading_height = element.parent().parent().find(".panel-heading").outerHeight();
                var h = panel_height - panel_heading_height;
                element.parent().css({
                    height: h
                });
                element.css({
                    height: h
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var SegmentDropzone = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        var S_ITER$0 = typeof Symbol !== "undefined" && Symbol && Symbol.iterator || "@@iterator";
        var S_MARK$0 = typeof Symbol !== "undefined" && Symbol && Symbol["__setObjectSetter__"];
        function GET_ITER$0(v) {
            if (v) {
                if (Array.isArray(v)) return 0;
                var f;
                if (S_MARK$0) S_MARK$0(v);
                if (typeof v === "object" && typeof (f = v[S_ITER$0]) === "function") {
                    if (S_MARK$0) S_MARK$0(void 0);
                    return f.call(v);
                }
                if (S_MARK$0) S_MARK$0(void 0);
                if (v + "" === "[object Generator]") return v;
            }
            throw new Error(v + " is not iterable");
        }
        function SegmentDropzone($scope, $element, $compile, SegmentGrabService, ContextMenuItemFactory, ContextMenuService) {
            this.$scope = $scope;
            this.$element = $element;
            this.$compile = $compile;
            this.SegmentGrabService = SegmentGrabService;
            this.ContextMenuItemFactory = ContextMenuItemFactory;
            this.ContextMenuService = ContextMenuService;
            this._setupState();
            this._setupScope();
            this._init();
        }
        DP$0(SegmentDropzone, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.unwatch = this.$scope.$watch("segment", function(newValue, oldValue) {
                if (angular.isDefined(newValue) && newValue !== null && self.elementID === null) {
                    self.onLoaded();
                    self.unwatch();
                }
            });
            if (this.$scope.segment !== null) {
                this.unwatch();
                this.onLoaded();
            }
        };
        proto$0.onLoaded = function() {
            var self = this;
            var rightNow = moment().format();
            var seg = {};
            this.elementID = "at-dz-segment-" + md5(this.SegmentGrabService.segments.count + rightNow);
            this.SegmentGrabService.segments.count += 1;
            this.$element.attr("id", this.elementID);
            this.$scope.segment.$element_id = this.elementID;
            if (!this.$scope.segment.hasOwnProperty("children")) {
                this.$scope.segment.children = [];
            } else {
                if (this.$scope.segment.children.length > 0) {
                    this.createOnInitLoadChildren();
                }
            }
            this.$scope.$on("dz-segment-" + this.$scope.segment.$element_id, function(e, e_id) {
                self.createChild();
            });
            this.$element.find(this.ACTUAL_ELEMENT).on("contextmenu", function(e) {
                e.preventDefault();
                return false;
            });
        };
        proto$0.createChild = function() {
            var $child = $(this.NEW_SEGMENT_TMPL);
            var newScope = this.$scope.$new();
            newScope.segment = this.$scope.segment.children[this.$scope.segment.children.length - 1];
            var child = this.$compile($child)(newScope);
            this.$element.find(this.CREATION_POINT).append(child);
        };
        proto$0.createOnInitLoadChildren = function() {
            var $D$0;
            var $D$1;
            var $D$2;
            var $D$3;
            var children = [];
            $D$3 = this.$scope.segment.children;
            $D$0 = GET_ITER$0($D$3);
            $D$2 = $D$0 === 0;
            $D$1 = $D$2 ? $D$3.length : void 0;
            for (var segment; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0["next"]())["done"]; ) {
                segment = $D$2 ? $D$3[$D$0++] : $D$1["value"];
                var $child = $(this.NEW_SEGMENT_TMPL);
                var childScope = this.$scope.$new();
                childScope.segment = segment;
                var child = this.$compile($child)(childScope);
                children.push(child);
            }
            $D$0 = $D$1 = $D$2 = $D$3 = void 0;
            this.$element.find(this.CREATION_POINT).append(children);
        };
        proto$0.onMouseOver = function($event) {
            this.$scope.over = true;
            this.SegmentGrabService.over(this.$scope.segment);
        };
        proto$0.onMouseOut = function($event) {
            this.$scope.over = false;
        };
        proto$0.onMouseDrop = function($e, $event) {
            this.SegmentGrabService.drop();
            this.createChild();
        };
        proto$0.onSegmentContextMenuCreate = function($event) {
            var self = this;
            var context = {
                scope: this.$scope,
                element: this.$element
            };
            var menuItems = [];
            menuItems.push(this.ContextMenuItemFactory.build("Copy").setIcon("fa-file-o").setAction(function() {
                self.$scope.parentController.copy(context);
            }));
            menuItems.push(this.ContextMenuItemFactory.build("Cut").setIcon("fa-scissors").setAction(function() {
                self.$scope.parentController.cut(context);
            }));
            if (this.$scope.parentController.canIPaste()) {
                menuItems.push(this.ContextMenuItemFactory.build("Paste").setIcon("fa-clipboard").setAction(function() {
                    self.$scope.parentController.paste(context);
                }));
            }
            menuItems.push(this.ContextMenuItemFactory.build("Remove").setIcon("fa-times").setAction(function() {
                self.$scope.parentController.remove(context);
            }));
            this.ContextMenuService.create($event, menuItems);
        };
        proto$0.onDRCContextMenuCreate = function($event) {
            if (this.canEdit) {
                if (this.$scope.parentController.canIPaste()) {
                    var context = {
                        scope: this.$scope,
                        element: this.$element
                    };
                    var menuItems = [];
                    var self = this;
                    menuItems.push(this.ContextMenuItemFactory.build("Paste").setIcon("fa-clipboard").setAction(function() {
                        self.$scope.parentController.paste(context);
                    }));
                    this.ContextMenuService.create($event, menuItems);
                }
            }
        };
        proto$0.onDestroy = function($event) {
            var self = this;
            this.$element.remove();
            this.SegmentGrabService.segmentsLocation.segments.forEach(function(segment, index) {
                var $D$4;
                var $D$5;
                var $D$6;
                $D$4 = GET_ITER$0(segment);
                $D$6 = $D$4 === 0;
                $D$5 = $D$6 ? segment.length : void 0;
                for (var elementID; $D$6 ? $D$4 < $D$5 : !($D$5 = $D$4["next"]())["done"]; ) {
                    elementID = $D$6 ? segment[$D$4++] : $D$5["value"];
                    if (self.$scope.segment.$element_id === elementID) {
                        self.SegmentGrabService.segmentsLocation.segments.splice(index, 1);
                        return;
                    }
                }
                $D$4 = $D$5 = $D$6 = void 0;
            });
        };
        proto$0._setupState = function() {
            this.canEdit = true;
            this.elementID = null;
            this.CREATION_POINT = ".segment-children:first";
            this.NEW_SEGMENT_TMPL = '<div at-layout-segment-dropzone segment="segment"></div>';
            this.MOUSE_OVER_CLASS = "over-dropzone";
            this.ACTUAL_ELEMENT = ".segment-main:first";
        };
        proto$0._setupScope = function() {
            this.$scope.over = false;
            this._attachParentController();
            this._attachCanEditSwitch();
            this._attachMouseOver();
            this._attachMouseOut();
            this._attachMouseDrop();
            this._attachSegmentContextMenu();
            this._attachDestroy();
        };
        proto$0._attachDestroy = function() {
            var self = this;
            this.$scope.$on("$destroy", function($event) {
                self.onDestroy($event);
            });
        };
        proto$0._attachParentController = function() {
            this.$scope.parentController = null;
        };
        proto$0._attachSegmentContextMenu = function() {
            var self = this;
            this.$scope.spawnContextMenu = function($event) {
                if ($event.button == 2) {
                    if (self.$scope.$parent.hasOwnProperty("segment") && self.canEdit) {
                        self.onSegmentContextMenuCreate($event);
                    } else {
                        self.onDRCContextMenuCreate($event);
                    }
                }
                $event.stopPropagation();
                $event.preventDefault();
                return false;
            };
        };
        proto$0._attachCanEditSwitch = function() {
            var self = this;
            this.$scope.$on("layout-can-edit", function(e, status) {
                self.canEdit = status;
            });
        };
        proto$0._attachMouseOut = function() {
            var self = this;
            this.$scope.mouseIsOut = function($event) {
                self.onMouseOut($event);
            };
        };
        proto$0._attachMouseOver = function() {
            var self = this;
            this.$scope.mouseIsOver = function($event) {
                self.onMouseOver($event);
            };
        };
        proto$0._attachMouseDrop = function() {
            var self = this;
            this.$scope.mouseDrop = function($event) {
                if ($event.button === 0 && self.SegmentGrabService.data.dragging) {
                    self.onMouseDrop(null, $event);
                }
            };
        };
        MIXIN$0(SegmentDropzone.prototype, proto$0);
        proto$0 = void 0;
        return SegmentDropzone;
    }();
    app.directive("atLayoutSegmentDropzone", [ "$compile", "SegmentGrabService", "$document", "ContextMenuService", "NotificationQueue", "ContextMenuItemFactory", function($compile, SegmentGrabService, $document, ContextMenuService, NotificationQueue, ContextMenuItemFactory) {
        return {
            restrict: "A",
            require: "^atLayoutDropzone",
            templateUrl: "assets/templates/apps/data/metadatamanagement/recordlayoutmanagement/dropZone/_atLayoutSegmentDropzone.html",
            scope: {
                segment: "="
            },
            controller: function($scope, $element) {
                var dz = new SegmentDropzone($scope, $element, $compile, SegmentGrabService, ContextMenuItemFactory, ContextMenuService);
            },
            link: function(scope, element, attrs, dzController) {
                scope.parentController = dzController;
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("EditLayoutController", [ "$scope", "RecordLayoutService", "RecordLayoutCommonService", "UserService", "APIService", "NotificationQueue", "AlertMessageService", "DataTypeService", function($scope, RecordLayoutService, RecordLayoutCommonService, UserService, APIService, NotificationQueue, AlertMessageService, DataTypeService) {
        var ref = this;
        $scope.layout = {};
        $scope.loadedView = null;
        $scope.ready = false;
        $scope.types = [];
        $scope.canEdit = true;
        $scope.init_segments = {
            arc: [],
            drc: [],
            zrc: []
        };
        $scope.init_segments_selected = {
            arc: null,
            drc: null,
            zrc: null
        };
        $scope.segment = {};
        $scope.summonNewTypeModal = function() {
            DataTypeService.summon();
        };
        var unWatch = $scope.$watch("ready", function(newValue, oldValue) {
            if (newValue === true) {
                init();
                $scope.loadedView = "assets/templates/apps/data/metadatamanagement/recordlayoutmanagement/editLayout/_loadedEditLayoutView.html";
            }
        });
        var init = function() {
            unWatch();
            if ($scope.layout.locked.is) {
                $scope.setCanEdit(false);
            }
            RecordLayoutCommonService.getTypes(function(types) {
                $scope.types = types;
                for (var i in $scope.types) {
                    if ($scope.types[i].id === $scope.layout.type) {
                        $scope.layout.type = $scope.types[i];
                        break;
                    }
                }
            });
        };
        RecordLayoutCommonService.getLatestLayout({
            id: RecordLayoutService.getSelected().typeID
        }, function(layout, init_segments) {
            $scope.layout = layout;
            UserService.getUser($scope.layout.created.by, function(user) {
                $scope.layout.created.by = user;
            });
            UserService.getUser($scope.layout.updated.by, function(user) {
                $scope.layout.updated.by = user;
            });
            if ($scope.layout.locked.by !== null) {
                $scope.$emit("at-layout-locked-layout");
                return;
            }
            if ($scope.layout.checked_out.by !== null) {
                UserService.getUser($scope.layout.checked_out.by, function(user) {
                    $scope.layout.checked_out.by = user;
                });
            }
            RecordLayoutCommonService.getInitSegments(function(p) {
                $scope.init_segments.arc = p.arc;
                $scope.init_segments.drc = p.drc;
                $scope.init_segments.zrc = p.zrc;
                $scope.init_segments.arc = RecordLayoutCommonService.addChildrenProp($scope.init_segments.arc);
                $scope.init_segments.drc = RecordLayoutCommonService.addChildrenProp($scope.init_segments.drc);
                $scope.init_segments.zrc = RecordLayoutCommonService.addChildrenProp($scope.init_segments.zrc);
                for (var seg in $scope.init_segments) {
                    for (var i in $scope.init_segments[seg]) {
                        if ($scope.init_segments[seg][i].id === init_segments[seg]) {
                            $scope.init_segments_selected[seg] = $scope.init_segments[seg][i];
                            break;
                        }
                    }
                }
                RecordLayoutCommonService.getLayoutSegments($scope.layout.id, function(segments) {
                    $scope.layout.segments = {};
                    $scope.layout.segments.drc = segments;
                    $scope.segment = $scope.layout.segments.drc;
                    $scope.$broadcast("drc-segment-loaded");
                    $scope.ready = true;
                });
            });
        });
        $scope.setCanEdit = function(status) {
            $scope.canEdit = status;
            $scope.$broadcast("layout-can-edit", status);
        };
        $scope.deleteLayout = function() {
            RecordLayoutCommonService.deleteLayout($scope.layout, function() {
                NotificationQueue.push({
                    icon: "thumbs-up",
                    text: "Layout is has been deleted!"
                });
                $scope.$emit("at-layout-reset");
            });
        };
        $scope.updateLayout = function() {
            UserService.getUserInfo(function(user) {
                $scope.layout.user = user;
                RecordLayoutCommonService.update($scope.layout, $scope.init_segments_selected, function() {
                    $scope.$emit("at-layout-change-to-edit-mode");
                });
            });
        };
        $scope.lockLayout = function() {
            UserService.getUserInfo(function(user) {
                APIService.post("layout/lock", {
                    id: $scope.layout.id,
                    user: user,
                    now: moment().format("MM/DD/YYYY")
                }).success(function(data) {
                    $scope.setCanEdit(false);
                    NotificationQueue.push({
                        icon: "thumbs-up",
                        text: "Layout is now locked!"
                    });
                    RecordLayoutService.select(data);
                    $scope.$emit("at-layout-locked-layout");
                }).error(function(status) {
                    AlertMessageService.showError("Oh no!", "Unable to lock layout!");
                });
            });
        };
        $scope.checkIn = function(cb) {
            ref.checkLayout("in", cb);
        };
        $scope.checkOut = function(cb) {
            ref.checkLayout("out", cb);
        };
        this.checkLayout = function(direction, cb) {
            UserService.getUserInfo(function(user) {
                APIService.post("layout/check/" + direction, {
                    id: $scope.layout.id,
                    user: user,
                    now: moment().format("MM/DD/YYYY")
                }).success(function(data) {
                    if (data.checkedOutUserID === null) {
                        $scope.layout.checked_out.is = false;
                        $scope.layout.checked_out.on = null;
                        $scope.layout.checked_out.self_checked = false;
                        $scope.layout.checked_out.by = null;
                    } else {
                        $scope.layout.checked_out.is = true;
                        $scope.layout.checked_out.on = moment(new Date(data.checkedOutDate)).format("MM/DD/YYYY");
                        $scope.layout.checked_out.self_checked = true;
                        $scope.layout.checked_out.by = user;
                    }
                    $scope.layout.updated.on = moment(new Date(data.updatedDate)).format("MM/DD/YYYY");
                    NotificationQueue.push({
                        icon: "thumbs-up",
                        text: "Layout is now checked " + direction + "!"
                    });
                    cb.apply(null, []);
                }).error(function(status) {
                    cb.apply(null, []);
                    AlertMessageService.showError("Oh no!", "Unable to check " + direction + "! [" + status + "]");
                });
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atLayoutSegments", [ function() {
        return {
            template: '<div at-layout-segment-start segment="segment"></div>',
            link: function(scope, element) {
                var _getStageHeight = function() {
                    return $(".mgma-stage").height();
                };
                var _panelOuterOffset = function() {
                    var $panel = element.closest(".panel");
                    return Math.abs($panel.outerHeight() - $panel.height()) + parseFloat($panel.css("margin-bottom"));
                };
                var _panelHeadingHeight = function() {
                    return element.parent().prev(".panel-heading").outerHeight();
                };
                var _setPanelHeight = function() {
                    var $panel = element.closest(".panel");
                    $panel.css({
                        height: Math.abs(_getStageHeight() - _panelOuterOffset())
                    });
                    $panel.find(".panel-body").css({
                        height: Math.abs(_getStageHeight() - (_panelHeadingHeight() + _panelOuterOffset()))
                    });
                };
                _setPanelHeight();
            }
        };
    } ]);
    app.directive("atLayoutSegmentStart", [ "$compile", function($compile) {
        return {
            templateUrl: "assets/templates/apps/data/metadatamanagement/recordlayoutmanagement/layoutSegments/_atLayoutSegmentView.html",
            controller: function($scope, $element) {
                var createChild = function(parent_segment_id) {
                    var $child = $('<div at-layout-segment-start segment="segment"></div>');
                    var childScope = $scope.$new();
                    childScope.segment = $scope.segment.children[$scope.segment.children.length - 1];
                    var child = $compile($child)(childScope);
                    $element.find(".segment-children:first").append(child);
                };
                var createInitChildren = function() {
                    var children = [];
                    for (var i in $scope.segment.children) {
                        var $child = $('<div at-layout-segment-start segment="segment"></div>');
                        var childScope = $scope.$new();
                        childScope.segment = $scope.segment.children[i];
                        var child = $compile($child[0].outerHTML)(childScope);
                        children.push(child);
                    }
                    $element.find(".segment-children:first").append(children);
                };
                var init = function() {
                    if (!$scope.segment.hasOwnProperty("children")) {
                        $scope.segment.children = [];
                    } else {
                        if ($scope.segment.children.length > 0) {
                            createInitChildren();
                        }
                    }
                };
                var unWatchInit = $scope.$watch("segment", function(newValue, oldValue) {
                    if (newValue !== null && _elementID === null) {
                        init();
                        unWatchInit();
                    }
                });
                if ($scope.segment !== null) {
                    unWatchInit();
                    init();
                }
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("LockedLayoutController", [ "$scope", "RecordLayoutService", "RecordLayoutCommonService", "UserService", "SegmentListService", function($scope, RecordLayoutService, RecordLayoutCommonService, UserService, SegmentListService) {
        $scope.layout = {};
        $scope.loadedView = null;
        $scope.other_version = null;
        $scope.versions = [];
        $scope.has_many_versions = false;
        $scope.cloneVersion = function() {
            UserService.getUserInfo(function(user) {
                RecordLayoutCommonService.clone({
                    layoutID: $scope.layout.id,
                    userID: user.userID
                }, function(id) {
                    console.log(id);
                });
            });
        };
        $scope.onVersionChange = function() {
            RecordLayoutService.select($scope.other_version);
            $scope.$emit("at-layout-change-to-edit-mode");
        };
        RecordLayoutCommonService.getLatestLayout({
            id: RecordLayoutService.getSelected().typeID
        }, function(layout, init_segments) {
            $scope.layout = layout;
            UserService.getUser($scope.layout.created.by, function(user) {
                $scope.layout.created.by = user;
            });
            UserService.getUser($scope.layout.updated.by, function(user) {
                $scope.layout.updated.by = user;
            });
            UserService.getUser($scope.layout.locked.by, function(user) {
                $scope.layout.locked.by = user;
            });
            $scope.layout.init_segments = {
                arc: null,
                drc: null,
                zrc: null
            };
            SegmentListService.fetchByID(init_segments.arc, function(arc) {
                $scope.layout.init_segments.arc = arc.version;
            });
            SegmentListService.fetchByID(init_segments.drc, function(drc) {
                $scope.layout.init_segments.drc = drc.version;
            });
            SegmentListService.fetchByID(init_segments.zrc, function(zrc) {
                $scope.layout.init_segments.zrc = zrc.version;
            });
            RecordLayoutCommonService.getTypeByID($scope.layout.type, function(type) {
                $scope.layout.type = type;
                RecordLayoutCommonService.getLayoutVersions(type.id, function(versions) {
                    if (versions.length > 1) {
                        $scope.has_many_versions = true;
                        $scope.versions = versions.map(function(v) {
                            v.decimalVersion = (v.version / 100).toString();
                            return v;
                        });
                        $scope.other_version = $scope.versions[$scope.versions.length - 1];
                    }
                });
            });
            RecordLayoutCommonService.getLayoutSegments($scope.layout.id, function(segments) {
                $scope.layout.segments = {};
                $scope.layout.segments.drc = segments;
                $scope.segment = $scope.layout.segments.drc;
                $scope.loadedView = "assets/templates/apps/data/metadatamanagement/recordlayoutmanagement/lockedLayout/_loadedLockedLayoutView.html";
            });
        });
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("NewLayoutController", [ "$scope", "$log", "RecordLayoutService", "UserService", "AlertMessageService", "SegmentPreviewService", "NotificationQueue", "RecordLayoutCommonService", "DataTypeService", function($scope, $log, RecordLayoutService, UserService, AlertMessageService, SegmentPreviewService, NotificationQueue, RecordLayoutCommonService, DataTypeService) {
        var ref = this;
        var nowNow = moment().format("MM/DD/YYYY");
        $scope.layout = {
            type: null,
            description: null,
            version: "0.1",
            platformID: null,
            created: {
                on: nowNow,
                by: null
            },
            updated: {
                on: nowNow,
                by: null
            },
            locked: {
                is: false,
                on: null,
                by: null
            },
            checked_out: {
                is: true,
                on: nowNow,
                by: null
            },
            segments: {
                drc: {}
            }
        };
        $scope.segment = null;
        $scope.types = [];
        $scope.summonNewTypeModal = function() {
            DataTypeService.summon();
        };
        $scope.$on("datatype-refresh", function(e, type) {
            type = type || null;
            fetchTypes(function() {
                if (type !== null) {
                    var i = $scope.types.map(function(m) {
                        return m.name;
                    }).indexOf(type.name);
                    $scope.layout.type = $scope.types[i];
                }
            });
        });
        var fetchTypes = function(cb) {
            cb = cb || null;
            RecordLayoutCommonService.getTypes(function(types) {
                $scope.types = types.filter(function(t) {
                    var i = this.layouts.map(function(l) {
                        return l.name;
                    }).indexOf(t.name);
                    if (i === -1) {
                        return true;
                    }
                    return false;
                }, {
                    layouts: RecordLayoutService.data.list
                });
                $scope.layout.type = $scope.types[0];
                if (cb !== null) {
                    cb.apply(null, []);
                }
            });
        };
        fetchTypes();
        UserService.getUserInfo(function(data) {
            $scope.layout.created.by = data;
            $scope.layout.updated.by = data;
            $scope.layout.checked_out.by = data;
        });
        $scope.preview = SegmentPreviewService.data;
        $scope.init_segments = {
            arc: [],
            drc: [],
            zrc: []
        };
        $scope.init_segments_selected = {
            arc: null,
            drc: null,
            zrc: null
        };
        RecordLayoutCommonService.getInitSegments(function(p) {
            $scope.init_segments.arc = p.arc;
            $scope.init_segments.drc = p.drc;
            $scope.init_segments.zrc = p.zrc;
            $scope.init_segments.arc = RecordLayoutCommonService.addChildrenProp($scope.init_segments.arc);
            $scope.init_segments.drc = RecordLayoutCommonService.addChildrenProp($scope.init_segments.drc);
            $scope.init_segments.zrc = RecordLayoutCommonService.addChildrenProp($scope.init_segments.zrc);
            $scope.init_segments_selected.arc = $scope.init_segments.arc[$scope.init_segments.arc.length - 1];
            $scope.init_segments_selected.drc = $scope.init_segments.drc[$scope.init_segments.drc.length - 1];
            $scope.init_segments_selected.zrc = $scope.init_segments.zrc[$scope.init_segments.zrc.length - 1];
            $scope.layout.segments.drc = angular.copy($scope.init_segments_selected.drc);
            $scope.segment = $scope.layout.segments.drc;
            $scope.$broadcast("drc-segment-loaded");
        });
        $scope.lockedMessage = function(is) {
            if (is) {
                return "Layout is locked!";
            }
            return "Layout is unlocked!";
        };
        $scope.checkedOutMessage = function(is) {
            if (is) {
                return "Layout is Checked Out!";
            }
            return "Layout is not Checked Out!";
        };
        $scope.createNewLayout = function() {
            RecordLayoutCommonService.create($scope.layout, $scope.init_segments_selected, function(layout) {
                RecordLayoutService.refresh(function(s) {
                    RecordLayoutService.select(layout);
                    NotificationQueue.push({
                        icon: "thumbs-up",
                        text: "Your Layout has been created!"
                    });
                    $scope.$emit("at-layout-change-to-edit-mode");
                });
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("newTypeModal", [ "DataTypeService", "RecordLayoutCommonService", function(DataTypeService, RecordLayoutCommonService) {
        return {
            templateUrl: "assets/templates/apps/data/metadatamanagement/recordlayoutmanagement/newType/_newTypeModal.html",
            controller: function($scope, $element) {
                $scope.types = [];
                $scope.type = {
                    name: null,
                    description: null
                };
                DataTypeService.onSummon(function() {
                    $element.find(".modal").modal();
                    RecordLayoutCommonService.getTypes(function(types) {
                        $scope.types = types;
                    });
                });
                $scope.createType = function() {
                    DataTypeService.create($scope.type, function(type) {
                        $element.find(".modal").modal("hide");
                        $scope.$broadcast("datatype-refresh", type);
                    });
                };
                $element.find(".modal").on("hidden.bs.modal", function() {
                    $scope.types = [];
                    $scope.type = {
                        name: null,
                        description: null
                    };
                });
            }
        };
    } ]);
    app.service("DataTypeService", [ "APIService", function(APIService) {
        var _onSummonCB;
        this.onSummon = function(cb) {
            _onSummonCB = cb;
        };
        this.summon = function() {
            _onSummonCB.apply(null, []);
        };
        this.checkUniqueName = function(name, cb) {
            APIService.get("datatype/is/unique/" + name).success(function(is) {
                cb.apply(null, [ is ]);
            });
        };
        this.create = function(type, cb) {
            APIService.put("datatype/new", type).success(function(t) {
                cb.apply(null, [ t ]);
            });
        };
    } ]);
    app.directive("atTypeNameInput", [ "DataTypeService", function(DataTypeService) {
        return {
            require: "ngModel",
            controller: function($scope, $element) {
                $scope._ctrl = null;
                var _prev = "";
                var toUpper = function() {
                    if ($scope.type.name !== null && $scope.type.name !== "") {
                        $scope.type.name = $scope.type.name.toUpperCase();
                    }
                };
                var toThree = function() {
                    if ($scope.type.name.length > 3) {
                        $scope.type.name = $scope.type.name.slice(0, 3);
                    }
                };
                var toUnique = function() {
                    if ($scope.type.name.length === 3 && $scope.type.name !== _prev) {
                        _prev = $scope.type.name;
                        DataTypeService.checkUniqueName($scope.type.name, function(is) {
                            $scope._ctrl.$setValidity("unique", is);
                        });
                    }
                };
                $scope.checkName = function() {
                    if (angular.isDefined($scope.type.name) && $scope.type.name.hasOwnProperty("length")) {
                        toUpper();
                        toThree();
                        toUnique();
                    }
                };
            },
            link: function(scope, element, attr, c) {
                scope._ctrl = c;
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atSegmentPicker", [ "SegmentListService", function(SegmentListService) {
        return {
            restrict: "A",
            templateUrl: "assets/templates/apps/data/metadatamanagement/recordlayoutmanagement/picker/_atSegmentPicker.html",
            scope: {},
            link: function(scope, element, attrs) {
                var parent_height = $("#segment-list-panel").outerHeight();
                var header_height = element.parent().prev().outerHeight();
                element.css({
                    height: parent_height - header_height
                });
            },
            controller: function($scope, $element) {
                $scope.$on("preview-changed", function(e, name) {
                    $scope.segments.map(function(s) {
                        if (s.name !== this.name) {
                            s.previewing = false;
                        }
                        return s;
                    }, {
                        name: name
                    });
                });
                $scope.segments = [];
                SegmentListService.getListForLayout(function(segments) {
                    for (var i in segments) {
                        var _seg = segments[i];
                        if (_seg.name.substr(0, 3) === "ARC" || _seg.name.substr(0, 3) === "DRC" || _seg.name.substr(0, 3) === "ZRC") {
                            _seg.show_in_list = false;
                        } else {
                            _seg.show_in_list = true;
                            if (_seg.has_many_versions === false) {
                                _seg.versions = [];
                                _seg.versions.push({
                                    id: {
                                        name: _seg.name,
                                        version: _seg.version
                                    },
                                    name: (parseInt(_seg.version) / 100).toString()
                                });
                                _seg.has_many_versions = true;
                            } else {
                                _seg.versions.map(function(s) {
                                    s.id = {
                                        name: s.name,
                                        version: s.version
                                    };
                                    s.name = (parseInt(s.version) / 100).toString();
                                    delete s["version"];
                                    return s;
                                });
                            }
                            _seg.versions.push({
                                id: {
                                    name: _seg.versions[_seg.versions.length - 1].name,
                                    version: 0
                                },
                                name: "Latest"
                            });
                        }
                    }
                    $scope.segments = segments;
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atSegmentPickerSegment", [ "SegmentPreviewService", "SegmentListService", "SegmentGrabService", "$document", function(SegmentPreviewService, SegmentListService, SegmentGrabService, $document) {
        return {
            require: "^atSegmentPicker",
            scope: {
                segment: "="
            },
            templateUrl: "assets/templates/apps/data/metadatamanagement/recordlayoutmanagement/picker/_atSegmentPickerSegment.html",
            controller: function($scope, $element) {
                $scope.segment.previewing = false;
                var _dragObject = {
                    e: null,
                    start: {
                        x: 0,
                        y: 0
                    },
                    current: {
                        x: 0,
                        y: 0
                    },
                    offset: {
                        x: 5,
                        y: -10
                    }
                };
                if ($scope.segment.has_many_versions) {
                    $scope.segment.other_version_select = $scope.segment.versions[$scope.segment.versions.length - 1];
                }
                $scope.previewMe = function(segment) {
                    SegmentPreviewService.set(segment);
                };
                $scope.onGrab = function(e) {
                    e.preventDefault();
                    if ($scope.segment.other_version_select.name !== "Latest") {
                        SegmentListService.fetchByNameAndVersion($scope.segment.other_version_select.id.name, $scope.segment.other_version_select.id.version, function(segment) {
                            segment.latest = false;
                            SegmentGrabService.grab(segment);
                        }, false);
                    } else {
                        SegmentListService.fetchLatestSegment($scope.segment.name + " - ", function(segment) {
                            segment.latest = true;
                            SegmentGrabService.grab(segment);
                        }, false);
                    }
                    _dragObject.e = $('<div id="segment-drag">' + $scope.segment.name + "</div>");
                    _dragObject.start.x = e.pageX + _dragObject.offset.x;
                    _dragObject.start.y = e.pageY + _dragObject.offset.y;
                    _dragObject.e.css({
                        top: _dragObject.start.y,
                        left: _dragObject.start.x
                    });
                    $("html").addClass("dragging-something");
                    $element.append(_dragObject.e);
                    $document.on("mousemove", mouseMove);
                    $document.on("mouseup", mouseUp);
                };
                function mouseMove(e) {
                    _dragObject.current.x = e.pageX + _dragObject.offset.x;
                    _dragObject.current.y = e.pageY + _dragObject.offset.y;
                    _dragObject.e.css({
                        top: _dragObject.current.y + "px",
                        left: _dragObject.current.x + "px"
                    });
                }
                function mouseUp(e) {
                    $scope.$apply(function() {
                        SegmentGrabService.drop();
                    });
                    _dragObject.e.remove();
                    $("html").removeClass("dragging-something");
                    $(".over-dropzone").removeClass("over-dropzone");
                    $document.off("mousemove", mouseMove);
                    $document.off("mouseup", mouseUp);
                }
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atSegmentPreview", [ "SegmentPreviewService", function(SegmentPreviewService) {
        return {
            restrict: "A",
            templateUrl: "assets/templates/apps/data/metadatamanagement/recordlayoutmanagement/preview/_atSegmentPreview.html",
            controller: function($scope, $element) {
                $scope.displaying = false;
                $scope.preview = null;
                SegmentPreviewService.onChange(function(segment) {
                    $scope.$broadcast("preview-changed", segment.name);
                    $scope.preview = segment;
                });
            },
            link: function(scope, element, attrs) {
                var $rows = element.find(".preview-wrapper:first-child > .row");
                var rowsHeight = $($rows[0]).height() + $($rows[1]).height();
                var wrapperHeight = element.find(".preview-wrapper").height();
                var headerRowHeight = element.find(".field-list > .row").height();
                element.find(".field-list .scroll-rows").css({
                    height: parseInt(wrapperHeight) - (parseInt(rowsHeight) + parseInt(headerRowHeight))
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("SegmentPreviewService", [ "SegmentListService", function(SegmentListService) {
        var eventChange = null;
        this.set = function(s) {
            s.previewing = true;
            SegmentListService.fetchByNameAndVersion(s.name, s.other_version_select.id.version, function(segment) {
                eventChange.apply(null, [ segment ]);
            });
        };
        this.onChange = function(cb) {
            eventChange = cb;
        };
    } ]);
    app.service("SegmentGrabService", [ function() {
        this.data = {
            segment: null,
            dragging: false,
            over: null
        };
        this.timeout = {
            count: 0
        };
        this.segments = {
            count: 0
        };
        this.segmentsLocation = {
            segments: []
        };
        this.listeners = [];
        var redoCount = 0;
        this.over = function(segment) {
            if (segment === null) {
                this.data.over = null;
                return;
            }
            if (this.data.over === null) {
                this.data.over = segment;
                return;
            }
            if (this.data.over !== null && this.data.over.$element_id !== segment.$element_id) {
                this.data.over = segment;
                return;
            }
        };
        this.on = function(action, data, cb) {
            this.listeners.push({
                action: action,
                "do": cb,
                data: data
            });
        };
        this.grab = function(segment) {
            this.over(null);
            this.data.dragging = true;
            this.data.segment = {
                id: segment.id,
                name: segment.name,
                version: segment.version,
                latest: segment.latest,
                children: []
            };
            this._do("grab", this.data.segment);
        };
        this.drop = function() {
            this.data.dragging = false;
            if (this.data.over !== null && this.data.segment !== null) {
                this.data.over.children.push(this.data.segment);
                this._do("successfullDrop", this.data.over.children[this.data.over.children.length - 1]);
            }
            this.data.segment = null;
            this._do("drop");
        };
        this.redoDropzone = function(reset) {
            reset = reset || false;
            if (reset) {
                redoCount = 0;
            }
            if (redoCount < 2) {
                for (var i in this.segmentsLocation.segments) {
                    for (var id in this.segmentsLocation.segments[i]) {
                        var seg = {};
                        if ($("#" + id).length !== 0) {
                            $main = $("#" + id).find(".segment-main:first");
                            seg[id] = {
                                top: $main.offset().top,
                                bottom: $main.offset().top + $main.outerHeight(),
                                left: $main.offset().left,
                                right: $main.offset().left + $main.outerWidth()
                            };
                            this.segmentsLocation.segments[i] = seg;
                        } else {
                            this.segmentsLocation.segments.splice(i, 1);
                        }
                    }
                }
                redoCount++;
            }
        };
        this._do = function(action, data) {
            data = data || null;
            for (var i in this.listeners) {
                if (this.listeners[i].action === action) {
                    this.listeners[i]["do"](data, this.listeners[i].data);
                }
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var ReformatterController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function ReformatterController($scope) {
            this.$scope = $scope;
            this._initValues();
            this._initScopeValues();
            this._setupScopeMethods();
        }
        DP$0(ReformatterController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._initValues = function() {
            this._baseTemplateLocation = "assets/templates/apps/data/metadatamanagement/{PERSPECTIVE}/{ACTION}/_main.html";
            this._perspective = "Reformatter";
        };
        proto$0._getTemplate = function(action) {
            return this._baseTemplateLocation.replace(/\{PERSPECTIVE\}/g, this._perspective.toLowerCase()).replace(/\{ACTION\}/g, action.toLowerCase() + this._perspective);
        };
        proto$0._setView = function(action) {
            this.$scope.current_view = this._getTemplate(action);
        };
        proto$0._initScopeValues = function() {
            this.$scope.reformatterList = [];
            this.$scope.current_view = null;
        };
        proto$0._setupScopeMethods = function() {
            var self = this;
            this.$scope.loaded = true;
            this.$scope.newReformatter = function() {
                self.createNewReformatter();
            };
            this.$scope.selectReformatter = function(item) {
                self.selectReformatter(item);
            };
        };
        proto$0.createNewReformatter = function() {
            this._setView("new");
        };
        proto$0.selectReformatter = function(item) {};
        MIXIN$0(ReformatterController.prototype, proto$0);
        proto$0 = void 0;
        return ReformatterController;
    }();
    app.controller("ReformatterController", [ "$scope", ReformatterController ]);
})();

(function() {
    var PRS$0 = function(o, t) {
        o["__proto__"] = {
            a: t
        };
        return o["a"] === t;
    }({}, {});
    var DP$0 = Object.defineProperty;
    var GOPD$0 = Object.getOwnPropertyDescriptor;
    var MIXIN$0 = function(t, s) {
        for (var p in s) {
            if (s.hasOwnProperty(p)) {
                DP$0(t, p, GOPD$0(s, p));
            }
        }
        return t;
    };
    var app = angular.module("atUI");
    var NewReformatterController = function() {
        "use strict";
        var proto$0 = {};
        function NewReformatterController($scope, $element, $attrs, RecordLayoutService, APIService, RecordLayoutUtilityService, PlatformService, $compile) {
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            this.RecordLayoutService = RecordLayoutService;
            this.APIService = APIService;
            this.RecordLayoutUtilityService = RecordLayoutUtilityService;
            this.PlatformService = PlatformService;
            this.$compile = $compile;
            this._initValues();
            this._initScopeValues();
            this._setupScopeMethods();
            this._initHeights();
        }
        DP$0(NewReformatterController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._initHeights = function() {
            this.$element.css("height", $(this.$attrs.newReformatter).outerHeight());
            var height = this.$element.find(".bottom-section").outerHeight();
            var total = this.$element.outerHeight();
            var full = total - height;
            this.$element.find(".top-section").css("height", full);
            var $panels = this.$element.find(".panels");
            var $panel = $panels.find(".panel").filter(":first");
            var heightDiff = parseInt($panel.outerHeight()) - parseInt($panel.height());
            var endHeight = full - heightDiff - parseInt($panel.find(".panel-heading").outerHeight()) - 20;
            this.$scope.heights = {
                height: endHeight
            };
            var $top = this.$element.find(".top-of-format");
            var topHeight = parseInt($top.outerHeight());
            this.$scope.tableHeight = {
                height: full - topHeight - 22 - 66
            };
        };
        proto$0._initValues = function() {
            this._template = null;
        };
        proto$0._initScopeValues = function() {
            var self = this;
        };
        proto$0._setupScopeMethods = function() {
            var self = this;
            this.$scope.dropzoneClose = false;
            this.$scope.templateHeader = [];
            this.$scope.template = [];
            this.$scope.heights = {};
            this.$scope.tableHeight = {};
            this.$scope.layoutChosen = false;
            this.$scope.templateReady = false;
            this.$scope.layouts = [];
            this.$scope.layout = {};
            this.$scope.layoutSelected = null;
            this.$scope.dropzoneConfig = {
                dictDefaultMessage: "- Drop template file here -",
                acceptedFiles: ".csv",
                accept: function(file, done) {
                    self.addedFile(file);
                    done("");
                },
                init: function() {
                    var dz = this;
                    this.on("error", function(file, err) {
                        dz.removeFile(file);
                        dz.disable();
                        self.$scope.$apply(function() {
                            self.$scope.dropzoneClose = true;
                        });
                    });
                }
            };
            this.RecordLayoutService.getList(function(layouts) {
                self.$scope.layouts = layouts;
            });
            this.$scope.selectLayout = function(layout) {
                self.selectLayout(layout);
            };
        };
        proto$0.selectLayout = function(layout) {
            var self = this;
            this.$scope.layoutChosen = true;
            this.$scope.layoutSelected = layout;
            this.APIService.get("layout/latest/" + layout.id + "/p/" + this.PlatformService.current.id).success(function(l) {
                self.APIService.get("layout/segments/" + l.id).success(function(segments) {
                    self.$scope.layout = self.RecordLayoutUtilityService._initLayout(segments);
                    self._render();
                });
            });
        };
        proto$0._render = function() {
            var dom = "<div reformat-item></div>";
            var newScope = this.$scope.$new();
            newScope.item = this.$scope.layout;
            newScope.deploymentID = this.PlatformService.current.id;
            var $dom = this.$compile(dom)(newScope);
            this.$element.find(".layout-panel").append($dom);
        };
        proto$0._setTemplate = function(text) {
            this._template = text;
            this._readTemplate();
        };
        proto$0._readTemplate = function() {
            var t = this._template.split("\n");
            var header = t.shift();
            this.$scope.templateHeader = header.split(",").map(function(e) {
                return e.trim();
            });
            this.$scope.templateHeader.push("Maps to");
            this.$scope.templateHeader.push("Trans. Rule");
            for (var i in t) {
                var row = t[i].split(",").map(function(e) {
                    return e.trim();
                });
                this.$scope.template.push(row);
            }
            this._renderTable();
            this.$scope.templateReady = true;
        };
        proto$0._renderTable = function() {
            var dom = "<tr reformat-table-row></tr>";
            var tbody = this.$element.find(".format-panel tbody");
            for (var i in this.$scope.template) {
                var newScope = this.$scope.$new();
                newScope.row = this.$scope.template[i];
                var $dom = this.$compile(dom)(newScope);
                tbody.append($dom);
            }
        };
        proto$0.addedFile = function(file) {
            var self = this;
            var reader = new FileReader();
            reader.readAsText(file);
            reader.onload = function(e) {
                self._setTemplate(e.target.result);
            };
        };
        MIXIN$0(NewReformatterController.prototype, proto$0);
        proto$0 = void 0;
        return NewReformatterController;
    }();
    app.directive("newReformatter", [ function() {
        return {
            controller: [ "$scope", "$element", "$attrs", "RecordLayoutService", "APIService", "RecordLayoutUtilityService", "PlatformService", "$compile", NewReformatterController ]
        };
    } ]);
    var DragService = function() {
        "use strict";
        var proto$0 = {};
        function DragService() {
            this._init();
        }
        DP$0(DragService, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            this._holding = null;
        };
        proto$0.holdThis = function(item) {
            this._holding = item;
        };
        proto$0.drop = function() {
            if (this._holding === null) {
                return null;
            }
            var item = this._holding.item;
            this._holding = null;
            return item;
        };
        MIXIN$0(DragService.prototype, proto$0);
        proto$0 = void 0;
        return DragService;
    }();
    app.service("DragService", [ DragService ]);
    var DraggingObjectController = function() {
        "use strict";
        var proto$0 = {};
        function DraggingObjectController($scope, $element, $document) {
            this.$scope = $scope;
            this.$element = $element;
            this.$document = $document;
            this._init();
        }
        DP$0(DraggingObjectController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.pos = {
                top: 0,
                left: 0
            };
            this.$scope.c = {
                offset: {
                    x: 5,
                    y: -10
                }
            };
            this.$scope.pos.left = this.$scope.event.pageX + this.$scope.c.offset.x;
            this.$scope.pos.top = this.$scope.event.pageY + this.$scope.c.offset.y;
            this.$document.on("mousemove", function(e) {
                self.mouseMove(e);
            });
            this.$document.on("mouseup", function(e) {
                self.mouseUp(e);
            });
            this.$scope.$on("$destroy", function() {
                self.$document.off("mousemove");
                self.$document.off("mouseup");
            });
        };
        proto$0.mouseMove = function(e) {
            var self = this;
            this.$scope.$apply(function() {
                self.$scope.pos.left = e.pageX + self.$scope.c.offset.x;
                self.$scope.pos.top = e.pageY + self.$scope.c.offset.y;
            });
        };
        proto$0.mouseUp = function(e) {
            this.$element.remove();
            $("html").removeClass("dragging-something");
        };
        MIXIN$0(DraggingObjectController.prototype, proto$0);
        proto$0 = void 0;
        return DraggingObjectController;
    }();
    app.directive("draggingObject", [ function() {
        return {
            template: "{{label}}",
            controller: [ "$scope", "$element", "$document", DraggingObjectController ],
            link: function(scope, element) {}
        };
    } ]);
    var ReformatItemController = function() {
        "use strict";
        var proto$0 = {};
        function ReformatItemController($scope, $element, APIService, DragService, $compile) {
            this.$scope = $scope;
            this.$element = $element;
            this.APIService = APIService;
            this.DragService = DragService;
            this.$compile = $compile;
            this._init();
        }
        DP$0(ReformatItemController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.fields = [];
            this.$scope.exploded = false;
            this.openSegment();
            this.$scope.grabField = function($event, field) {
                self.grabField($event, field);
            };
        };
        proto$0.grabField = function($event, field) {
            $("html").addClass("dragging-something");
            this.DragService.holdThis({
                event: $event,
                item: field
            });
            var dom = '<div dragging-object ng-style="pos"></div>';
            var newScope = this.$scope.$new();
            newScope.label = field.segmentName + "." + field.name;
            newScope.event = $event;
            var $dom = this.$compile(dom)(newScope);
            this.$element.append($dom);
        };
        proto$0.openSegment = function() {
            var self = this;
            this.APIService.get("segment/latest/" + this.$scope.item.name + "/p/" + this.$scope.deploymentID, {
                raw: true
            }).success(function(data) {
                self.$scope.fields = data[3];
            });
            this.$scope.toggleOpen = function() {
                self.toggleOpen();
            };
        };
        proto$0.toggleOpen = function() {
            this.$scope.exploded = !this.$scope.exploded;
        };
        MIXIN$0(ReformatItemController.prototype, proto$0);
        proto$0 = void 0;
        return ReformatItemController;
    }();
    app.directive("reformatItem", [ "$compile", function($compile) {
        return {
            templateUrl: "assets/templates/apps/data/metadatamanagement/reformatter/reformatItem.html",
            controller: [ "$scope", "$element", "APIService", "DragService", "$compile", ReformatItemController ],
            link: function(scope, element) {
                this._render = function(item) {
                    var dom = "<div reformat-item></div>";
                    var newScope = scope.$new();
                    newScope.item = item;
                    newScope.deploymentID = scope.deploymentID;
                    var $dom = $compile(dom)(newScope);
                    element.find(".children").append($dom);
                };
                if (scope.item.children.length > 0) {
                    for (var i in scope.item.children) {
                        this._render(scope.item.children[i]);
                    }
                }
            }
        };
    } ]);
    app.directive("heightOf", [ function() {
        return {
            link: function(scope, element, attrs) {
                var $ref = $(attrs.heightOf);
                element.css("height", $ref.outerHeight());
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var ReformatTableRowController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function ReformatTableRowController($scope, $element, DragService) {
            this.$scope = $scope;
            this.$element = $element;
            this.DragService = DragService;
            this._init();
        }
        DP$0(ReformatTableRowController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this.$scope.mappedTo = null;
            this.$scope.isOver = false;
            this.$scope.mouseUp = function() {
                self.mouseUp();
            };
        };
        proto$0.mouseUp = function() {
            this.$scope.mappedTo = this.DragService.drop();
            if (this.$scope.mappedTo !== null) {
                this.$scope.mappedTo.__NAME = this.$scope.mappedTo.segmentName + "." + this.$scope.mappedTo.name;
            }
        };
        MIXIN$0(ReformatTableRowController.prototype, proto$0);
        proto$0 = void 0;
        return ReformatTableRowController;
    }();
    app.directive("reformatTableRow", [ function() {
        return {
            templateUrl: "assets/templates/apps/data/metadatamanagement/reformatter/tablerow/reformatTableRow.html",
            controller: [ "$scope", "$element", "DragService", ReformatTableRowController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atSegmentFields", [ "$timeout", "LoadingScreenService", function($timeout, LoadingScreenService) {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                LoadingScreenService.show();
                $timeout(function() {
                    var $side = $("#segment-list-viewer");
                    var $panel = $(".panel");
                    var $button = $("#segment-create-button");
                    var segHeight = $side.outerHeight() - (element.offset().top - $side.offset().top) - (parseInt($panel.css("margin-bottom")) + parseInt($panel.css("border-bottom-width")) + $button.outerHeight());
                    element.css({
                        height: segHeight
                    });
                    $timeout(function() {
                        LoadingScreenService.hide();
                    }, 200);
                }, 1300);
            }
        };
    } ]);
    app.directive("atSegmentNewField", [ function() {
        return {
            restrict: "A",
            scope: {
                field: "=",
                lookupDataset: "=",
                newAction: "=",
                first: "=",
                last: "=",
                readStatus: "=isReadOnly",
                editMode: "="
            },
            templateUrl: "assets/templates/apps/data/metadatamanagement/segmentmanagement/_atSegmentNewField.html",
            controller: function($scope) {
                $scope.types = [ "SHORT", "INTEGER", "LONG", "STRING", "DATE" ];
                var typeLengths = {
                    SHORT: 5,
                    INTEGER: 11,
                    LONG: 20,
                    STRING: 50,
                    DATE: 8
                };
                if ($scope.field.dataTypeName === null || $scope.field.dataTypeName === "") {
                    $scope.field.dataTypeName = "STRING";
                    $scope.field.length = typeLengths[$scope.field.dataTypeName];
                }
                if ($scope.field.dataTypeName !== null && $scope.field.dataTypeName !== "" && ($scope.field.length === null || $scope.field.length === "")) {
                    $scope.field.length = typeLengths[$scope.field.dataTypeName];
                }
                if ($scope.editMode === null || $scope.editMode === "") {
                    $scope.editMode = false;
                }
                $scope.setDefaultLength = function() {
                    $scope.field.length = typeLengths[$scope.field.dataTypeName];
                };
                if ($scope.field.fieldNumber === null || $scope.field.fieldNumber === "") {
                    var fields = $scope.$parent.$parent.segment.fields;
                    var hiNumber = 0;
                    for (var i in fields) {
                        if (parseInt(fields[i].fieldNumber) > hiNumber) {
                            hiNumber = parseInt(fields[i].fieldNumber);
                        }
                    }
                    $scope.field.fieldNumber = hiNumber + 1;
                }
                $scope.removeField = function() {
                    var fields = $scope.$parent.$parent.segment.fields;
                    for (i in fields) {
                        if ($scope.field.fieldNumber === fields[i].fieldNumber) {
                            fields.splice(i, 1);
                            break;
                        }
                    }
                };
            },
            link: function(scope, element, attrs) {
                if (scope.last && !scope.first) {
                    element.find(".field-name").focus();
                    element.find(".field-lookup").on("blur", function() {
                        if (scope.field.name !== "" && scope.field.name !== null) {
                            scope.$apply(function() {
                                scope.newAction();
                            });
                        }
                    });
                }
            }
        };
    } ]);
    app.directive("atFieldValidationNumber", [ function() {
        return {
            restrict: "A",
            scope: {
                "in": "=in"
            },
            link: function(scope, element, attrs) {
                scope.$watch("in", function(newValue, oldValue) {
                    var v = element.val();
                    if (isNaN(v)) {
                        element.val("");
                        scope.in = null;
                    }
                });
            }
        };
    } ]);
    app.directive("atFieldValidationMaxLength", [ function() {
        return {
            restrict: "A",
            scope: {
                "in": "=in",
                limit: "=max"
            },
            link: function(scope, element, attrs) {
                scope.$watch("in", function(newValue, oldValue) {
                    var v = element.val();
                    if (v.length > parseInt(scope.limit)) {
                        var n = v.slice(0, scope.limit);
                        element.val(n);
                        scope.in = n;
                    }
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("EditSegmentController", [ "$scope", "AlertMessageService", "UserService", "LookupDatasetService", "APIService", "SegmentListService", "NotificationQueue", "UndoService", "hotkeys", "SegmentService", "ModalService", function($scope, AlertMessageService, UserService, LookupDatasetService, APIService, SegmentListService, NotificationQueue, UndoService, hotkeys, SegmentService, ModalService) {
        $scope.ready = false;
        $scope.cloneInProgress = false;
        $scope.segment = null;
        $scope.lookupDataset = LookupDatasetService.data;
        $scope.readStatus = {
            amIReadOnly: false
        };
        $scope.user = null;
        $scope.loadedView = null;
        hotkeys.bindTo($scope).add({
            combo: "alt+1",
            description: "Add new field row",
            callback: function() {
                $scope.addNewField();
            }
        });
        var getVersions = function() {
            SegmentService.getVersions($scope.segment.name, function(versions) {
                if (versions.length > 1) {
                    $scope.segment.versions = versions.map(function(a) {
                        return {
                            id: a.id,
                            name: parseFloat(a.version / 100)
                        };
                    });
                    $scope.segment.has_many_versions = true;
                }
                $scope.ready = true;
            });
        };
        if (SegmentListService.data.selectedByID === null) {
            SegmentListService.fetchLatestSegment(SegmentListService.getSelected().name, function(segment) {
                $scope.segment = segment;
                getVersions();
            });
        } else {
            SegmentListService.fetchByID(SegmentListService.data.selectedByID, function(segment) {
                $scope.segment = segment;
                getVersions();
            });
        }
        LookupDatasetService.refresh();
        var unWatch = $scope.$watch("ready", function(newValue, oldValue) {
            if (newValue === true) {
                init();
                $scope.loadedView = "assets/templates/apps/data/metadatamanagement/segmentmanagement/_loadedEditSegmentView.html";
            }
        });
        var init = function() {
            unWatch();
            if ($scope.segment.hasOwnProperty("versions")) {
                var version_i = $scope.segment.versions.length - 1;
                for (var i in $scope.segment.versions) {
                    if ($scope.segment.versions[i].id === $scope.segment.id) {
                        version_i = i;
                        break;
                    }
                }
                $scope.version_data = {
                    other_version: $scope.segment.versions[version_i]
                };
                $scope.$watch("version_data.other_version", function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                        SegmentListService.data.selectedByID = $scope.version_data.other_version.id;
                        $scope.$emit("at-change-to-edit-mode");
                    }
                });
            }
            $scope.$watch("segment.locked", function(newValue, oldValue) {
                if (newValue !== oldValue) {
                    isReadOnly();
                }
            });
            var _removeFieldsUndoCache = null;
            $scope.$watchCollection("segment.fields", function(newValue, oldValue) {
                if (newValue.length !== oldValue.length && newValue.length < oldValue.length) {
                    _removeFieldsUndoCache = oldValue;
                    UndoService.triggerMessage("Removed field from segment.").onUndo(function() {
                        $scope.segment.fields = _removeFieldsUndoCache;
                    }).onDismiss(function() {
                        _removeFieldsUndoCache = null;
                    });
                }
            });
            isReadOnly();
            UserService.getUserInfo(function(user) {
                $scope.user = user;
            });
        };
        isReadOnly = function() {
            UserService.getUserInfo(function(user) {
                if ($scope.segment.locked.is) {
                    $scope.readStatus.amIReadOnly = true;
                    return true;
                }
                if ($scope.segment.checked_out.is) {
                    if (parseInt($scope.segment.checked_out.by.userID) !== parseInt(user.userID)) {
                        $scope.readStatus.amIReadOnly = true;
                        return true;
                    }
                }
                $scope.readStatus.amIReadOnly = false;
            });
        };
        $scope.canIUpdate = function() {
            if (!$scope.ready) {
                return !false;
            }
            if ($scope.readStatus.amIReadOnly) {
                return !false;
            }
            if ($scope.segment.name !== null && $scope.segment.name !== "") {
                if ($scope.segment.version !== null && $scope.segment.version !== "") {
                    if ($scope.segment.shortDescription !== null && $scope.segment.shortDescription !== "") {
                        if ($scope.segment.fields[0].name !== null && $scope.segment.fields[0].name !== "") {
                            return !true;
                        }
                    }
                }
            }
            return !false;
        };
        $scope.cloneVersion = function() {
            AlertMessageService.showQuestion("Hold on!", "This will create a new version of this segment. Is that ok?", [ {
                label: "Yes",
                "class": "btn-primary",
                action: function() {
                    doVersionClone();
                },
                dismiss: true
            }, {
                label: "Cancel",
                "class": "btn-default",
                action: function() {},
                dismiss: true
            } ]);
        };
        var doVersionClone = function() {
            if ($scope.cloneInProgress === false) {
                $scope.cloneInProgress = true;
                UserService.getUserInfo(function(user) {
                    var now = moment().format("MM/DD/YYYY");
                    var new_segment = angular.copy($scope.segment);
                    delete new_segment["id"];
                    delete new_segment["has_many_versions"];
                    delete new_segment["isSelected"];
                    delete new_segment["show_in_list"];
                    delete new_segment["versions"];
                    new_segment.checked_out = {
                        is: true,
                        by: user,
                        on: now
                    };
                    new_segment.locked = {
                        is: false,
                        by: null,
                        on: null
                    };
                    new_segment.created = {
                        by: user,
                        on: now
                    };
                    new_segment.updated = {
                        by: user,
                        on: now
                    };
                    new_segment.version = -1;
                    SegmentService.create(new_segment).success(function(data) {
                        SegmentListService.refresh(function(s) {
                            NotificationQueue.push({
                                icon: "thumbs-up",
                                text: "New version was created!"
                            });
                            $scope.$emit("at-change-to-edit-mode");
                            $scope.cloneInProgress = false;
                        });
                    }).error(function(err) {
                        $scope.cloneInProgress = false;
                        AlertMessageService.showError("Unable to create segment version!");
                    });
                });
            }
        };
        $scope.addNewField = function() {
            if (!$scope.readStatus.amIReadOnly) {
                $scope.segment.fields.push({
                    name: null,
                    fieldNumber: null,
                    description: null,
                    dataTypeName: null,
                    length: null,
                    codetableName: null
                });
            }
        };
        $scope.updateSegment = function() {
            $scope.segment.updated.on = moment().format("MM/DD/YYYY");
            SegmentService.update($scope.segment).success(function(data) {
                SegmentListService.refresh(function(s) {
                    SegmentListService.select($scope.segment);
                    NotificationQueue.push({
                        icon: "thumbs-up",
                        text: "Your Segment has been updated!"
                    });
                    $scope.$emit("at-change-to-edit-mode");
                });
            }).error(function(err) {
                AlertMessageService.showError("Unable to update segment! [" + err + "]");
            });
        };
        $scope.segmentLockedMessage = function(is) {
            if (is) {
                return "Segment is Locked!";
            }
            return "Segment is Unlocked!";
        };
        $scope.segmentCheckedOutMessage = function(is) {
            if (is) {
                return "Segment is Checked Out!";
            }
            return "Segment is not Checked Out!";
        };
        $scope.lockSegment = function() {
            UserService.getUserInfo(function(user) {
                SegmentService.lock({
                    id: $scope.segment.id,
                    userID: user.userID
                }).success(function(userID) {
                    UserService.getUser(userID, function(user) {
                        $scope.segment.locked = {
                            is: true,
                            on: moment().format("MM/DD/YYYY"),
                            by: user
                        };
                    });
                    NotificationQueue.push({
                        icon: "thumbs-up",
                        text: "Segment is now locked!"
                    });
                }).error(function(status) {
                    AlertMessageService.showError("Oh no!", "Unable to lock segment!");
                });
            });
        };
        $scope.dependentLayouts = [];
        $scope.deleteSegment = function() {
            SegmentService.checkForDelete($scope.segment, function(data) {
                if (data !== null && data.length > 0) {
                    $scope.dependentLayouts = data;
                    ModalService.summon("segment-dependent-modal");
                } else {
                    SegmentService.deleteSegment($scope.segment, function() {
                        NotificationQueue.push({
                            icon: "thumbs-up",
                            text: "Segment was deleted!"
                        });
                        $scope.reset();
                    });
                }
            });
        };
        $scope.reset = function() {
            $scope.$emit("at-segment-reset");
        };
        $scope.checkIn = function(cb) {
            checkSegment("in", cb);
        };
        $scope.checkOut = function(cb) {
            checkSegment("out", cb);
        };
        var checkSegment = function(direction, cb) {
            UserService.getUserInfo(function(user) {
                SegmentService.check(direction, {
                    id: $scope.segment.id,
                    userID: user.userID
                }).success(function(data) {
                    UserService.getUser(data.userID, function(user) {
                        $scope.segment.checked_out = {
                            is: data.is,
                            on: moment().format("MM/DD/YYYY"),
                            by: user
                        };
                    });
                    NotificationQueue.push({
                        icon: "thumbs-up",
                        text: "Segment is now checked " + direction + "!"
                    });
                    cb();
                }).error(function(status) {
                    cb();
                    AlertMessageService.showError("Oh no!", "Unable to check " + direction + "! [" + status + "]");
                });
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("LookupDatasetService", [ "APIService", "AlertMessageService", function(APIService, AlertMessageService) {
        this.data = {
            cache: []
        };
        this.refresh = function(cb) {
            cb = cb || null;
            var ref = this;
            APIService.get("codes/distinct").success(function(data) {
                ref.data.cache = data;
                if (cb !== null) {
                    cb(true);
                }
            }).error(function(err, status) {
                AlertMessageService.showError("Oh no!", "Unable to fetch lookup dataset! [" + status + "]");
                if (cb !== null) {
                    cb(false);
                }
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("NewSegmentController", [ "$scope", "AlertMessageService", "UserService", "LookupDatasetService", "APIService", "SegmentListService", "NotificationQueue", "SegmentService", function($scope, AlertMessageService, UserService, LookupDatasetService, APIService, SegmentListService, NotificationQueue, SegmentService) {
        var nowNow = moment().format("MM/DD/YYYY");
        $scope.segment = {
            name: null,
            shortDescription: null,
            version: "0.1",
            description: null,
            fields: [ {
                name: null,
                fieldNumber: null,
                description: null,
                dataTypeName: "STRING",
                length: null,
                codetableName: null
            } ],
            created: {
                on: nowNow,
                by: null
            },
            updated: {
                on: nowNow,
                by: null
            },
            locked: {
                is: false,
                on: null,
                by: null
            },
            checked_out: {
                is: true,
                on: nowNow,
                by: null
            }
        };
        $scope.lookupDataset = LookupDatasetService.data;
        LookupDatasetService.refresh();
        $scope.canCreate = function() {
            if ($scope.UniqueSegmentNameForm.$invalid) {
                return !false;
            }
            if (angular.isDefined($scope.segment.name) && $scope.segment.name !== null && $scope.segment.name !== "") {
                if (angular.isDefined($scope.segment.version) && $scope.segment.version !== null && $scope.segment.version !== "") {
                    if (angular.isDefined($scope.segment.shortDescription) && $scope.segment.shortDescription !== null && $scope.segment.shortDescription !== "") {
                        if (angular.isDefined($scope.segment.fields[0].name) && $scope.segment.fields[0].name !== null && $scope.segment.fields[0].name !== "") {
                            return !true;
                        }
                    }
                }
            }
            return !false;
        };
        $scope.addNewField = function() {
            $scope.segment.fields.push({
                name: null,
                fieldNumber: null,
                description: null,
                dataTypeName: null,
                length: null,
                codetableName: null
            });
        };
        $scope.createNewSegment = function() {
            SegmentService.create($scope.segment).success(function(data) {
                SegmentListService.refresh(function(s) {
                    NotificationQueue.push({
                        icon: "thumbs-up",
                        text: "Your Segment has been created!"
                    });
                    SegmentListService.select($scope.segment);
                    $scope.$emit("at-change-to-edit-mode");
                });
            }).error(function(err) {
                AlertMessageService.showError("Unable to create segment! [" + err + "]");
            });
        };
        $scope.segmentLockedMessage = function(is) {
            if (is) {
                return "Segment is Locked!";
            }
            return "Segment is Unlocked!";
        };
        $scope.segmentCheckedOutMessage = function(is) {
            if (is) {
                return "Segment is Checked Out!";
            }
            return "Segment is not Checked Out!";
        };
        UserService.getUserInfo(function(data) {
            $scope.segment.created.by = data;
            $scope.segment.updated.by = data;
            $scope.segment.checked_out.by = data;
        });
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("SegmentManagementController", [ "$scope", "$timeout", "SegmentListService", "UserService", function($scope, $timeout, SegmentListService, UserService) {
        UserService.getUserInfo();
        $scope.segmentList = [];
        $scope.listLoaded = false;
        SegmentListService.onUpdate(function(segments) {
            $scope.segmentList = segments;
            $scope.listLoaded = true;
        });
        SegmentListService.refresh();
        $scope.current_view = null;
        $scope.newSegment = function() {
            SegmentListService.select(false);
            $scope.current_view = "assets/templates/apps/data/metadatamanagement/segmentmanagement/_newSegmentView.html";
        };
        $scope.selectSegment = function(segment) {
            SegmentListService.select(segment);
            $scope.$emit("at-change-to-edit-mode");
        };
        $scope.$on("at-change-to-edit-mode", function() {
            var s = SegmentListService.getSelected();
            $scope.current_view = "assets/templates/apps/data/metadatamanagement/segmentmanagement/_editSegmentView.html?s=" + s.name + "&t=" + moment().toISOString();
        });
        $scope.$on("at-segment-reset", function() {
            SegmentListService.refresh();
            $scope.current_view = null;
        });
    } ]);
    app.directive("atSegmentNameInput", [ "SegmentService", function(SegmentService) {
        return {
            require: "ngModel",
            controller: function($scope, $element) {
                $scope._ctrl = null;
                var _prev = "";
                var toUpper = function() {
                    if ($scope.segment.name !== null && $scope.segment.name !== "") {
                        $scope.segment.name = $scope.segment.name.toUpperCase();
                    }
                };
                var toThree = function() {
                    if ($scope.segment.name.length > 3) {
                        $scope.segment.name = $scope.segment.name.slice(0, 3);
                    }
                };
                var toUnique = function() {
                    if ($scope.segment.name.length === 3 && $scope.segment.name !== _prev) {
                        _prev = $scope.segment.name;
                        SegmentService.checkUniqueName($scope.segment.name, function(is) {
                            $scope._ctrl.$setValidity("unique", is);
                        });
                    }
                };
                $scope.checkName = function() {
                    if (angular.isDefined($scope.segment.name) && $scope.segment.name.hasOwnProperty("length")) {
                        toUpper();
                        toThree();
                        toUnique();
                    }
                };
            },
            link: function(scope, element, attr, c) {
                scope._ctrl = c;
            }
        };
    } ]);
    app.directive("atDateWidget", [ function() {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                var ref = this;
                this.applyModelChange = function(element) {
                    var $elem = $(element);
                    var model_name = $elem.attr("ng-model");
                    var s = model_name.split(".", 1);
                    scope.$apply(function() {
                        scope[s[0]][s[1]] = $elem.val();
                    });
                };
                element.datetimepicker({
                    pickTime: false
                }).on("dp.change", function(e) {
                    ref.applyModelChange(this);
                });
            }
        };
    } ]);
    app.directive("atLookupRefreshButton", [ "LookupDatasetService", function(LookupDatasetService) {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                element.on("click", function() {
                    element.find("i").removeClass("fa-exclamation-triangle").addClass("fa-refresh").addClass("fa-spin");
                    LookupDatasetService.refresh(function(success) {
                        if (success) {
                            element.find("i").removeClass("fa-spin").removeAttr("style");
                        } else {
                            element.find("i").removeClass("fa-spin fa-refresh").addClass("fa-exclamation-triangle").css({
                                color: "#D0C60D"
                            });
                        }
                    });
                });
            }
        };
    } ]);
    app.directive("atFullScreenButton", [ function() {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                element.on("click", function() {
                    if (element.find(".fa-expand").length > 0) {
                        element.find(".fa-expand").removeClass("fa-expand").addClass("fa-compress");
                        element.attr("title", "Compress");
                        element.closest(".panel").addClass("full-screen");
                    } else {
                        element.find(".fa-compress").removeClass("fa-compress").addClass("fa-expand");
                        element.attr("title", "Expand to full screen");
                        element.closest(".panel").removeClass("full-screen");
                    }
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("CodesService", [ "AjaxQueueService", "APIService", "PlatformService", function(AjaxQueueService, APIService, PlatformService) {
        var _BY_ID = "code/", _BY_NAME = "code/name/", _FETCH = "code", _FETCH_GROUPS = "code/groups", _SAVE = "code", _DELETE_GROUPING = "code/group/";
        AjaxQueueService.register("code");
        AjaxQueueService.turnOffCaching();
        this.fetchGroups = function(cb) {
            APIService.get(_FETCH_GROUPS + "/p/" + PlatformService.current.id).success(function(groups) {
                cb(groups);
            });
        };
        this.fetch = function(cb) {
            AjaxQueueService.addToQueue(_FETCH, "code", cb);
        };
        this.findById = function(id, cb) {
            AjaxQueueService.addToQueue(_BY_ID + id, "code", cb);
        };
        this.findByGroupingName = function(name, cb) {
            APIService.get(_BY_NAME + name + "/p/" + PlatformService.current.id).success(function(codes) {
                cb.apply(null, [ codes ]);
            });
        };
        this.clearCache = function() {
            AjaxQueueService.clearCache("code");
        };
        this.clearSpecificCache = function(call) {
            AjaxQueueService.clearSpecificCache("code", call);
        };
        this.save = function(codes, cb) {
            APIService.post(_SAVE, {
                codes: _preprocessCodes(codes.codes),
                deleted: _preprocessCodes(codes.deleted)
            }).success(function() {
                cb.apply(null, []);
            });
        };
        this.deleteGrouping = function(codeGroupName, cb) {
            APIService.delete(_DELETE_GROUPING + codeGroupName + "/p/" + PlatformService.current.id).success(function() {
                cb.apply(null, []);
            });
        };
        var _preprocessCodes = function(codes) {
            return codes.map(function(code) {
                delete code["changed"];
                if (code.lockedIndicator === "NOT LOCKED") {
                    code.lockedIndicator = 0;
                } else {
                    code.lockedIndicator = 1;
                }
                return code;
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.directive("atItemLocked", [ "UserService", function(UserService) {
        return {
            restrict: "A",
            scope: {
                item: "=",
                lockAction: "&",
                itemName: "@"
            },
            templateUrl: "assets/templates/apps/data/metadatamanagement/shared/itemStatus/_atItemLocked.html",
            link: function(scope, element, attrs) {
                scope.disable_lock = false;
                if (scope.item.checked_out.is) {
                    UserService.getUserInfo(function(user) {
                        if (scope.item.checked_out.by.id !== user.id) {
                            scope.disable_lock = true;
                        }
                    });
                }
            }
        };
    } ]);
    app.directive("atItemCheckedOut", [ "UserService", function(UserService) {
        return {
            restrict: "A",
            scope: {
                item: "=",
                checkInAction: "&",
                checkOutAction: "&",
                itemName: "@"
            },
            templateUrl: "assets/templates/apps/data/metadatamanagement/shared/itemStatus/_atItemCheckedOut.html",
            link: function(scope, element, attrs) {
                scope.$watch("item.checked_out.is", function(newValue, oldValue) {
                    if (scope.item.checked_out.is) {
                        UserService.getUserInfo(function(data) {
                            if (scope.item.checked_out.by.id === data.id) {
                                scope.item.checked_out.self_checked = true;
                            } else {
                                scope.item.checked_out.self_checked = false;
                            }
                        });
                    }
                });
                scope.performCheckOut = function() {
                    var direction = "out";
                    element.find(".fa-sign-" + direction).removeClass("fa-sign-" + direction).addClass("fa-spinner fa-spin");
                    scope.checkOutAction({
                        cb: function() {
                            element.find(".fa-spinner").removeClass("fa-spinner fa-spin").addClass("fa-sign-out");
                        }
                    });
                };
                scope.performCheckIn = function() {
                    var direction = "in";
                    element.find(".fa-sign-" + direction).removeClass("fa-sign-" + direction).addClass("fa-spinner fa-spin");
                    scope.checkInAction({
                        cb: function() {
                            element.find(".fa-spinner").removeClass("fa-spinner fa-spin").addClass("fa-sign-in");
                        }
                    });
                };
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("MGMAController", [ "$scope", "UserService", "NavBarToggleService", "StoreService", "$routeParams", "$locationEx", "PlatformService", "$route", "$timeout", function($scope, UserService, NavBarToggleService, StoreService, $routeParams, $locationEx, PlatformService, $route, $timeout) {
        PlatformService.onChange(function() {
            $route.reload();
        });
        $timeout(function() {
            NavBarToggleService.doClose();
        }, 100);
        StoreService.leftOffHere("Metadata");
        $scope.changeRoute = function(currActive) {
            $locationEx.skipReload().path("/data/metadatamanagement/perspective/" + currActive.name.toLowerCase().replace(/ /gi, "_")).replace();
            StoreService.leftOffHere(currActive.name);
        };
        $scope.perspectives = [];
        $scope.loadedPerspectives = [];
        UserService.getPerspectives(function(p) {
            $scope.perspectives = p;
            if ($routeParams.hasOwnProperty("perspective")) {
                $scope.perspectives = $scope.perspectives.map(function(p, i) {
                    var l = p.name.toLowerCase().replace(/ /gi, "_");
                    if (l === this.perspective) {
                        p.active = true;
                        return p;
                    }
                    p.active = false;
                    return p;
                }, {
                    perspective: $routeParams.perspective
                });
            } else {
                $scope.perspectives = $scope.perspectives.map(function(p, i) {
                    if (p.rank === 1) {
                        p.active = true;
                        return p;
                    }
                    p.active = false;
                    return p;
                });
            }
            $scope.$watch("perspectives", function(newValue, oldValue, scope) {
                $scope.loadActive();
            }, true);
        });
        $scope.loadActive = function() {
            var currActive = $scope.perspectives.filter(function(el, i) {
                if (el.active) {
                    return true;
                }
                return false;
            })[0];
            if ($scope.loadedPerspectives.length > 0) {
                var loadedActive = $scope.loadedPerspectives.filter(function(el, i) {
                    if (el.active) {
                        return true;
                    }
                    return false;
                })[0];
                $scope.changeRoute(currActive);
                if (currActive.uiPerspectiveID !== loadedActive.id) {
                    var found = $scope.loadedPerspectives.filter(function(el, i) {
                        if (el.id === this.id) {
                            return true;
                        }
                        return false;
                    }, {
                        id: currActive.uiPerspectiveID
                    });
                    for (var i in $scope.loadedPerspectives) {
                        if ($scope.loadedPerspectives[i].id === loadedActive.id) {
                            $scope.loadedPerspectives[i].active = false;
                        }
                    }
                    if (found.length > 0) {
                        for (var i in $scope.loadedPerspectives) {
                            if ($scope.loadedPerspectives[i].id === found[0].id) {
                                $scope.loadedPerspectives[i].active = true;
                            }
                        }
                        return;
                    }
                } else {
                    return;
                }
            }
            var currActiveName = currActive.name.toLowerCase();
            currActiveName = currActiveName.replace(/ /g, "");
            $scope.loadedPerspectives.push({
                id: currActive.uiPerspectiveID,
                include: "assets/templates/apps/data/metadatamanagement/" + currActiveName.toLowerCase() + "/main.html",
                active: true
            });
        };
        $scope.$on("perspective-change", function(e, id) {
            $scope.$apply(function() {
                $scope.perspectives = $scope.perspectives.map(function(p, i) {
                    if (p.uiPerspectiveID === this.id) {
                        p.active = true;
                        return p;
                    }
                    p.active = false;
                    return p;
                }, {
                    id: id
                });
            });
        });
    } ]);
    app.directive("perspectiveButton", [ function() {
        return {
            templateUrl: "assets/templates/core/shared/perspective/perspective-button.template.html",
            controller: function($scope, $element, $attrs) {
                $scope.changePerspective = function(id) {
                    $scope.$emit("perspective-change", id);
                };
            },
            link: function(scope, element, attrs) {
                element.find("a").on("click", function() {
                    scope.changePerspective(scope.p.uiPerspectiveID);
                });
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var MemoryFootprintController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function MemoryFootprintController($scope, $element, $window, $interval) {
            this.$scope = $scope;
            this.$element = $element;
            this.$window = $window;
            this.$interval = $interval;
            this._init();
        }
        DP$0(MemoryFootprintController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            var self = this;
            this._seconds = 30;
            this.$scope.memory = {
                usage: 0,
                total: 0
            };
            this.calcMemory();
            this.$interval(function() {
                self.calcMemory();
            }, this._seconds * 1e3);
        };
        proto$0.calcMemory = function() {
            var m = this.$window.performance.memory;
            this.$scope.memory.usage = m.usedJSHeapSize / 1e6;
            this.$scope.memory.total = m.totalJSHeapSize / 1e6;
        };
        MIXIN$0(MemoryFootprintController.prototype, proto$0);
        proto$0 = void 0;
        return MemoryFootprintController;
    }();
    app.directive("memoryFootprint", [ function() {
        return {
            template: "{{memory.usage}}Mb/{{memory.total}}Mb",
            controller: [ "$scope", "$element", "$window", "$interval", MemoryFootprintController ]
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("SegmentListService", [ "APIService", "AlertMessageService", "UserService", "SyncService", "PlatformService", function(APIService, AlertMessageService, UserService, SyncService, PlatformService) {
        var _list = [];
        var _listeners = [];
        this.data = {
            _cache: [],
            selectedByID: null
        };
        var _postProcessSegment = function(data, cb) {
            var segment = angular.copy(data[0]);
            delete segment["checkedOutDate"];
            delete segment["checkedOutUserID"];
            delete segment["lockedDate"];
            delete segment["lockedUserID"];
            delete segment["createDate"];
            delete segment["createUserID"];
            delete segment["updateDate"];
            delete segment["updateUserID"];
            delete segment["parent"];
            delete segment["children"];
            segment.fields = data[3];
            segment.version = (parseInt(segment.version) / 100).toString();
            segment.created = {
                on: moment(new Date(data[0].createDate)).format("MM/DD/YYYY"),
                by: data[0].createUserID
            };
            segment.updated = {
                on: moment(new Date(data[0].updateDate)).format("MM/DD/YYYY"),
                by: data[0].updateUserID
            };
            segment.locked = {
                is: data[0].lockedDate === null ? false : true,
                on: moment(new Date(data[0].lockedDate)).format("MM/DD/YYYY"),
                by: data[0].lockedUserID
            };
            segment.checked_out = {
                is: data[0].checkedOutDate === null ? false : true,
                on: moment(new Date(data[0].checkedOutDate)).format("MM/DD/YYYY"),
                by: data[0].checkedOutUserID
            };
            var _key = "segmentUsers";
            SyncService.addKey(_key);
            SyncService.addTo(_key, "createdBy");
            SyncService.addTo(_key, "updatedBy");
            SyncService.addTo(_key, "checkedOutBy");
            SyncService.addTo(_key, "lockedBy");
            SyncService.onComplete(_key, function() {
                cb.apply(null, [ segment ]);
            });
            UserService.getUser(segment.created.by, function(user) {
                segment.created.by = user;
                SyncService.syncComplete(_key, "createdBy");
            });
            UserService.getUser(segment.updated.by, function(user) {
                segment.updated.by = user;
                SyncService.syncComplete(_key, "updatedBy");
            });
            if (segment.checked_out.by !== null) {
                UserService.getUser(segment.checked_out.by, function(user) {
                    segment.checked_out.by = user;
                    SyncService.syncComplete(_key, "checkedOutBy");
                });
            } else {
                SyncService.syncComplete(_key, "checkedOutBy");
            }
            if (segment.locked.by !== null) {
                UserService.getUser(segment.locked.by, function(user) {
                    segment.locked.by = user;
                    SyncService.syncComplete(_key, "lockedBy");
                });
            } else {
                SyncService.syncComplete(_key, "lockedBy");
            }
        };
        this.fetchLatestSegment = function(name, cb, loading) {
            loading = typeof loading !== "undefined" ? loading : true;
            name = name.split(" - ")[0];
            APIService.get("segment/latest/" + name + "/p/" + PlatformService.current.id, {
                raw: true,
                loadingScreen: loading
            }).success(function(data) {
                _postProcessSegment(data, function(segment) {
                    cb.apply(null, [ segment ]);
                });
            }).error(function(err, status) {
                AlertMessageService.showError("Unable to fetch segment! [" + status + "]");
            });
        };
        this.fetchByID = function(id, cb) {
            APIService.get("segment/" + id, {
                raw: true
            }).success(function(data) {
                _postProcessSegment(data, function(segment) {
                    cb.apply(null, [ segment ]);
                });
            }).error(function(err, status) {
                AlertMessageService.showError("Unable to fetch segment! [" + status + "]");
            });
        };
        this.fetchByNameAndVersion = function(name, version, cb, loading) {
            loading = typeof loading !== "undefined" ? loading : true;
            APIService.get("segment/name/" + name + "/version/" + version + "/p/" + PlatformService.current.id, {
                raw: true,
                loadingScreen: loading
            }).success(function(data) {
                _postProcessSegment(data, function(segment) {
                    cb.apply(null, [ segment ]);
                });
            }).error(function(err, status) {
                AlertMessageService.showError("Unable to fetch segment! [" + status + "]");
            });
        };
        this.fetch = function(by, cb) {
            var call = "segment/";
            for (var name in by) {
                call += name + "/" + by[name] + "/";
            }
            APIService.get(call.substring(0, call.length - 1), {
                loadingScreen: false
            }).success(function(data) {
                cb(data);
            }).error(function(err) {
                AlertMessageService.showError("Unable to fetch segment! [" + err + "]");
            });
        };
        this.getListForLayout = function(cb) {
            APIService.get("layout/segments/all/" + PlatformService.current.id).success(function(data) {
                cb.apply(null, [ data ]);
            }).error(function(err) {
                AlertMessageService.showError("Unable to fetch segment list! [" + err + "]");
            });
        };
        this.getList = function(cb) {
            APIService.get("segment/all/" + PlatformService.current.id).success(function(data) {
                cb.apply(null, [ data ]);
            }).error(function(err) {
                AlertMessageService.showError("Unable to fetch segment list! [" + err + "]");
            });
        };
        this.refresh = function(cb) {
            cb = cb || null;
            this.getList(function(list) {
                _list = list.map(function(l) {
                    return {
                        name: l,
                        show_in_list: true,
                        isSelected: false
                    };
                });
                if (cb !== null) cb.apply(null, [ _list ]);
                _runOnUpdate();
            });
        };
        var _runOnUpdate = function() {
            angular.forEach(_listeners, function(cb) {
                cb.apply(null, [ _list ]);
            });
        };
        this.onUpdate = function(cb) {
            _listeners.push(cb);
        };
        this.getSelected = function() {
            var r = _list.filter(function(item) {
                return item.isSelected;
            });
            if (r.length > 0) {
                return r[0];
            }
            return {};
        };
        this.select = function(segment) {
            if (segment === false) {
                _list = _list.map(function(item) {
                    item.isSelected = false;
                    return item;
                });
            } else {
                _list.forEach(function(l) {
                    var _name = this.name;
                    if (_name.indexOf(" - ") === -1) {
                        _name = this.name + " - " + this.shortDescription;
                    }
                    if (l.name === _name) {
                        l.isSelected = true;
                    } else {
                        l.isSelected = false;
                    }
                }, segment);
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.service("SegmentService", [ "APIService", "PlatformService", function(APIService, PlatformService) {
        var _fieldFields = [ "createUserID", "length", "createDate", "name", "codeTableName", "dataTypeName", "updateUserID", "updateDate", "description", "primaryKey", "segmentName" ];
        var _preProccessSegment = function(segment) {
            var s = angular.copy(segment);
            if (!s.hasOwnProperty("platformID")) {
                s.platformID = PlatformService.current.id;
            }
            s.version = parseFloat(s.version) * 100;
            s.createDate = new Date(s.created.on);
            s.createUserID = s.created.by.userID;
            s.updateDate = new Date(s.updated.on);
            s.updateUserID = s.updated.by.userID;
            if (s.locked.is) {
                s.lockedDate = new Date(s.locked.on);
                s.lockedUserID = s.locked.by.userID;
            } else {
                s.lockedDate = null;
                s.lockedUserID = null;
            }
            if (s.checked_out.is) {
                s.checkedOutDate = new Date(s.checked_out.on);
                s.checkedOutUserID = s.checked_out.by.userID;
            } else {
                s.checkedOutDate = null;
                s.checkedOutUserID = null;
            }
            delete s["created"];
            delete s["updated"];
            delete s["checked_out"];
            delete s["locked"];
            delete s["versions"];
            delete s["has_many_versions"];
            var now = new Date();
            for (var i in s.fields) {
                if (s.fields[i].name === null || s.fields[i].name === "") {
                    s.fields.splice(i, 1);
                    continue;
                }
                s.fields[i].primaryKey = {
                    segmentID: -1,
                    fieldNumber: s.fields[i].fieldNumber
                };
                if (s.hasOwnProperty("id")) {
                    s.fields[i].primaryKey.segmentID = s.id;
                }
                s.fields[i].segmentName = s.name;
                s.fields[i].createDate = now;
                s.fields[i].updateDate = now;
                s.fields[i].createUserID = s.createUserID;
                s.fields[i].updateUserID = s.createUserID;
                angular.forEach(s.fields[i], function(value, key) {
                    var _found = false;
                    for (_i in _fieldFields) {
                        if (key === _fieldFields[_i]) {
                            _found = true;
                            break;
                        }
                    }
                    if (!_found) {
                        delete this[key];
                    }
                }, s.fields[i]);
            }
            var fields = s.fields;
            delete s["fields"];
            s.listFields = fields;
            return s;
        };
        this.create = function(segment) {
            var s = _preProccessSegment(segment);
            return APIService.put("segment/new", s);
        };
        this.update = function(segment) {
            var s = _preProccessSegment(segment);
            return APIService.post("segment/update", s);
        };
        this.lock = function(data) {
            return APIService.post("segment/lock", data);
        };
        this.check = function(direction, data) {
            return APIService.post("segment/check/" + direction, data);
        };
        this.getVersions = function(name, cb) {
            APIService.get("segment/versions/" + name + "/p/" + PlatformService.current.id).success(function(versions) {
                cb.apply(null, [ versions ]);
            });
        };
        this.checkUniqueName = function(name, cb) {
            APIService.get("segment/is/unique/" + name + "/p/" + PlatformService.current.id).success(function(is) {
                cb.apply(null, [ is ]);
            });
        };
        this.deleteSegment = function(segment, cb) {
            APIService.delete("segment/" + segment.id).success(function() {
                cb.apply(null, []);
            });
        };
        this.checkForDelete = function(segment, cb) {
            APIService.get("segment/check/delete/" + segment.id).success(function(data) {
                cb.apply(null, [ data ]);
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("DashboardController", [ "$scope", "$log", "UserService", function($scope, $log, UserService) {
        $scope.user = null;
        UserService.getUserInfo(function(user) {
            $scope.user = user;
        });
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var DashDeploymentStatsController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DashDeploymentStatsController($scope, $element, APIService, PlatformService) {
            this.$scope = $scope;
            this.$element = $element;
            this.APIService = APIService;
            this.PlatformService = PlatformService;
            this._init();
        }
        DP$0(DashDeploymentStatsController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            this._initScope();
        };
        proto$0._initScope = function() {
            var self = this;
            this.$scope.data = [];
            this.$scope.labels = [ "Layouts", "Segments", "Codes" ];
            this.$scope.d = null;
            this.$scope.deployments = [];
            this.PlatformService.onChange(function() {
                self.$scope.deployments = self.PlatformService.getPlatforms();
                self.selectDeployment(self.PlatformService.current);
            });
            this.PlatformService.fetchPlatforms(function() {
                self.$scope.deployments = self.PlatformService.getPlatforms();
                self.selectDeployment(self.PlatformService.current);
            });
            this.$scope.selectDeployment = function(deployment) {
                self.selectDeployment(deployment);
            };
        };
        proto$0.selectDeployment = function(deployment) {
            this.$scope.d = deployment;
            this.fetchData();
        };
        proto$0.fetchData = function() {
            var self = this;
            this.APIService.get("platform/" + this.$scope.d.id + "/stats", {
                cache: true
            }).success(function(data) {
                var d = [ data.layouts, data.segments, data.codes ];
                self.$scope.data = [];
                self.$scope.data.push(d);
            });
        };
        MIXIN$0(DashDeploymentStatsController.prototype, proto$0);
        proto$0 = void 0;
        return DashDeploymentStatsController;
    }();
    app.directive("dashDeploymentStats", [ function() {
        return {
            templateUrl: "assets/templates/apps/home/dashboard/deploymentstats/dashDeploymentStats.html",
            controller: [ "$scope", "$element", "APIService", "PlatformService", DashDeploymentStatsController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    var DashOverallStatsController = function() {
        "use strict";
        var PRS$0 = function(o, t) {
            o["__proto__"] = {
                a: t
            };
            return o["a"] === t;
        }({}, {});
        var DP$0 = Object.defineProperty;
        var GOPD$0 = Object.getOwnPropertyDescriptor;
        var MIXIN$0 = function(t, s) {
            for (var p in s) {
                if (s.hasOwnProperty(p)) {
                    DP$0(t, p, GOPD$0(s, p));
                }
            }
            return t;
        };
        var proto$0 = {};
        function DashOverallStatsController($scope, $element, APIService, PlatformService, StoreService) {
            this.$scope = $scope;
            this.$element = $element;
            this.APIService = APIService;
            this.PlatformService = PlatformService;
            this.StoreService = StoreService;
            this._init();
        }
        DP$0(DashOverallStatsController, "prototype", {
            configurable: false,
            enumerable: false,
            writable: false
        });
        proto$0._init = function() {
            this._initScope();
        };
        proto$0._initScope = function() {
            var self = this;
            this.$scope.stats = {
                platforms: 0,
                layouts: 0,
                segments: 0
            };
            this.$scope.leftOff = this.StoreService.getRawLeftOff();
            this.$scope.leftOffLocation = this.StoreService.getWhereWeLeftOff();
            this.PlatformService.onChange(function() {
                self._fetchStats();
            });
            this._fetchStats();
        };
        proto$0._fetchStats = function() {
            var self = this;
            this.APIService.get("dash/stats/" + this.PlatformService.current.id, {
                cache: true
            }).success(function(stats) {
                self.$scope.stats = stats;
            });
        };
        MIXIN$0(DashOverallStatsController.prototype, proto$0);
        proto$0 = void 0;
        return DashOverallStatsController;
    }();
    app.directive("dashOverallStats", [ function() {
        return {
            templateUrl: "assets/templates/apps/home/dashboard/overallstats/dashOverallStats.html",
            controller: [ "$scope", "$element", "APIService", "PlatformService", "StoreService", DashOverallStatsController ]
        };
    } ]);
})();

(function() {
    var app = angular.module("atUILogin");
    app.controller("LoginScreenController", [ "$scope", "APIService", "$window", "localStorageService", function($scope, APIService, $window, localStorageService) {
        $scope.user = {
            loginID: null,
            password: null,
            remember: true
        };
        var _checkIfRemembered = function() {
            var _loginID = simpleStorage.get("loginID");
            if (angular.isDefined(_loginID)) {
                $scope.user.loginID = _loginID;
            }
        };
        _checkIfRemembered();
        $scope.canLogIn = function() {
            if ($scope.user.loginID !== null && $scope.user.loginID !== "") {
                if ($scope.user.password !== null && $scope.user.password !== "") {
                    return false;
                }
            }
            return true;
        };
        $scope.$on("do-login", function() {
            if (!$scope.canLogIn()) {
                $scope.logIn();
            }
        });
        $scope.logIn = function() {
            APIService.post("auth/login/do", {
                loginID: $scope.user.loginID,
                password: $scope.user.password
            }).success(function(res) {
                if (res.status === "OK") {
                    if ($scope.user.remember) {
                        simpleStorage.set("loginID", res.data[0].logonID.toLowerCase());
                    } else {
                        simpleStorage.deleteKey("loginID");
                    }
                    localStorageService.set("token", res.data[100]);
                    $window.location.replace("/index.html");
                }
            }).error(function(data, status) {
                console.log(data, status);
            });
        };
    } ]);
    app.directive("passwordField", [ function() {
        return {
            link: function(scope, element) {
                element.on("keyup", function(e) {
                    var code = e.keyCode || e.which;
                    if (code === 13) {
                        scope.$broadcast("do-login");
                    }
                });
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").controller("RecordEditorController", [ "$scope", "$log", "UndoService", function($scope, $log, UndoService) {} ]);
})();

(function() {
    var app = angular.module("atUI");
    app.controller("RecordManagementController", [ "$scope", "StoreService", function($scope, StoreService) {
        StoreService.leftOffHere();
    } ]);
})();

(function() {
    angular.module("atUI").controller("OLDRecordManagementController", [ "$scope", "$http", "$log", "AlertMessageService", "localStorageService", "UserService", "FileService", "FilesService", "UndoService", "FilesStoreService", "hotkeys", "StoreService", function($scope, $http, $log, AlertMessageService, localStorageService, UserService, FileService, FilesService, UndoService, FilesStoreService, hotkeys, StoreService) {
        var ref = this;
        this.filesStore = FilesStoreService.filesStore;
        hotkeys.add({
            combo: "alt+n",
            description: "Creates new file",
            callback: function() {
                $scope.startNewFileProcess();
            }
        });
        $scope.filesClearActionDisabled = true;
        $scope.files = [];
        $scope.currentPanel = "saved-files";
        StoreService.leftOffHere();
        $scope.$watch(function() {
            return FilesService.getAll();
        }, function(newValue, oldValue) {
            if (newValue.length > 0) {
                $scope.filesClearActionDisabled = false;
            }
            $scope.files = FilesService.getAll();
        });
        $scope.$watch(function() {
            return FilesStoreService.idbIsReady;
        }, function(newValue, oldValue) {
            if (newValue === true) {
                ref.getSavedFiles();
            }
        });
        $scope.startNewFileProcess = function() {
            $scope.$broadcast("new-file-started");
            FileService.openModal();
        };
        $scope.isThereAnyFilesToShow = function() {
            var tmpFiles = FilesService.getAll();
            if (tmpFiles.length === 0) return false;
            var c = 0;
            for (var i in tmpFiles) {
                if (tmpFiles[i].isDeleted) c = c + 1;
            }
            if (c === tmpFiles.length) {
                return false;
            }
            return true;
        };
        $scope.deleteFile = function(file) {
            if (ref.idbIsReady) {
                file.isDeleted = true;
                ref.filesStore.put(file, function() {
                    $scope.$apply(function() {
                        ref.getSavedFiles();
                    });
                    UndoService.triggerMessage(function() {
                        file.isDeleted = false;
                        ref.filesStore.put(file, function() {
                            $scope.$apply(function() {
                                ref.getSavedFiles();
                            });
                        });
                    });
                });
            }
        };
        $scope.clearAll = function() {
            if (ref.idbIsReady) {
                var ids = [];
                ref.filesStore.getAll(function(files) {
                    for (var i in files) {
                        if (files[i].isDeleted === false) {
                            files[i].isDeleted = true;
                            ids.push(files[i].id);
                        }
                    }
                    ref.filesStore.putBatch(files, function() {
                        UndoService.triggerMessage(function() {
                            ref.filesStore.getAll(function(files) {
                                for (var i in files) {
                                    for (var _id in ids) {
                                        if (files[i].id === ids) files[i].isDeleted = false;
                                    }
                                }
                                ref.filesStore.putBatch(files);
                            });
                        });
                        ref.getSavedFiles();
                    });
                });
            }
        };
        this.getSavedFiles = function(cb) {
            cb = cb || null;
            this.filesStore.getAll(function(files) {
                FilesService.clearAll();
                $scope.$apply(function() {
                    FilesService.set(files);
                    if (cb !== null) cb();
                });
            });
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("ARCFieldsService", [ function() {
        this.hiddenFields = {
            fileCreationDate: true,
            fileCreationTime: true,
            fileName: true,
            numberOfInputFiles: true,
            fileSequenceNumber: true
        };
        this.defaultValues = {
            fileCreationDate: "getCurrentDate",
            fileCreationTime: "getCurrentTime",
            numberOfInputFiles: function(field) {
                return 1;
            }
        };
        this.fieldTypes = {
            currencyCode: {
                type: "select",
                options: {
                    type: "ajax",
                    src: "currency_codes"
                }
            },
            languageCode: {
                type: "select",
                options: {
                    type: "ajax",
                    src: "language_codes"
                }
            }
        };
        this.showField = function(field) {
            if (angular.isDefined(this.hiddenFields[field.name])) {
                return false;
            }
            return true;
        };
        this.hasDefaultFieldValue = function(field) {
            if (angular.isDefined(this.defaultValues[field.name])) {
                return true;
            }
            return false;
        };
        this.getDefaultFieldValue = function(field) {
            if (typeof this.defaultValues[field.name] === "function") {
                return this.defaultValues[field.name](field);
            }
            if (angular.isDefined(this[this.defaultValues[field.name]])) {
                return this[this.defaultValues[field.name]](field);
            }
        };
        this.getCurrentTime = function(field) {
            return moment().format("HH:MM:ss");
        };
        this.getCurrentDate = function(field) {
            return moment().format("YYYYMMDD");
        };
        this.dataSuppierInfo = function(fields) {
            var dataSuppierInfo = [];
            for (var i in fields) {
                if (fields[i].name.indexOf("dataSupplier") > -1) {
                    dataSuppierInfo.push(fields[i]);
                }
            }
            return dataSuppierInfo;
        };
        this.textLocalSettingInfo = function(fields) {
            var settings = [];
            for (var i in fields) {
                if (fields[i].name.indexOf("Code") > -1) {
                    settings.push(fields[i]);
                }
            }
            return settings;
        };
        this.programInfo = function(fields) {
            var info = [];
            for (var i in fields) {
                if (fields[i].name.indexOf("program") > -1) {
                    info.push(fields[i]);
                }
            }
            return info;
        };
        this.softwareInfo = function(fields) {
            var info = [];
            for (var i in fields) {
                if (fields[i].name.indexOf("software") > -1) {
                    info.push(fields[i]);
                }
            }
            return info;
        };
        this.getFieldType = function(field) {
            if (angular.isDefined(this.fieldTypes[field.name])) {
                return this.fieldTypes[field.name];
            }
            return false;
        };
    } ]);
})();

(function() {
    angular.module("atUI").directive("arcFieldType", [ "ARCFieldsService", "$interpolate", "APIService", "$compile", function(ARCFieldsService, $interpolate, APIService, $compile) {
        return {
            link: function(scope, element, attrs) {
                var field = ARCFieldsService.getFieldType(scope.$parent.field);
                if (field !== false) {
                    if (field.type === "select") {
                        var exp = $interpolate("{{getFieldTypeClass(field)}}");
                        var field_class = exp({
                            field: scope.$parent.field,
                            getFieldTypeClass: scope.getFieldTypeClass
                        });
                        var context = {
                            field: scope.$parent.field
                        };
                        var exp = $interpolate("{{field.name}}");
                        var field_id = exp(context);
                        var scope_name = "field_ajax_" + scope.$parent.field.name;
                        if (field.options.type === "ajax") {
                            scope[scope_name] = [];
                            APIService.get(field.options.src).success(function(data) {
                                scope.$parent.$parent[scope_name] = data.data;
                                scope.$parent.$parent.arc[scope.$parent.field.name] = null;
                            });
                        }
                        var tmp_scope = scope.$parent.$parent;
                        tmp_scope["field"] = scope.$parent.field;
                        element.append($compile($('<select class="form-control ' + field_class + '" ng-model="arc.' + field_id + '" ng-options="val.name for val in ' + scope_name + " | orderBy:'name'\" id=\"" + field_id + '"></select>').append($('<option value="">- Choose One -</option>')))(tmp_scope));
                    }
                } else {
                    var exp = $interpolate("{{getFieldTypeClass(field)}}");
                    var field_class = exp({
                        field: scope.$parent.field,
                        getFieldTypeClass: scope.getFieldTypeClass
                    });
                    var exp = $interpolate("{{getFieldType(field)}}");
                    var field_type = exp({
                        field: scope.$parent.field,
                        getFieldType: scope.getFieldType
                    });
                    var context = {
                        field: scope.$parent.field
                    };
                    var exp = $interpolate("{{field.name}}");
                    var field_id = exp(context);
                    var exp = $interpolate("{{field.description}}");
                    var field_placeholder = exp(context);
                    element.append($compile($('<input type="' + field_type + '" class="form-control ' + field_class + '" ng-model="arc.' + field_id + '" id="' + field_id + '" placeholder="' + field_placeholder + '">'))(scope.$parent.$parent));
                }
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("FieldGroupingService", [ function() {
        this.group = function(fields) {
            var groups = {};
            fields.sort();
            var alpha = {};
            for (var i in fields) {
                var firstLetter = fields[i].charAt(0);
                if (!alpha.hasOwnProperty(firstLetter)) alpha[firstLetter] = [];
                alpha[firstLetter].push(fields[i]);
            }
            for (var letter in alpha) {
                var cont = true, i = 0, c = 0, end_count = 0, count = 0;
                var b = [];
                for (var aa in alpha[letter]) {
                    end_count = end_count + alpha[letter][aa].length;
                    b.push([]);
                }
                while (cont) {
                    if (alpha[letter].length === 1) {
                        break;
                    }
                    var next = i + 1;
                    if (next in alpha[letter]) {
                        if (alpha[letter][i].charAt(c) !== "") {
                            count += 1;
                        }
                        if (alpha[letter][i].charAt(c) !== "" && alpha[letter][next].charAt(c) !== "" && alpha[letter][i].charAt(c) === alpha[letter][next].charAt(c)) {
                            if (!(c in b[i])) b[i].push("1");
                            if (!(c in b[next])) b[next].push("1");
                        } else {
                            if (!(c in b[i])) b[i].push("0");
                            if (!(c in b[next])) b[next].push("0");
                        }
                        i++;
                    } else {
                        if (alpha[letter][i].charAt(c) !== "") {
                            count += 1;
                        }
                        i = 0;
                        c++;
                    }
                    if (count >= end_count) {
                        cont = false;
                    }
                }
                for (var _i in b) {
                    if (b[_i].length > 0) {
                        var mask = b[_i].join("").split("10", 1)[0].length;
                        var group_name = alpha[letter][_i].substring(0, mask + 1);
                        if (!groups.hasOwnProperty(group_name)) {
                            groups[group_name] = [];
                        }
                        groups[group_name].push(alpha[letter][_i]);
                    } else {
                        if (!groups.hasOwnProperty("_other")) {
                            groups["_other"] = [];
                        }
                        groups["_other"].push(alpha[letter][_i]);
                    }
                }
                var sorted_groups = [];
                for (var name in groups) {
                    sorted_groups.push([ name, groups[name] ]);
                }
                sorted_groups.sort(function(a, b) {
                    if (a[0] === "_other" || b[0] === "_other") return 1;
                    if (a[0] < b[0]) return -1;
                    if (a[0] > b[0]) return 1;
                    return 0;
                });
            }
            return sorted_groups;
        };
    } ]);
})();

(function() {
    angular.module("atUI").directive("fields", [ function() {
        return {
            restrict: "A",
            link: function(scope, el) {
                var ref = this;
                this.applyModelChange = function(element) {
                    var $elem = $(element);
                    var model_name = $elem.attr("ng-model");
                    var s = model_name.split(".");
                    scope.$apply(function() {
                        scope[s[0]][s[1]] = $elem.val();
                    });
                };
                scope.$watch("arc_groups", function(newValue, oldValue) {
                    if (newValue.length === 0) {
                        el.css({
                            display: "none"
                        });
                    } else {
                        el.slideDown(function() {
                            $(".field-type-date").datetimepicker({
                                pickTime: false
                            }).on("dp.change", function(e) {
                                ref.applyModelChange(this);
                            });
                            $(".field-type-time").datetimepicker({
                                pickDate: false
                            }).on("dp.change", function(e) {
                                ref.applyModelChange(this);
                            });
                        });
                    }
                });
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").directive("segmentField", [ "$compile", "ValidationService", "AlertMessageService", "LookupService", function($compile, ValidationService, AlertMessageService, LookupService) {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                var ref = this;
                this.camelcaseToCapWords = function(name) {
                    return name.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/\w\S*/g, function(txt) {
                        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                    });
                };
                this.createSelectLookupField = function(_field) {
                    LookupService.get(_field.lookup_group, function(data) {
                        scope.$parent.$parent[_field.lookup_group] = data.data;
                        scope.$parent.$parent.arc[_field.name] = null;
                        var rule = ValidationService.getValidationRulesFor(_field, scope.$parent.$parent[attrs.sfValidation]);
                        var is_required = "";
                        var is_required_rule = null;
                        if (rule !== false) {
                            for (var i in rule.rules) {
                                if (rule.rules[i].operator === "exists" && rule.rules[i].not_indicator === true) {
                                    is_required = ' ng-required="true"';
                                    is_required_rule = rule.rules[i];
                                    break;
                                }
                            }
                        }
                        var $form_group = $('<div id="field-group-' + _field.name + '" class="form-group"></div>');
                        ref.injectInvalidDetection(_field);
                        $form_group.append($('<label for="' + _field.name + '">' + ref.camelcaseToCapWords(_field.name) + "</label>"));
                        var $select_html = $('<select class="form-control field-type-' + _field.class_type.toLowerCase() + '" ng-model="' + attrs.sfModel + "." + _field.name + '" ng-options="val.name for val in ' + _field.lookup_group + " | orderBy:'name'\" id=\"" + _field.name + '"' + is_required + "></select>").append($('<option value="">- Choose One -</option>'));
                        $form_group.append($select_html);
                        var select = $compile($form_group)(scope.$parent.$parent);
                        element.append(select);
                        if (is_required !== "") {
                            $('<span class="help-block" style="display: none;">' + is_required_rule.metric_description.replace("<fieldName>", "") + "</span>").insertAfter($("#" + _field.name));
                        }
                    });
                };
                this.createInputField = function(_field) {
                    var $form_group = $('<div id="field-group-' + _field.name + '" class="form-group"></dvi>');
                    this.injectInvalidDetection(_field);
                    $form_group.append($('<label for="' + _field.name + '">' + ref.camelcaseToCapWords(_field.name) + "</label>"));
                    var $input_html = $('<input type="text" placeholder="' + _field.description + '" ng-model="' + attrs.sfModel + "." + _field.name + '" class="form-control field-type-' + _field.class_type.toLowerCase() + '" id="' + _field.name + '">');
                    $form_group.append($input_html);
                    var input = $compile($form_group)(scope.$parent.$parent);
                    element.append(input);
                    var rule = ValidationService.getValidationRulesFor(_field, scope.$parent.$parent[attrs.sfValidation]);
                };
                this.injectInvalidDetection = function(_field) {
                    scope.$parent.$parent.$watch("arc." + _field.name, function(oldValue, newValue, scope) {
                        if (oldValue !== newValue) {
                            var name = this.exp.split(".")[1];
                            var $f = $("#" + name);
                            if ($f.hasClass("ng-dirty") && $f.hasClass("ng-invalid")) {
                                $f.closest(".form-group").addClass("has-error");
                                $f.siblings(".help-block").slideDown();
                            } else {
                                $f.closest(".form-group").removeClass("has-error");
                                $f.siblings(".help-block").slideUp();
                            }
                        }
                    });
                };
                var field = null;
                for (var i in scope.$parent.$parent[attrs.sfDefinitions]) {
                    if (scope.field === scope.$parent.$parent[attrs.sfDefinitions][i].name) {
                        field = scope.$parent.$parent[attrs.sfDefinitions][i];
                        break;
                    }
                }
                if (field === null) {
                    AlertMessageService.showError("Fatal Error!", "Unable to create field requested.");
                    return;
                }
                if (field.lookup_group.length > 0) {
                    this.createSelectLookupField(field);
                } else {
                    this.createInputField(field);
                }
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("FileService", [ function() {
        this.modal_id = "#newFileModal";
        var file = {};
        this.create = function(newFile) {
            file = newFile;
        };
        this.get = function() {
            return file;
        };
        this.clear = function() {
            file = {};
        };
        this.openModal = function() {
            var $m = $(this.modal_id);
            $m.on("shown.bs.modal", function(e) {
                $(this).find("#modal-platform").focus();
            });
            $m.modal();
        };
        this.closeModal = function() {
            $(this.modal_id).modal("hide");
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("FileModelService", [ function() {
        this.model = {};
    } ]);
})();

(function() {
    angular.module("atUI").service("FilesService", [ function() {
        var _files = [];
        this.put = function(file) {
            _files.push(file);
        };
        this.set = function(files) {
            _files = files;
        };
        this.get = function(key) {
            return _files[key];
        };
        this.getAll = function() {
            return _files;
        };
        this.clearAll = function() {
            _files = [];
        };
    } ]);
})();

(function() {
    "use strict";
    angular.module("atUI").controller("NewFileController", [ "$scope", "APIService", "$log", "FileModelService", "FileService", "FilesStoreService", "AlertMessageService", "ARCFieldsService", "FieldGroupingService", function($scope, APIService, $log, FileModelService, FileService, FilesStoreService, AlertMessageService, ARCFieldsService, FieldGroupingService) {
        var ref = this;
        this.HEADER_SEGMENT_NAME = "ARC";
        this.filesStore = FilesStoreService.filesStore;
        this.cache = {};
        this.structures = [ {
            model: "uif",
            dependentOn: "platform",
            select_model: "uifs"
        }, {
            model: "uif_type",
            dependentOn: "uif",
            select_model: "uif_types"
        }, {
            model: "uif_subtype",
            dependentOn: "uif_type",
            select_model: "uif_subtypes"
        } ];
        $scope.name = "";
        $scope.created_by = "Alan Tirado";
        $scope.platforms = [];
        $scope.uifs = [];
        $scope.uif_types = [];
        $scope.uif_substypes = [];
        $scope.platform = null;
        $scope.uif = null;
        $scope.uif_type = null;
        $scope.uif_subtype = null;
        $scope.hash = null;
        $scope.header_fields = [];
        $scope.arc = FileModelService.model;
        $scope.arc_validation = {};
        $scope.arc_groups = [];
        $scope.arc_service = ARCFieldsService;
        for (var i in this.structures) {
            var dependentOn = ref.structures[i]["dependentOn"];
            $scope.$watch(dependentOn, function(newValue, oldValue) {
                var this_structure = ref.getStructure(this.exp);
                var url = this_structure["select_model"] + "/";
                if (newValue !== null) url = url + newValue.id;
                ref.changeSelectModels(this_structure["dependentOn"], this_structure["select_model"], this_structure["model"], url, function(data) {
                    $scope[this_structure["select_model"]] = data["data"];
                    ref.cache[this_structure["select_model"]][$scope[this_structure["dependentOn"]]["id"]] = data["data"];
                });
            });
        }
        $scope.$watch("uif_type", function(newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue !== null) {
                    ref.createARCForm();
                } else {
                    ref.removeARCForm();
                }
            }
        });
        $scope.$on("new-file-discarded", function(e) {
            $scope.uif_subtype = null;
        });
        $scope.$on("new-file-created", function(e) {
            $scope.createEmptyFile();
        });
        $scope.$on("new-file-started", function(e) {
            $log.log("New file started!");
            ref.fillScope("platforms", function(data) {
                $scope.platforms = data["data"];
            });
        });
        $scope.createNewFile = function() {
            var createdOn = moment().format();
            FileService.create({
                meta: {
                    name: $scope.name,
                    created_by: $scope.created_by,
                    created_on: createdOn,
                    updated_on: createdOn
                },
                isDeleted: false,
                records: {}
            });
            $scope.name = "";
            $scope.$emit("new-file-created");
        };
        $scope.createEmptyFile = function() {
            if (ref.idbIsReady) {
                var file = FileService.get();
                file.hash = $scope.hash;
                ref.filesStore.put(file, function(id) {
                    FileService.closeModal();
                    $scope.$apply(function() {
                        ref.getSavedFiles(function() {
                            $scope.currentPanel = "file-editor";
                        });
                    });
                });
            }
        };
        $scope.discardNewFile = function() {
            $scope.name = "";
            FileService.closeModal();
            $scope.$emit("new-file-discarded");
        };
        $scope.getFieldType = function(field) {
            switch (field.class_type) {
              case "DATE":
              case "TIME":
              case "STRING":
                return "text";

              case "LONG":
              case "INTEGER":
                return "number";

              default:
                return "text";
            }
        };
        this.removeARCForm = function() {
            $scope.arc_groups = [];
        };
        this.changeSelectModels = function(dependentTo, select_model, model, url, success_cb) {
            var ref = this;
            if ($scope[dependentTo] === null) {
                $scope[select_model] = [];
                $scope[model] = null;
                return false;
            }
            if (!angular.isDefined(ref.cache[select_model])) {
                ref.cache[select_model] = {};
            }
            if (!angular.isDefined(ref.cache[select_model][$scope[dependentTo]["id"]])) {
                ref.fillScope(url, success_cb);
            } else {
                $scope[select_model] = ref.cache[select_model][$scope[dependentTo]["id"]];
            }
        };
        this.fillScope = function(url, success_cb) {
            var ref = this;
            APIService.get(url).success(function(data) {
                success_cb(data);
            }).error(function(data, status) {
                AlertMessageService.showError("Oh no!", "Unable to get data! [" + status + "]");
            });
        };
        this.getStructure = function(dependentOn) {
            for (var i in this.structures) {
                if (this.structures[i]["dependentOn"] === dependentOn) return this.structures[i];
            }
        };
        this.getSegmentFields = function(id, cb) {
            APIService.get("uif/" + $scope.uif.id + "/uif_type/" + $scope.uif_type.id + "/uif_subtype/" + $scope.uif_subtype.id + "/segment/" + id + "/fields").success(function(data) {
                cb(data.data);
            }).error(function(data, status) {
                AlertMessageService.showError("Oh no!", "Unable to get segment fields! [" + status + "]");
            });
        };
        this.createARCForm = function() {
            ref.getARCHeaderSegment(function(header_segment) {
                $scope.uif_subtype = {
                    id: 1
                };
                ref.getSegmentFields(header_segment.id, function(header_fields) {
                    $scope.uif_subtype = null;
                    $scope.header_fields = header_fields;
                    ref.setARCModel(header_fields, function() {
                        ref.getARCHeaderValidationRules(function(header_rules) {
                            $scope.arc_validation = header_rules.data;
                        });
                    });
                });
            });
        };
        this.getARCHeaderSegment = function(cb) {
            APIService.get("uif/" + $scope.uif.id + "/uif_type/" + $scope.uif_type.id + "/uif_subtype/1/arc_segment").success(function(segment) {
                cb(segment);
            }).error(function(data, status) {
                AlertMessageService.showError("Oh no!", "Unable to get segments! [" + status + "]");
            });
        };
        this.setARCModel = function(header_fields, cb) {
            var fields = [];
            for (var i in header_fields) {
                $scope.arc[header_fields[i].name] = null;
                fields.push(header_fields[i].name);
            }
            $scope.arc_groups = FieldGroupingService.group(fields);
            cb();
        };
        this.getARCHeaderValidationRules = function(cb) {
            APIService.get("uif/" + $scope.uif.id + "/uif_type/" + $scope.uif_type.id + "/uif_subtype/1/segment/arc_segment/validation_rules").success(function(segment) {
                cb(segment);
            }).error(function(data, status) {
                AlertMessageService.showError("Oh no!", "Unable to get segments! [" + status + "]");
            });
        };
        this.setARCDefaultValues = function() {
            for (var i in $scope.header_fields) {
                if (ARCFieldsService.hasDefaultFieldValue($scope.header_fields[i])) {
                    $scope.arc[$scope.header_fields[i].name] = ARCFieldsService.getDefaultFieldValue($scope.header_fields[i]);
                } else {
                    $scope.arc[$scope.header_fields[i].name] = "";
                }
            }
        };
    } ]);
    angular.module("atUI").filter("groupNameFilter", function() {
        return function(name) {
            if (name === "_other") {
                return "Other";
            }
            return name.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/\w\S*/g, function(txt) {
                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
            });
        };
    });
})();

(function() {
    angular.module("atUI").directive("newFileModal", [ function() {
        return {
            restrict: "A",
            link: function(scope, el) {
                el.find("#file_name").on("keypress", function(e) {
                    var key = e.which;
                    if (key === 13) {
                        scope.createNewFile();
                    }
                });
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").directive("simpleFileList", [ function() {
        return {
            restrict: "A",
            templateUrl: "public/js/ATAD/templates/simpleFileList.template.html"
        };
    } ]);
})();

(function() {
    angular.module("atUI").filter("isDeleted", function() {
        return function(records) {
            var filtered = [];
            angular.forEach(records, function(record) {
                if (!record.isDeleted) filtered.push(record);
            });
            return filtered;
        };
    });
})();

(function() {
    angular.module("atUI").service("HashService", [ function() {
        var hash = null;
        this.save = function(newHash) {
            hash = newHash;
        };
        this.get = function() {
            return hash;
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("LookupService", [ "APIService", function(APIService) {
        this.get = function(lookup_group, cb) {
            APIService.get(lookup_group).success(function(data) {
                cb(data);
            }).error(function(status) {
                AlertMessageService.showError("Lookup Error", "Unable to get lookup group! [" + status + "]");
            });
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.config([ "$routeProvider", function($routeProvider) {
        $routeProvider.when("/segmentManagement", {
            templateUrl: "assets/templates/apps/recordManagementTool/segmentManager/segment-dashboard.html",
            controller: "SegmentManagementController"
        }).when("/recordManagement", {
            templateUrl: "assets/templates/apps/recordManagementTool/recordManager/record-dashboard.html",
            controller: "RecordManagementController"
        }).when("/recordManagement/editor", {
            templateUrl: "assets/templates/apps/recordManagementTool/recordEditor/record-editor.html",
            controller: "RecordEditorController"
        });
    } ]);
})();

(function() {
    angular.module("atUI").service("RecordService", [ function() {
        this.modal_id = "#newRecordModal";
        var record = {};
        this.create = function(newRecord) {
            record = newRecord;
        };
        this.get = function() {
            return record;
        };
        this.clear = function() {
            record = {};
        };
        this.openModal = function() {
            var $m = $(this.modal_id);
            $m.on("shown.bs.modal", function(e) {
                $(this).find("#record_name").focus();
            });
            $m.modal();
        };
        this.closeModal = function() {
            $(this.modal_id).modal("hide");
        };
    } ]);
})();

(function() {
    angular.module("atUI").service("RecordsService", [ function() {
        var _records = [];
        this.put = function(record) {
            _records.push(record);
        };
        this.set = function(records) {
            _records = records;
        };
        this.get = function(key) {
            return _records[key];
        };
        this.getAll = function() {
            return _records;
        };
        this.clearAll = function() {
            _records = [];
        };
    } ]);
})();

(function() {
    angular.module("atUI").directive("workspace", [ "$log", "$timeout", function($log, $timeout) {
        return {
            restrict: "A",
            link: function(scope, el) {
                el.find(".workspace-panel").each(function(i, panel) {
                    if (panel.id !== scope.currentPanel) {
                        $(panel).css({
                            display: "none"
                        });
                    }
                });
                scope.$watch("currentPanel", function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                        el.css({
                            height: el.height(),
                            overflow: "hidden"
                        });
                        var $oldPanel = $("#" + oldValue);
                        $oldPanel.addClass("workspace-panel-leave");
                        $timeout(function() {
                            $oldPanel.css({
                                display: "none"
                            });
                            $oldPanel.removeClass("workspace-panel-leave");
                        }, 1e3);
                        var $newPanel = $("#" + newValue);
                        $newPanel.addClass("workspace-panel-enter");
                        $newPanel.css({
                            display: "block"
                        });
                        $timeout(function() {
                            $newPanel.removeClass("workspace-panel-enter");
                        }, 1e3);
                    }
                });
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").directive("atNames", function() {
        return {
            restrict: "A",
            scope: {
                fields: "=atFields",
                rows: "=atRows"
            },
            templateUrl: "public/js/app/templates/atNames.template.html"
        };
    });
})();

(function() {
    angular.module("atUI").controller("InputScreenController", [ "$scope", "$log", "$locale", "APIService", "$timeout", "IDCardNumberService", "PhoneNumberService", "AddressService", "ErrorMessagesService", "AlertMessageService", "$location", "ToolbarService", function($scope, $log, $locale, APIService, $timeout, IDCardNumberService, PhoneNumberService, AddressService, ErrorMessagesService, AlertMessageService, $location, ToolbarService) {
        $scope.attemptedSubmit = false;
        $scope.errors = ErrorMessagesService;
        $scope.$invalid = false;
        $scope.isLoading = function() {
            return false;
        };
        $scope.toBeLoaded = {
            reasons: {
                url: "input/reasons",
                loaded: false,
                onSuccess: function(data) {
                    $scope.reasons = data;
                },
                input: "reason"
            },
            loans: {
                url: "input/loans",
                loaded: false,
                onSuccess: function(data) {
                    $scope.loans = data;
                },
                input: "loan"
            }
        };
        $scope.reasons = [ {} ];
        $scope.loans = [ {} ];
        $scope.memberNames = [ {
            label: "Consumer",
            value: "C"
        }, {
            label: "Business",
            value: "B"
        } ];
        for (var i in $scope.toBeLoaded) {
            APIService.get($scope.toBeLoaded[i].url).success(function(data) {
                $scope.toBeLoaded[data["name"]].onSuccess(data["data"]);
                $scope.toBeLoaded[data["name"]].loaded = true;
                $scope.checkIfEverythingIsLoaded();
            });
        }
        $scope.inputs = {
            memberName: $scope.memberNames[0],
            memberRefNumber: [],
            reason: "__INJECT__[reasons]",
            concent: false,
            loan: "__INJECT__[loans]",
            loanDetail: "",
            loanAmount: "",
            familyName: "",
            firstName: "",
            middleName: [],
            aliasName: [],
            email: "",
            bday: {
                year: "",
                month: "",
                day: ""
            },
            addresses: [],
            idcards: IDCardNumberService,
            phoneNumbers: PhoneNumberService,
            currentEmployer: "",
            yearsEmployed: "",
            monthlyIncome: "",
            bankAccountNumber: "",
            noOfCreditCards: ""
        };
        $scope.resetInputs = [];
        $scope.injectLoaded = function() {
            var redos = [];
            for (var i in $scope.inputs) {
                if (typeof $scope.inputs[i] === "string") {
                    if ($scope.inputs[i].indexOf("__INJECT__") > -1) {
                        var match = /__INJECT__\[(.+)\]/.exec($scope.inputs[i]);
                        $scope.inputs[i] = $scope[match[1]][0];
                        redos.push({
                            name: match[1],
                            input: i
                        });
                    }
                }
            }
            $scope.resetInputs = angular.copy($scope.inputs);
            for (var i in redos) {
                $scope.resetInputs[redos[i]["input"]] = $scope[redos[i]["name"]][0];
            }
            $scope.inputs.memberName = $scope.memberNames[0];
            $scope.inputs.addresses = AddressService.getData();
        };
        $scope.checkIfEverythingIsLoaded = function() {
            for (var i in $scope.toBeLoaded) {
                if ($scope.toBeLoaded[i].loaded === false) return false;
            }
            $scope.injectLoaded();
        };
        $scope.checkInputs = function() {
            $scope.inputs.addresses = AddressService.getData();
            $scope.attemptedSubmit = true;
            $scope.errors.msgs = [];
            $("#stage").find("input").blur();
            $("#stage").find("select").blur();
            if ($(".ng-invalid").length > 0) {
                AddressService.checkIfValid();
                $scope.$invalid = true;
                $scope.errors.msgs.push("The form is invalid! Please correct the red items below.");
                return false;
            } else {
                AddressService.checkIfValid();
                if (AddressService.isInvalid.isIt === true) {
                    $scope.$invalid = true;
                } else {
                    $scope.$invalid = false;
                    $scope.errors.msgs = [];
                    $scope.submitForm();
                }
            }
        };
        $scope.submitForm = function() {
            APIService.post("input/submit/consumer", {}).success(function(data) {
                $timeout(function() {
                    $location.path($location.path() + "/report");
                }, 4e3);
            }).error(function(data, status) {
                AlertMessageService.showError("Error!", "Unable to submit form! [" + status + "]");
            });
        };
        $scope.reset = function() {
            $scope.inputs = angular.copy($scope.resetInputs);
            for (var i in $scope.toBeLoaded) {
                $scope.inputs[$scope.toBeLoaded[i]["input"]] = $scope[i][0];
            }
        };
    } ]);
})();

(function() {
    var atUI = angular.module("atUI");
    atUI.filter("camelcaseToCapWords", function() {
        return function(type) {
            return type.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/\w\S*/g, function(txt) {
                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
            });
        };
    });
})();

angular.module("atUI").factory("ReportDataService", function() {
    return {
        data: {
            ident: {
                name: {
                    first: "John",
                    middle: "Carlos",
                    family: "Sorano"
                },
                aliases: [ "Johnny", "Desert Dirt Bikes" ],
                idCards: [ {
                    number: "9719780",
                    location: "NWS",
                    exp: "1998/2017",
                    type: "driver"
                }, {
                    number: "N00995000",
                    location: "AUS",
                    exp: "2010/2020",
                    type: "passport"
                } ],
                dateOfBirth: {
                    day: "17",
                    month: "01",
                    year: "1980"
                },
                gender: "M",
                employer: {
                    name: "Desert Dirt Bikes",
                    duration: "3 years"
                },
                occupation: "Self Employed, President",
                contact: [ {
                    type: "homePhone",
                    info: "02 4872 0422"
                }, {
                    type: "bussinessPhone",
                    info: "02 4210 7317"
                }, {
                    type: "email",
                    info: "JCS@gmail.com"
                }, {
                    type: "webAddress",
                    info: "http://www.dirtbikes.com"
                } ],
                addresses: [ {
                    street1: "92 Goodhope Street",
                    street2: "",
                    city: "Paddington",
                    state: "NSW",
                    postal: "2575",
                    country: "AUS",
                    type: "residence",
                    ownership: "owner",
                    dates: {
                        from: "07/2012",
                        to: "09/2014"
                    }
                }, {
                    street1: "80-84 Tasman Parade",
                    street2: "",
                    city: "Fairfield West",
                    state: "NSW",
                    postal: "2165",
                    country: "AUS",
                    type: "apartment",
                    ownership: "rent",
                    dates: {
                        from: "08/2002",
                        to: "06/2012"
                    }
                } ]
            },
            score: {
                number: "627",
                factors: [ "Number of recent inquiries wihtin norms", "Total outstanding balance within norms", "No defaults in past 5 years", "No late payments in past 24 months", "No public record filings in past 3 years" ]
            },
            attributes: {
                openAccounts: {
                    total: "2",
                    dates: {
                        recent: "09/2014",
                        oldest: "05/2001"
                    },
                    balance: {
                        total: "22000",
                        secured: "50%",
                        unsecured: "50%"
                    },
                    creditLimit: "28000",
                    pastDueAccounts: "0",
                    pastDueAmount: "0"
                },
                closedAccounts: {
                    total: "1",
                    dates: {
                        recent: "09/2000"
                    }
                },
                inquiries: {
                    total: "2",
                    last: [ {
                        label: "last30Days",
                        value: "1"
                    }, {
                        label: "last90Days",
                        value: "0"
                    }, {
                        label: "last180Days",
                        value: "1"
                    } ]
                },
                courtFilings: {
                    dates: {
                        recent: "05/2009"
                    },
                    bankruptcies: "2",
                    judgments: "1"
                },
                collections: {
                    total: "0",
                    amount: "0"
                },
                defaults: {
                    total: "0",
                    amount: "0"
                }
            },
            tradeHistory: [ {
                accountNumber: "XXXX-XXXX-AU21",
                lender: {
                    name: "bankmecu",
                    industry: "Auto Loan Financing"
                },
                status: "open",
                dates: {
                    opened: "01/09/2014",
                    lastUpdate: "30/09/2014"
                },
                type: "Installment - Individual",
                limit: "20000",
                terms: "48 installment payments",
                repaymentFrequency: "monthly",
                paymentAmount: "450",
                loanType: "secured",
                collateral: "automobile",
                paymentInfo: {
                    status: "current",
                    balance: "20000",
                    amount: "450",
                    minimumFlag: "Y",
                    date: "15/09/2014"
                },
                grid: [ {
                    date: "10/2014",
                    status: "C"
                }, {
                    date: "09/2014",
                    status: "-"
                }, {
                    date: "08/2014",
                    status: "-"
                }, {
                    date: "07/2014",
                    status: "-"
                }, {
                    date: "06/2014",
                    status: "-"
                }, {
                    date: "05/2014",
                    status: "-"
                }, {
                    date: "04/2014",
                    status: "-"
                }, {
                    date: "03/2014",
                    status: "-"
                }, {
                    date: "02/2014",
                    status: "-"
                }, {
                    date: "01/2014",
                    status: "-"
                }, {
                    date: "12/2013",
                    status: "-"
                }, {
                    date: "11/2013",
                    status: "-"
                }, {
                    date: "10/2013",
                    status: "-"
                }, {
                    date: "09/2013",
                    status: "-"
                }, {
                    date: "08/2013",
                    status: "-"
                }, {
                    date: "07/2013",
                    status: "-"
                }, {
                    date: "06/2013",
                    status: "-"
                }, {
                    date: "05/2013",
                    status: "-"
                } ]
            }, {
                accountNumber: "XXXX-XXXX-AU221",
                lender: {
                    name: "Brisbane Credit Services",
                    industry: "Financial Institution"
                },
                status: "open",
                dates: {
                    opened: "05/01/2001",
                    lastUpdate: "30/09/2014"
                },
                type: "Revolving Credit - Individual",
                limit: "5000",
                terms: "REV",
                repaymentFrequency: "monthly",
                paymentAmount: "25",
                loanType: "unsecured",
                collateral: "none",
                paymentInfo: {
                    status: "current",
                    balance: "2000",
                    amount: "25",
                    minimumFlag: "Y",
                    date: "18/09/2014"
                },
                grid: [ {
                    date: "10/2014",
                    status: "C"
                }, {
                    date: "09/2014",
                    status: "C"
                }, {
                    date: "08/2014",
                    status: "C"
                }, {
                    date: "07/2014",
                    status: "C"
                }, {
                    date: "06/2014",
                    status: "C"
                }, {
                    date: "05/2014",
                    status: "C"
                }, {
                    date: "04/2014",
                    status: "30"
                }, {
                    date: "03/2014",
                    status: "-"
                }, {
                    date: "02/2014",
                    status: "-"
                }, {
                    date: "01/2014",
                    status: "C"
                }, {
                    date: "12/2013",
                    status: "C"
                }, {
                    date: "11/2013",
                    status: "C"
                }, {
                    date: "10/2013",
                    status: "C"
                }, {
                    date: "09/2013",
                    status: "-"
                }, {
                    date: "08/2013",
                    status: "C"
                }, {
                    date: "07/2013",
                    status: "-"
                }, {
                    date: "06/2013",
                    status: "C"
                }, {
                    date: "05/2013",
                    status: "C"
                } ]
            }, {
                accountNumber: "XXXX-XXXX-8722",
                lender: {
                    name: "American Express",
                    industry: "Financial Institution"
                },
                status: "closed",
                dates: {
                    opened: "05/02/1998",
                    lastUpdate: "30/09/2000"
                },
                type: "Revolving Credit - Individual",
                limit: "500",
                terms: "REV",
                repaymentFrequency: "monthly",
                paymentAmount: "20",
                loanType: "unsecured",
                collateral: "none",
                paymentInfo: {
                    status: "paid",
                    balance: "0",
                    amount: "N/A",
                    minimumFlag: "N/A",
                    date: "15/09/2001"
                },
                grid: [ {
                    date: "09/2000",
                    status: "C"
                }, {
                    date: "08/2000",
                    status: "C"
                }, {
                    date: "07/2000",
                    status: "C"
                }, {
                    date: "06/2000",
                    status: "C"
                }, {
                    date: "05/2000",
                    status: "C"
                }, {
                    date: "04/2000",
                    status: "C"
                }, {
                    date: "03/2000",
                    status: "-"
                }, {
                    date: "02/2000",
                    status: "-"
                }, {
                    date: "01/2000",
                    status: "-"
                }, {
                    date: "12/1999",
                    status: "-"
                }, {
                    date: "11/1999",
                    status: "-"
                }, {
                    date: "10/1999",
                    status: "-"
                }, {
                    date: "09/1999",
                    status: "-"
                }, {
                    date: "08/1999",
                    status: "-"
                }, {
                    date: "07/1999",
                    status: "-"
                }, {
                    date: "06/1999",
                    status: "-"
                }, {
                    date: "05/1999",
                    status: "-"
                }, {
                    date: "04/1999",
                    status: "-"
                } ]
            } ],
            inquiryHistory: [ {
                date: "31/08/2014",
                organization: {
                    name: "Bankmecu",
                    industry: null
                },
                details: [ "Installment", "Individual" ]
            }, {
                date: "12/15/2000",
                organization: {
                    name: "Brisbane Credit Services",
                    industry: "Financial"
                },
                details: [ "REV", "Individual" ]
            } ],
            publicRecordFilings: [ {
                number: "NCT-01-22170-0",
                court: "Federal Circuit Court of Australia",
                assets: "1000",
                liabilities: "5000",
                trustee: {
                    name: "Andrew Bardnen",
                    contact: "abarmden@rodgersrsreidy.com.au"
                },
                filing: {
                    type: "bankruptcy",
                    date: "15/01/2008",
                    status: "initial"
                }
            }, {
                number: "NCT-01-22170-1",
                court: "Federal Circuit Court of Australia",
                assets: "1000",
                liabilities: "3000",
                trustee: {
                    name: "Andrew Bardnen",
                    contact: "abarmden@rodgersrsreidy.com.au"
                },
                filing: {
                    type: "bankruptcy",
                    date: "30/05/2009",
                    status: "discharged"
                }
            }, {
                number: "A1/2008",
                court: "High Court of Australia",
                judgment_amount: "3000",
                plaintiff: "Commonweath Bank of Australia",
                filing: {
                    type: "judgment",
                    date: "15/12/2009",
                    status: "satisfied"
                }
            } ],
            statements: [ {
                date: "15/01/2008",
                statement: "I filed bankruptcy in 2008 due to extended unemployment that resulted from an injury I suffered in 2002 which left me unable to work. I was able to return to work in 2003 and have since paid all my bills on time."
            } ]
        },
        reportInfo: {
            number: "12345678",
            reciprocity: "comprehensive",
            referenceNumbers: [ "ABC123", "ABC456" ],
            language: "Australian English",
            currency: "AUD"
        }
    };
});

(function() {
    angular.module("atUI").controller("Address", [ "$scope", "AddressService", function($scope, AddressService) {
        $scope.addMoreReady = false;
        $scope.addresses = AddressService.getData();
        $scope.isInvalid = AddressService.isInvalid;
        $scope.states = [ {
            value: "California",
            label: "California"
        } ];
        $scope.countries = [ {
            value: "USA"
        }, {
            value: "AUS"
        } ];
        $scope.types = [ {
            value: "Residence",
            label: "Residence"
        }, {
            value: "Office",
            label: "Office"
        }, {
            value: "Vacation",
            label: "Vacation"
        } ];
        $scope.statuses = [ {
            value: "Current",
            label: "Current"
        }, {
            value: "Previous",
            label: "Previous"
        } ];
        $scope.resetAddress = {
            street1: "",
            city: "",
            state: null,
            postal: "",
            country: $scope.countries[0].value,
            type: null,
            status: $scope.statuses[0].value,
            $isDeleted: false
        };
        $scope.inputAddress = angular.copy($scope.resetAddress);
        $scope.editingAddress = angular.copy($scope.resetAddress);
        $scope.$addressRef = {};
        $scope.checkIfReadyToAdd = function() {
            if ($scope.inputAddress.street1 === "") {
                $scope.addMoreReady = false;
                return;
            }
            if ($scope.inputAddress.postal === "") {
                $scope.addMoreReady = false;
                return;
            }
            $scope.addMoreReady = true;
        };
        $scope.addAddress = function() {
            $scope.addresses = AddressService.add($scope.inputAddress);
            $scope.inputAddress = angular.copy($scope.resetAddress);
            $scope.checkIfReadyToAdd();
        };
        $scope.removeAddress = function(address) {
            $scope.addresses = AddressService.remove(address);
        };
        $scope.editAddress = function(address) {
            $scope.editingAddress = angular.copy(address);
            $scope.$addressRef = address;
            $("#editingAddressModal").modal();
        };
        $scope.updateAddress = function() {
            $scope.addresses = AddressService.update($scope.$addressRef, $scope.editingAddress);
            $("#editingAddressModal").modal("hide");
            $scope.editingAddress = angular.copy($scope.resetAddress);
        };
    } ]);
})();

(function() {
    angular.module("atUI").factory("AddressService", [ "ErrorMessagesService", function(ErrorMessagesService) {
        var data = [];
        return {
            checkIfValid: function() {
                if (data.length === 0) {
                    this.isInvalid.isIt = true;
                    ErrorMessagesService.msgs.push("This form requires a minimum of 1 address! Please add one.");
                } else {
                    this.isInvalid.isIt = false;
                }
            },
            add: function(address) {
                data.push(address);
                this.checkIfValid();
                return data;
            },
            remove: function(address) {
                var i = data.indexOf(address);
                data.splice(i, 1);
                return data;
            },
            update: function(address, updated) {
                var i = data.indexOf(address);
                data[i] = updated;
                return data;
            },
            getData: function() {
                return data;
            },
            isInvalid: {
                isIt: false
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").directive("addressBox", function() {
        return {
            restrict: "A",
            templateUrl: "assets/templates/apps/reporting/shared/address/addressBox.template.html"
        };
    });
})();

(function() {
    angular.module("atUI").controller("AddressesSmartTable", [ "$scope", "$filter", function($scope, $filter) {
        $scope.addresses = [];
        $scope.addressStates = [ {
            value: "California"
        } ];
        $scope.countries = [ {
            value: "USA"
        } ];
        $scope.types = [ {
            value: "Residence"
        }, {
            value: "Office"
        }, {
            value: "Vacation"
        } ];
        $scope.statuses = [ {
            value: "Current"
        }, {
            value: "Previous"
        } ];
        $scope.showState = function(address) {
            var selected = [];
            if (address.state) {
                selected = $filter("filter")($scope.addressStates, {
                    value: address.state
                });
            }
            return selected.length ? selected[0].value : " - ";
        };
        $scope.showType = function(address) {
            var selected = [];
            if (address.type) {
                selected = $filter("filter")($scope.types, {
                    value: address.type
                });
            }
            return selected.length ? selected[0].value : " - ";
        };
        $scope.showstatus = function(address) {
            var selected = [];
            if (address.status) {
                selected = $filter("filter")($scope.statuses, {
                    value: address.status
                });
            }
            return selected.length ? selected[0].value : " - ";
        };
        $scope.showCountry = function(address) {
            var selected = [];
            if (address.country) {
                selected = $filter("filter")($scope.countries, {
                    value: address.country
                });
            }
            return selected.length ? selected[0].value : " - ";
        };
        $scope.removeAddress = function(i) {
            $scope.addresses.splice(i, 1);
        };
        $scope.addAddress = function() {
            $scope.inserted = {
                id: $scope.addresses.length + 1,
                street1: "",
                street2: "",
                street3: "",
                city: "",
                state: $scope.addressStates[0].value,
                postal: "",
                country: $scope.countries[0].value,
                type: $scope.types[0].value,
                status: $scope.statuses[0].value
            };
            $scope.addresses.push($scope.inserted);
        };
        $scope.addAddress();
    } ]);
})();

(function() {
    angular.module("atUI").controller("MultiAddressController", [ "$scope", function($scope) {
        $scope.moreMode = false;
        $scope.ready = false;
        $scope.readyToAdd = false;
        $scope.addresses = [];
        $scope.states = [ {
            value: "California"
        } ];
        $scope.countries = [ {
            value: "USA"
        } ];
        $scope.types = [ {
            value: "Residence"
        }, {
            value: "Office"
        }, {
            value: "Vacation"
        } ];
        $scope.statuses = [ {
            value: "Current"
        }, {
            value: "Previous"
        } ];
        $scope.resetAddress = {
            street1: "",
            street2: "",
            street3: "",
            city: "",
            state: null,
            postal: "",
            country: $scope.countries[0].value,
            type: null,
            status: null
        };
        $scope.inputAddress = angular.copy($scope.resetAddress);
        $scope.currAddress = angular.copy($scope.resetAddress);
        $scope.currAddress.status = $scope.statuses[0];
        $scope.prevAddress = angular.copy($scope.resetAddress);
        $scope.prevAddress.status = $scope.statuses[1];
        $scope.checkIfAddressIsReady = function() {
            if ($scope.currAddress.street1 === "") {
                $scope.ready = false;
                return;
            }
            if ($scope.currAddress.postal === "") {
                $scope.ready = false;
                return;
            }
            if ($scope.prevAddress.street1 === "") {
                $scope.ready = false;
                return;
            }
            if ($scope.prevAddress.postal === "") {
                $scope.ready = false;
                return;
            }
            $scope.ready = true;
        };
        $scope.checkIfReadyToAdd = function() {
            if ($scope.address.street1 === "") {
                $scope.readyToAdd = false;
                return;
            }
            if ($scope.address.postal === "") {
                $scope.readyToAdd = false;
                return;
            }
            $scope.readyToAdd = true;
        };
        $scope.removeAddress = function(address) {
            var i = $scope.addresses.indexOf(address);
            $scope.addresses[i].$isDeleted = true;
        };
        $scope.addAddresses = function() {
            $scope.addresses.push($scope.currAddress);
            $scope.addresses.push($scope.prevAddress);
            $scope.currAddress = angular.copy($scope.resetAddress);
            $scope.prevAddress = angular.copy($scope.resetAddress);
        };
        $scope.addMore = function() {
            $scope.inputMode = "opened";
            $scope.addAddresses();
        };
        $scope.addAddress = function() {
            $scope.addresses.push($scope.address);
            $scope.address = angular.copy($scope.resetAddress);
        };
    } ]);
})();

angular.module("atUI").factory("IDCardNumberService", function() {
    return {
        data: []
    };
});

(function() {
    angular.module("atUI").controller("IDCardNumberSmartTable", [ "$scope", "$filter", "IDCardNumberService", function($scope, $filter, IDCardNumberService) {
        $scope.idCardNumberTypes = [ {
            value: "driversLicense",
            label: "Drivers License"
        }, {
            value: "passport",
            label: "Passport"
        }, {
            value: "voterID",
            label: "Voter ID"
        }, {
            value: "securityCard",
            label: "Security Card"
        } ];
        $scope.idCardExtraChoices = {
            driversLicense: [ {
                value: "NSW",
                label: "NSW"
            }, {
                value: "VIC",
                label: "VIC"
            }, {
                value: "QLD",
                label: "QLD"
            }, {
                value: "WA",
                label: "WA"
            }, {
                value: "SA",
                label: "SA"
            }, {
                value: "TAS",
                label: "TAS"
            }, {
                value: "ACT",
                label: "ACT"
            }, {
                value: "NT",
                label: "NT"
            }, {
                value: "Overseas",
                label: "Overseas"
            } ],
            passport: [],
            voterID: [],
            securityCard: []
        };
        $scope.idCards = IDCardNumberService;
        $scope.idCardNumberTypeChanged = function(idCard) {
            if ($scope.idCardExtraChoices[this.$data].length == 0) {
                idCard.extraChoices = [];
                idCard.extra = null;
                idCard.disableExtra = true;
            } else {
                idCard.extraChoices = $scope.idCardExtraChoices[this.$data];
                idCard.extra = $scope.idCardExtraChoices[this.$data][0].value;
                idCard.disableExtra = false;
            }
        };
        $scope.showIDCardNumberType = function(idCard) {
            var selected = [];
            if (idCard.type) {
                selected = $filter("filter")($scope.idCardNumberTypes, {
                    value: idCard.type
                });
            }
            return selected.length ? selected[0].label : "Not Set";
        };
        $scope.showExtraInfo = function(idCard) {
            if ($scope.idCardExtraChoices[idCard.type].length === 0) {
                return "Not Needed";
            } else {
                var selected = [];
                if (idCard.extra) {
                    selected = $filter("filter")(idCard.extraChoices, {
                        value: idCard.extra
                    });
                }
                return selected.length ? selected[0].label : "Error";
            }
        };
        $scope.removeIDCard = function(i) {
            $scope.idCards.data.splice(i, 1);
        };
        $scope.addIDCard = function() {
            $scope.inserted = {
                id: $scope.idCards.data.length + 1,
                number: "",
                type: $scope.idCardNumberTypes[0].value,
                extra: $scope.idCardExtraChoices[$scope.idCardNumberTypes[0].value][0].value,
                extraChoices: $scope.idCardExtraChoices[$scope.idCardNumberTypes[0].value],
                disableExtra: false
            };
            $scope.idCards.data.push($scope.inserted);
            console.log($scope.idCards);
        };
        $scope.addIfFirst = function() {
            if ($scope.idCards.data.length === 0) {
                $scope.addIDCard();
            }
        };
    } ]);
})();

(function() {
    var app = angular.module("atUI");
    app.config([ "$routeProvider", function($routeProvider) {
        $routeProvider.when("/consumerCreditReport", {
            templateUrl: "assets/templates/apps/reportTool/inputScreen/consumer-input.html",
            controller: "InputScreenController"
        }).when("/consumerCreditReport/report", {
            templateUrl: "assets/templates/apps/reportTool/reportScreen/consumer-report.html",
            controller: "ReportController"
        });
    } ]);
})();

(function() {
    angular.module("atUI").filter("phoneNumber", function() {
        return function(tel) {
            if (!tel) {
                return "";
            }
            var value = tel.toString().trim().replace(/^\+/, "");
            if (value.match(/[^0-9]/)) {
                return tel;
            }
            var country, city, number;
            switch (value.length) {
              case 10:
                country = 1;
                city = value.slice(0, 3);
                number = value.slice(3);
                break;

              case 11:
                country = value[0];
                city = value.slice(1, 4);
                number = value.slice(4);
                break;

              case 12:
                country = value.slice(0, 3);
                city = value.slice(3, 5);
                number = value.slice(5);
                break;

              default:
                return tel;
            }
            if (country == 1) {
                country = "";
            }
            number = number.slice(0, 3) + "-" + number.slice(3);
            return (country + " (" + city + ") " + number).trim();
        };
    });
})();

angular.module("atUI").factory("PhoneNumberService", function() {
    return {
        data: []
    };
});

(function() {
    angular.module("atUI").controller("PhoneNumberSmartTable", [ "$scope", "$filter", "PhoneNumberService", function($scope, $filter, PhoneNumberService) {
        $scope.phoneNumberTypes = [ {
            value: "Home"
        }, {
            value: "Mobile"
        }, {
            value: "Office"
        } ];
        $scope.phoneNumbers = PhoneNumberService;
        $scope.showPhoneNumberType = function(phoneNumber) {
            var selected = [];
            if (phoneNumber.type) {
                selected = $filter("filter")($scope.phoneNumberTypes, {
                    value: phoneNumber.type
                });
            }
            return selected.length ? selected[0].value : "Not Set";
        };
        $scope.removePhoneNumber = function(i) {
            $scope.phoneNumbers.data.splice(i, 1);
        };
        $scope.addPhoneNumber = function() {
            $scope.inserted = {
                id: $scope.phoneNumbers.data.length + 1,
                number: "",
                type: $scope.phoneNumberTypes[0].value
            };
            $scope.phoneNumbers.data.push($scope.inserted);
        };
        $scope.addIfFirst = function() {
            if ($scope.phoneNumbers.data.length === 0) {
                $scope.addPhoneNumber();
            }
        };
    } ]);
})();

(function() {
    angular.module("atUI").controller("ProductAddonsController", [ "$scope", function($scope) {
        $scope.productAddonsDisplay = true;
        $scope.showMore = false;
        $scope.showMoreToggleLabel = "Show More";
        var $addonsBox = $("#productAddOnsBox");
        if ($addonsBox.find(".addons").length > 4) {
            $scope.showMore = true;
            $scope.productAddonsDisplay = false;
        }
        $scope.toggleProductAddonsMoreLess = function() {
            if ($scope.productAddonsDisplay === true) {
                $scope.productAddonsDisplay = false;
                $scope.showMoreToggleLabel = "Show More";
            } else {
                $scope.productAddonsDisplay = true;
                $scope.showMoreToggleLabel = "Show Less";
            }
        };
    } ]);
})();